<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="manifest" href="./manifest.webmanifest" />
    <meta name="theme-color" content="#0b1220" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="Alpenwetter" />
    <!-- iOS uses apple-touch-icon for "Zum Home-Bildschirm" (not the favicon). -->
    <link rel="apple-touch-icon" sizes="180x180" href="./icons/apple-touch-icon.png?v=3" />
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="./icons/apple-touch-icon.png?v=3" />
    <link rel="icon" type="image/png" sizes="192x192" href="./icons/icon-192.png" />
    <link rel="icon" type="image/png" sizes="512x512" href="./icons/icon-512.png" />
    <title>ALPENWETTER LAB • Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <script src="https://cdn.jsdelivr.net/npm/proj4@2.9.2/dist/proj4.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
        href="https://fonts.googleapis.com/css2?family=Fraunces:opsz,wght@9..144,400;9..144,600;9..144,700&family=Sora:wght@400;500;600;700&display=swap"
        rel="stylesheet" />
    <style>
        :root {
            color-scheme: dark;
            --bg: #090f18;
            --bg-2: #0b1c2c;
            --surface: rgba(9, 16, 28, 0.82);
            --panel: rgba(12, 22, 38, 0.9);
            --card: rgba(13, 23, 40, 0.8);
            --card-strong: rgba(19, 33, 54, 0.94);
            --text: #f8fafc;
            --text-soft: #d8e4f2;
            --muted: #9fb2c7;
            --accent: #5de0e6;
            --accent-2: #facc15;
            --accent-3: #fb7185;
            --accent-cool: #60a5fa;
            --score-good: #22c55e;
            --score-mid: #facc15;
            --score-bad: #fb7185;
            --warning: #f59e0b;
            --line: rgba(148, 163, 184, 0.16);
            --line-strong: rgba(148, 163, 184, 0.28);
            --glow: rgba(94, 234, 212, 0.25);
            --shadow: 0 24px 60px rgba(4, 10, 20, 0.45);
            --shadow-soft: 0 18px 38px rgba(4, 10, 20, 0.38);
            --shadow-strong: 0 28px 70px rgba(4, 10, 20, 0.55);
            --ring: rgba(94, 234, 212, 0.55);
            --radius: 18px;
            --font-body: "Sora", "Space Grotesk", "IBM Plex Sans", "Fira Sans", sans-serif;
            --font-display: "Fraunces", "Cormorant Garamond", serif;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            min-height: 100vh;
            font-family: var(--font-body);
            font-size: 15px;
            line-height: 1.55;
            color: var(--text);
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            font-kerning: normal;
            background:
                radial-gradient(1200px 800px at 5% -20%, rgba(96, 165, 250, 0.22) 0%, rgba(11, 17, 27, 0) 60%),
                radial-gradient(1000px 650px at 95% 0%, rgba(250, 204, 21, 0.2) 0%, rgba(11, 17, 27, 0) 60%),
                radial-gradient(900px 700px at 85% 90%, rgba(34, 197, 94, 0.12) 0%, rgba(11, 17, 27, 0) 60%),
                linear-gradient(180deg, #090f18 0%, #0b1626 35%, #0a101a 100%);
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: "";
            position: fixed;
            inset: -20%;
            background:
                radial-gradient(520px 260px at 10% 20%, rgba(94, 234, 212, 0.22), transparent 60%),
                radial-gradient(420px 260px at 85% 10%, rgba(250, 204, 21, 0.2), transparent 60%),
                radial-gradient(520px 340px at 90% 80%, rgba(96, 165, 250, 0.18), transparent 60%);
            filter: blur(10px);
            opacity: 0.65;
            mix-blend-mode: screen;
            pointer-events: none;
            z-index: 0;
        }

        body::after {
            content: "";
            position: fixed;
            inset: 0;
            background-image: radial-gradient(rgba(255, 255, 255, 0.06) 1px, transparent 1px);
            background-size: 3px 3px;
            opacity: 0.14;
            pointer-events: none;
            z-index: 0;
        }

        .app {
            max-width: 1200px;
            margin: 0 auto;
            padding-bottom: 48px;
            position: relative;
            z-index: 1;
        }

        .hero {
            margin: 20px 20px 0;
            padding: 28px 32px;
            border-radius: calc(var(--radius) + 6px);
            display: grid;
            grid-template-columns: 1.15fr 0.85fr;
            gap: 28px;
            background:
                linear-gradient(135deg, rgba(94, 234, 212, 0.22), rgba(15, 23, 42, 0.3) 55%),
                linear-gradient(180deg, rgba(15, 25, 40, 0.98), rgba(10, 20, 34, 0.8));
            border: 1px solid rgba(148, 163, 184, 0.24);
            box-shadow: var(--shadow-strong);
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(12px);
            animation: heroIn 0.6s ease both;
        }

        .hero::before {
            content: "";
            position: absolute;
            inset: -40% 40% 50% -20%;
            background: radial-gradient(500px 240px at 30% 20%, rgba(96, 165, 250, 0.2), transparent 70%);
            opacity: 0.6;
            pointer-events: none;
        }

        .hero::after {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(420px 160px at 85% 0%, rgba(250, 204, 21, 0.22), transparent 60%);
            opacity: 0.65;
            pointer-events: none;
        }

        .hero-left,
        .hero-right {
            position: relative;
            z-index: 1;
        }

        .eyebrow {
            text-transform: uppercase;
            letter-spacing: 0.32em;
            font-size: 11px;
            color: var(--text-soft);
            margin-bottom: 10px;
        }

        .title {
            font-family: var(--font-display);
            font-size: 36px;
            font-weight: 600;
            letter-spacing: 0.6px;
            line-height: 1.05;
            text-shadow: 0 18px 40px rgba(6, 10, 20, 0.6);
        }

        .subtitle {
            color: var(--text-soft);
            margin-top: 8px;
            font-size: 14px;
            max-width: 520px;
        }

        .status {
            margin-top: 10px;
            font-size: 13px;
            color: var(--accent);
        }

        .hero-kpis {
            display: grid;
            gap: 14px;
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        .kpi {
            padding: 14px 16px;
            border-radius: 14px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.08), rgba(12, 22, 38, 0.7));
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .kpi-label {
            font-size: 11px;
            color: var(--muted);
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        .kpi-value {
            font-size: 22px;
            margin-top: 6px;
            font-weight: 600;
        }

        .kpi-sub {
            margin-top: 4px;
            font-size: 12px;
            color: var(--muted);
        }

        .score-good {
            color: var(--score-good);
            text-shadow: 0 0 12px rgba(34, 197, 94, 0.35);
        }

        .score-mid {
            color: var(--score-mid);
            text-shadow: 0 0 12px rgba(250, 204, 21, 0.3);
        }

        .score-bad {
            color: var(--score-bad);
            text-shadow: 0 0 12px rgba(248, 113, 113, 0.28);
        }

        .alert {
            margin: 12px 32px 0;
            padding: 10px 12px;
            border-radius: 10px;
            background: rgba(245, 158, 11, 0.12);
            color: var(--warning);
            font-size: 13px;
            display: none;
        }

        .toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            padding: 18px 32px 0;
            flex-wrap: wrap;
        }

        .tabs {
            display: flex;
            gap: 8px;
            align-items: center;
            min-width: 0;
            max-width: 100%;
        }

        .tab-btn {
            border: 1px solid var(--line);
            padding: 8px 16px;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(10, 18, 32, 0.7), rgba(12, 20, 34, 0.45));
            color: var(--text);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            flex: 0 0 auto;
            white-space: nowrap;
            backdrop-filter: blur(8px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .tab-btn.active {
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.3), rgba(250, 204, 21, 0.2));
            color: var(--text);
            border-color: rgba(94, 234, 212, 0.5);
            box-shadow: 0 12px 30px rgba(6, 10, 20, 0.45), inset 0 1px 0 rgba(255, 255, 255, 0.14);
        }

        .tab-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(94, 234, 212, 0.6);
            box-shadow: 0 10px 20px rgba(6, 10, 20, 0.35);
        }

        .tab-btn:focus-visible {
            outline: 2px solid rgba(94, 234, 212, 0.7);
            outline-offset: 2px;
        }

        .location {
            display: flex;
            align-items: center;
            gap: 8px;
            background: linear-gradient(135deg, rgba(10, 18, 32, 0.7), rgba(12, 20, 34, 0.5));
            border: 1px solid rgba(148, 163, 184, 0.2);
            padding: 6px 12px;
            border-radius: 999px;
            position: relative;
            flex-wrap: wrap;
        }

        .location label {
            color: var(--muted);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
        }

        .location select {
            appearance: auto;
            background: rgba(10, 18, 32, 0.92);
            border: 1px solid var(--line);
            color: var(--text);
            font-size: 13px;
            font-family: var(--font-body);
            outline: none;
            padding: 6px 26px 6px 10px;
            border-radius: 10px;
            min-width: 180px;
        }

        .location input {
            background: rgba(10, 18, 32, 0.92);
            border: 1px solid var(--line);
            color: var(--text);
            font-size: 13px;
            font-family: var(--font-body);
            outline: none;
            padding: 6px 10px;
            border-radius: 10px;
            min-width: 220px;
        }

        .location select,
        .location input {
            transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .location select:focus-visible,
        .location input:focus-visible {
            border-color: var(--ring);
            box-shadow: 0 0 0 3px rgba(94, 234, 212, 0.22);
        }

        .location .mini-btn {
            border: 1px solid var(--line);
            background: linear-gradient(135deg, rgba(20, 30, 48, 0.9), rgba(10, 18, 32, 0.85));
            color: var(--text);
            font-size: 12px;
            padding: 6px 10px;
            border-radius: 999px;
            cursor: pointer;
            font-weight: 600;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 6px 14px rgba(4, 10, 20, 0.25);
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .location .pin-btn {
            border: 1px solid rgba(250, 204, 21, 0.6);
            color: #facc15;
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.92), rgba(17, 24, 39, 0.85));
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 10px 18px rgba(12, 20, 34, 0.35);
        }

        .location .pin-btn:hover {
            border-color: rgba(250, 204, 21, 0.9);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 14px 26px rgba(12, 20, 34, 0.45);
        }

        .location .mini-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(94, 234, 212, 0.6);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.12), 0 12px 24px rgba(4, 10, 20, 0.35);
        }

        .location .mini-btn:focus-visible {
            outline: 2px solid rgba(94, 234, 212, 0.65);
            outline-offset: 2px;
        }

        .location-suggest {
            width: 100%;
            margin-top: 6px;
            border: 1px solid var(--line);
            border-radius: 12px;
            background: rgba(10, 18, 32, 0.96);
            box-shadow: 0 16px 32px rgba(4, 10, 20, 0.45);
            overflow: hidden;
            max-height: 280px;
            overflow-y: auto;
        }

        .location-suggest[hidden] {
            display: none !important;
        }

        .location-suggest-item {
            width: 100%;
            border: 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
            background: transparent;
            color: var(--text);
            text-align: left;
            padding: 10px 12px;
            cursor: pointer;
            transition: background 0.15s ease;
        }

        .location-suggest-item:last-child {
            border-bottom: 0;
        }

        .location-suggest-item:hover,
        .location-suggest-item.active {
            background: rgba(94, 234, 212, 0.18);
        }

        .location-suggest-title {
            font-size: 13px;
            line-height: 1.2;
        }

        .location-suggest-meta {
            margin-top: 3px;
            font-size: 11px;
            color: var(--muted);
            letter-spacing: 0.06em;
            text-transform: uppercase;
        }

        .location-suggest-empty {
            padding: 10px 12px;
            font-size: 12px;
            color: var(--muted);
        }

        .toolbar-actions {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }

        .pinned-bar {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 10px 18px;
            margin: 10px 20px 0;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(10, 18, 32, 0.7), rgba(7, 12, 22, 0.5));
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
        }

        .pin-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(94, 234, 212, 0.28);
            background: linear-gradient(135deg, rgba(16, 28, 46, 0.85), rgba(12, 20, 34, 0.68));
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06), 0 6px 14px rgba(4, 10, 20, 0.24);
        }

        .pin-chip .remove {
            opacity: 0.7;
            font-weight: 700;
            margin-left: 4px;
        }

        .pin-chip:hover {
            border-color: rgba(94, 234, 212, 0.5);
            transform: translateY(-1px);
            box-shadow: 0 12px 24px rgba(4, 10, 20, 0.4);
        }

        .ghost-btn {
            border: 1px solid var(--line);
            padding: 8px 14px;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(10, 18, 32, 0.8), rgba(10, 18, 32, 0.5));
            color: var(--text);
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            transition: all 0.2s ease;
            backdrop-filter: blur(8px);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .ghost-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(94, 234, 212, 0.5);
            box-shadow: 0 10px 22px rgba(4, 10, 20, 0.35);
        }

        .inline-label {
            color: var(--muted);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.14em;
        }

        .inline-select {
            margin-left: 8px;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 12px;
        }

        .inline-input {
            margin-left: 8px;
            padding: 4px 8px;
            border-radius: 8px;
            font-size: 12px;
            width: 90px;
        }

        .alt-options {
            display: flex;
            flex-wrap: wrap;
            gap: 8px 12px;
            margin-top: 6px;
        }

        .alt-option {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: var(--text);
        }

        .page {
            display: none;
        }

        .page.active {
            display: block;
            animation: fadeIn 0.4s ease;
        }

        .page-filter {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 10px 32px 0;
        }

        .page-filter .inline-select {
            margin-left: 8px;
        }

        .grid {
            display: grid;
            gap: 18px;
            grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
            padding: 20px 32px 32px;
        }

        .grid-wide {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        }

        .para-layout {
            grid-template-columns: minmax(320px, 1.2fr) minmax(320px, 1fr);
            align-items: stretch;
        }

        .map-panel {
            min-height: 420px;
        }

        .card {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(0, 0, 0, 0.15)), var(--card);
            border-radius: var(--radius);
            padding: 16px;
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(148, 163, 184, 0.2);
            backdrop-filter: blur(8px);
            position: relative;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            animation: liftIn 0.6s ease both;
        }

        .card::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(120deg, rgba(94, 234, 212, 0.18), transparent 55%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .card::after {
            content: "";
            position: absolute;
            inset: 1px;
            border-radius: calc(var(--radius) - 1px);
            border: 1px solid rgba(255, 255, 255, 0.04);
            pointer-events: none;
            opacity: 0.6;
        }

        .card:hover {
            transform: translateY(-4px);
            border-color: rgba(94, 234, 212, 0.45);
            box-shadow: var(--shadow-strong);
        }

        .card:hover::before {
            opacity: 0.25;
        }

        .card h3 {
            margin: 0 0 8px;
            font-size: 12px;
            color: var(--muted);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.22em;
        }

        .card.accent {
            background: var(--card-strong);
            border-color: rgba(250, 204, 21, 0.45);
        }

        .card.accent .value {
            color: var(--accent-2);
        }

        .card .value.score-good,
        .kpi-value.score-good {
            color: var(--score-good);
            text-shadow: 0 0 12px rgba(34, 197, 94, 0.35);
        }

        .card .value.score-mid,
        .kpi-value.score-mid {
            color: var(--score-mid);
            text-shadow: 0 0 12px rgba(250, 204, 21, 0.3);
        }

        .card .value.score-bad,
        .kpi-value.score-bad {
            color: var(--score-bad);
            text-shadow: 0 0 12px rgba(248, 113, 113, 0.28);
        }

        .value {
            font-size: 28px;
            font-weight: 600;
            letter-spacing: 0.3px;
            text-shadow: 0 0 20px rgba(94, 234, 212, 0.12);
        }

        .subvalue {
            margin-top: 6px;
            color: var(--muted);
            font-size: 13px;
        }

        .tag-row {
            margin-top: 10px;
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }

        .tag {
            padding: 4px 8px;
            border-radius: 999px;
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.2), rgba(96, 165, 250, 0.16));
            border: 1px solid rgba(94, 234, 212, 0.25);
            color: var(--accent);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        #map {
            height: 100%;
            min-height: 420px;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-soft);
            border: 1px solid rgba(148, 163, 184, 0.24);
            background: #0a101a;
        }

        .map-panel {
            min-height: 420px;
            position: relative;
        }

        .map-panel.map-panel-full {
            min-height: 520px;
        }

        .map-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 14px;
            padding: 14px 32px 0;
            flex-wrap: wrap;
        }

        .map-layer-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .map-layer-btn {
            border: 1px solid rgba(148, 163, 184, 0.24);
            background: linear-gradient(135deg, rgba(10, 18, 32, 0.8), rgba(10, 18, 32, 0.55));
            color: var(--text);
            font-size: 11px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            padding: 7px 14px;
            border-radius: 999px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .map-layer-btn.active {
            border-color: rgba(94, 234, 212, 0.6);
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.28), rgba(96, 165, 250, 0.2));
            box-shadow: 0 12px 26px rgba(4, 10, 20, 0.45);
        }

        .map-layer-btn:hover {
            transform: translateY(-1px);
            border-color: rgba(94, 234, 212, 0.5);
        }

        .map-meta {
            color: var(--muted);
            font-size: 12px;
            letter-spacing: 0.08em;
            text-transform: uppercase;
        }

        .map-time {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .map-time input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 180px;
            height: 6px;
            border-radius: 999px;
            background: rgba(148, 163, 184, 0.2);
            outline: none;
        }

        .map-time input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.9), rgba(96, 165, 250, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 16px rgba(4, 10, 20, 0.45);
        }

        .map-time input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.9), rgba(96, 165, 250, 0.9));
            border: 1px solid rgba(255, 255, 255, 0.6);
            box-shadow: 0 8px 16px rgba(4, 10, 20, 0.45);
        }

        .map-time-label {
            font-size: 12px;
            color: var(--text-soft);
            letter-spacing: 0.08em;
            text-transform: uppercase;
            min-width: 120px;
        }

        .map-legend {
            position: absolute;
            left: 16px;
            bottom: 16px;
            padding: 10px 12px;
            border-radius: 12px;
            background: rgba(10, 18, 32, 0.85);
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 14px 28px rgba(4, 10, 20, 0.45);
            backdrop-filter: blur(8px);
            min-width: 160px;
        }

        .map-legend-title {
            font-size: 11px;
            color: var(--text-soft);
            letter-spacing: 0.16em;
            text-transform: uppercase;
        }

        .map-legend-bar {
            height: 6px;
            border-radius: 999px;
            margin: 8px 0 6px;
            background: linear-gradient(90deg, #38bdf8, #facc15, #f97316, #ef4444);
        }

        .map-legend-labels {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: var(--muted);
        }

        .panel {
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(0, 0, 0, 0.2)), var(--panel);
            border-radius: var(--radius);
            padding: 18px;
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: var(--shadow-soft);
            backdrop-filter: blur(8px);
            animation: liftIn 0.6s ease both;
        }

        .panel h3 {
            margin-top: 0;
            font-size: 13px;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--muted);
        }

        .panel.note-panel {
            background: linear-gradient(135deg, rgba(94, 234, 212, 0.12), rgba(15, 25, 40, 0.7));
        }

        .thermik-panel {
            background: linear-gradient(180deg, rgba(13, 23, 40, 0.92), rgba(10, 18, 32, 0.85));
            border-color: rgba(94, 234, 212, 0.28);
            box-shadow: 0 22px 50px rgba(4, 10, 20, 0.55);
        }

        .thermik-panel .chart-sub {
            color: rgba(216, 228, 242, 0.86);
        }

        .thermik-panel h3 {
            color: rgba(248, 250, 252, 0.95);
        }

        .thermik-tooltip {
            position: fixed;
            z-index: 50;
            display: none;
            min-width: 160px;
            max-width: 240px;
            padding: 8px 10px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.95);
            color: #f8fafc;
            font-size: 11px;
            line-height: 1.4;
            box-shadow: 0 18px 36px rgba(15, 23, 42, 0.35);
            pointer-events: none;
        }

        .thermik-tooltip strong {
            display: block;
            font-size: 12px;
            margin-bottom: 4px;
            color: #fbbf24;
        }

        canvas {
            width: 100%;
            max-height: 240px;
        }

        .chart-wrap {
            position: relative;
            height: 180px;
            margin-top: 8px;
        }

        .thermik-wrap {
            height: 420px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-x: contain;
            border-radius: 14px;
        }

        .thermik-wrap::-webkit-scrollbar {
            height: 8px;
        }

        .thermik-wrap::-webkit-scrollbar-thumb {
            background: rgba(15, 23, 42, 0.22);
            border-radius: 999px;
        }

        .thermik-wrap::-webkit-scrollbar-track {
            background: transparent;
        }

        #thermikMatrix {
            max-height: 420px;
        }

        .chart-card {
            padding: 12px 12px 6px;
            border-radius: 14px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            background: linear-gradient(180deg, rgba(12, 20, 34, 0.75), rgba(8, 14, 26, 0.6));
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.04);
        }

        /* iOS Safari/PWA sometimes keeps Chart.js inline canvas widths after rotation.
           Force canvases to respect their container so charts never overflow the card. */
        .chart-card .chart-wrap {
            overflow: hidden;
        }

        .chart-card canvas {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-grid {
            display: grid;
            gap: 12px;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            margin-top: 10px;
        }

        .chart-title {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 0.18em;
            color: var(--muted);
        }

        .chart-title span {
            font-size: 11px;
            letter-spacing: 0.12em;
        }

        .chart-sub {
            margin-top: 4px;
            font-size: 11px;
            color: rgba(159, 178, 199, 0.8);
        }

        .note {
            color: var(--muted);
            font-size: 12px;
            margin-top: 8px;
        }

        .list {
            margin: 0;
            padding: 0;
            list-style: none;
            display: grid;
            gap: 8px;
        }

        .list li {
            position: relative;
            padding-left: 16px;
            color: var(--muted);
            font-size: 13px;
        }

        .start-window .list {
            margin-top: 10px;
        }

        .list li::before {
            content: "*";
            position: absolute;
            left: 0;
            color: var(--accent);
        }

        select {
            background: rgba(10, 18, 32, 0.8);
            color: var(--text);
            border: 1px solid var(--line);
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.06);
        }

        .grid>* {
            animation-delay: calc(var(--stagger, 0) * 60ms);
        }

        .grid>*:nth-child(1) {
            --stagger: 1;
        }

        .grid>*:nth-child(2) {
            --stagger: 2;
        }

        .grid>*:nth-child(3) {
            --stagger: 3;
        }

        .grid>*:nth-child(4) {
            --stagger: 4;
        }

        .grid>*:nth-child(5) {
            --stagger: 5;
        }

        .grid>*:nth-child(6) {
            --stagger: 6;
        }

        .grid>*:nth-child(7) {
            --stagger: 7;
        }

        .grid>*:nth-child(8) {
            --stagger: 8;
        }

        .grid>*:nth-child(9) {
            --stagger: 9;
        }

        .grid>*:nth-child(10) {
            --stagger: 10;
        }

        .grid>*:nth-child(11) {
            --stagger: 11;
        }

        .grid>*:nth-child(12) {
            --stagger: 12;
        }

        @keyframes heroIn {
            from {
                opacity: 0;
                transform: translateY(-10px) scale(0.99);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes liftIn {
            from {
                opacity: 0;
                transform: translateY(16px) scale(0.98);
            }

            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @media (max-width: 960px) {
            .hero {
                grid-template-columns: 1fr;
                margin: 16px;
                padding: 24px;
            }

            .hero-kpis {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .para-layout {
                grid-template-columns: 1fr;
            }

            .toolbar {
                padding: 14px 18px 0;
                flex-direction: column;
                align-items: stretch;
            }

            .tabs {
                order: 1;
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                overflow-x: auto;
                overflow-y: hidden;
                -webkit-overflow-scrolling: touch;
                scroll-snap-type: x mandatory;
                scroll-padding: 12px;
                padding-bottom: 10px;
            }

            .tab-btn {
                scroll-snap-align: start;
            }

            .toolbar-actions {
                order: 0;
                width: 100%;
                justify-content: space-between;
            }

            .location {
                width: 100%;
                flex-wrap: wrap;
                border-radius: 16px;
            }

            .location label {
                flex: 0 0 100%;
                font-size: 10px;
                letter-spacing: 0.14em;
            }

            .location input {
                /* iOS Safari auto-zooms form controls when font-size < 16px */
                font-size: 16px;
                flex: 1 1 100%;
                min-width: 0;
                width: 100%;
            }

            .inline-select {
                font-size: 16px;
            }

            .location .mini-btn {
                padding: 8px 12px;
            }

            .pinned-bar {
                padding: 8px 14px;
                margin: 8px 12px 0;
                overflow-x: auto;
                flex-wrap: nowrap;
            }

            .chart-grid {
                grid-template-columns: 1fr;
            }

            .page-filter {
                padding: 10px 18px 0;
                justify-content: flex-start;
            }

            .grid {
                padding: 16px 18px 24px;
            }

            #map {
                min-height: 320px;
            }

            .chart-wrap {
                height: 210px;
            }

            .thermik-wrap {
                height: 360px;
            }

            #thermikMatrix {
                max-height: 360px;
            }
        }

        @media (max-width: 720px) {
            .hero {
                margin: 12px;
                padding: 20px;
            }

            .hero-kpis {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }

            .toolbar {
                padding: 12px 14px 0;
            }

            .grid {
                padding: 16px 14px 24px;
            }

            #map {
                height: 280px;
            }
        }

        @media (max-width: 520px) {
            .title {
                font-size: 28px;
            }

            .hero-kpis {
                grid-template-columns: 1fr;
            }

            .kpi {
                padding: 12px 12px;
            }

            .tabs {
                flex-wrap: wrap;
                overflow-x: hidden;
                scroll-snap-type: none;
                padding-bottom: 0;
                gap: 6px;
            }

            .tab-btn {
                padding: 8px 12px;
                font-size: 12px;
                letter-spacing: 0.11em;
            }

            .chart-wrap {
                height: 220px;
            }

            .thermik-wrap {
                height: 340px;
            }

            #thermikMatrix {
                max-height: 340px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>

<body>
    <div class="app">
        <div class="hero">
            <div class="hero-left">
                <div class="eyebrow">ALPENWETTER LAB</div>
                <div class="title" id="heroTitle">Dashboard</div>
                <div class="subtitle" id="heroSubtitle"></div>
                <div class="status" id="dataStatus">Aktualisiere…</div>

            </div>
            <div class="hero-right">
                <div class="hero-kpis">
                    <div class="kpi">
                        <div class="kpi-label">Temperatur</div>
                        <div class="kpi-value" id="heroTemp">?</div>
                        <div class="kpi-sub" id="heroTempRange">?</div>
                    </div>
                    <div class="kpi">
                        <div class="kpi-label">Wind</div>
                        <div class="kpi-value" id="heroWind">?</div>
                        <div class="kpi-sub" id="heroWindRange">?</div>
                    </div>
                    <div class="kpi">
                        <div class="kpi-label">Flugscore</div>
                        <div class="kpi-value" id="heroHammer">?</div>
                        <div class="kpi-sub" id="heroHammerHint">?</div>
                    </div>
                    <div class="kpi">
                        <div class="kpi-label">Radscore</div>
                        <div class="kpi-value" id="heroRide">?</div>
                        <div class="kpi-sub" id="heroRideHint">?</div>
                    </div>
                </div>
            </div>
        </div>

        <div class="toolbar">
            <div class="tabs">
                <button class="tab-btn active" id="tabOverview" type="button"
                    onclick="showPage('overview')">&Uuml;bersicht</button>
                <button class="tab-btn" id="tabCycling" type="button" onclick="showPage('cycling')">Radfahren</button>
                <button class="tab-btn" id="tabParagliding" type="button"
                    onclick="showPage('paragliding')">Paragleiten</button>
                <button class="tab-btn" id="tabMap" type="button" onclick="showPage('map')">Karte</button>
                <button class="tab-btn" id="tabCrossCountry" type="button" onclick="showPage('xc')">Langlaufen</button>
                <button class="tab-btn" id="tabSkitour" type="button" onclick="showPage('skitour')">Skitouren</button>
            </div>
            <div class="toolbar-actions">
                <div class="location">
                    <label for="customLocationInput">Suche</label>
                    <input id="customLocationInput" type="text" placeholder="Ort oder lat, lon" />
                    <button class="mini-btn" id="customLocationBtn" type="button">Los</button>
                    <button class="mini-btn pin-btn" id="pinLocationBtn" type="button">Anpinnen</button>
                    <div class="location-suggest" id="locationSuggest" role="listbox" hidden></div>
                </div>
            </div>
        </div>
        <div class="pinned-bar" id="pinnedLocations"></div>
        <div class="alert" id="alertBox"></div>

        <section class="page active" id="pageOverview">
            <section class="grid grid-wide" id="overviewGrid"></section>
            <section class="grid">
                <div class="card accent">
                    <h3>Beste Flugbedingungen</h3>
                    <div class="value" id="bestFlight">?</div>
                    <div class="subvalue" id="bestFlightHint">?</div>
                </div>
                <div class="card accent">
                    <h3>Bestes Radwetter</h3>
                    <div class="value" id="bestRide">?</div>
                    <div class="subvalue" id="bestRideHint">?</div>
                </div>
                <div class="card accent">
                    <h3>Schönstes Wetter</h3>
                    <div class="value" id="bestBeauty">?</div>
                    <div class="subvalue" id="bestBeautyHint">?</div>
                </div>
            </section>
        </section>

        <section class="page" id="pageParagliding">
            <section class="page-filter">
                <div>
                    <label for="paraDaySelect" class="inline-label">Tag</label>
                    <select id="paraDaySelect" class="inline-select"></select>
                </div>
            </section>
            <section class="grid">
                <div class="card accent">
                    <h3>Flugscore</h3>
                    <div class="value" id="hammerScore">?</div>
                    <div class="subvalue" id="hammerHint">?</div>
                    <div class="subvalue" id="hammerReasons">?</div>
                </div>
                <div class="card">
                    <h3>Temperatur</h3>
                    <div class="value" id="tempValue">?</div>
                    <div class="subvalue" id="tempRange">?</div>
                </div>
                <div class="card">
                    <h3>Wind</h3>
                    <div class="value" id="windValue">?</div>
                    <div class="subvalue" id="windHeight">Höhe: 10 m</div>
                    <div class="subvalue" id="windRange">?</div>
                </div>
                <div class="card">
                    <h3>Wolken</h3>
                    <div class="value" id="cloudValue">?</div>
                </div>
                <div class="card">
                    <h3>Niederschlag</h3>
                    <div class="value" id="precipValue">?</div>
                    <div class="subvalue" id="precipSum">?</div>
                </div>
                <div class="card">
                    <h3>Luftfeuchte</h3>
                    <div class="value" id="rhValue">?</div>
                </div>
                <div class="card">
                    <h3>Sonne</h3>
                    <div class="value" id="sunValue">?</div>
                    <div class="subvalue" id="sunSum">?</div>
                </div>
                <div class="card">
                    <h3>Thermik</h3>
                    <div class="value" id="thermikIndex">?</div>
                    <div class="subvalue" id="thermikHint">?</div>
                </div>
                <div class="card start-window">
                    <h3>Startfenster</h3>
                    <div class="value" id="startWindowValue">?</div>
                    <div class="subvalue" id="startWindowPeak">?</div>
                    <div class="subvalue" id="startWindowArrive">?</div>
                    <div class="subvalue" id="startWindowUncertainty">?</div>
                    <ul class="list" id="startWindowReasons"></ul>
                </div>
                <div class="card">
                    <h3>Atmosphäre</h3>
                    <div class="value" id="profileStability">?</div>
                    <div class="subvalue" id="profileLapse">?</div>
                    <div class="subvalue" id="profileInversion">?</div>
                </div>
                <div class="card">
                    <h3>Windprofil</h3>
                    <div class="value" id="windProfile">?</div>
                    <div class="subvalue" id="windShear">?</div>
                </div>
                <div class="card">
                    <h3>Windchill</h3>
                    <div class="value" id="paraWindChillValue">?</div>
                    <div class="subvalue" id="paraWindChillHint">?</div>
                </div>
            </section>

            <section class="grid">
                <div class="panel">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                        <h3 style="margin:0">48h Verlauf (Paragleiten)</h3>
                    </div>
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title">Temperatur <span>C</span></div>
                            <div class="chart-sub">Stundenwerte in lokaler Zeit</div>
                            <div class="chart-wrap"><canvas id="tempChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Wind <span>km/h</span></div>
                            <div class="chart-sub">Takeoff-Höhe in lokaler Zeit</div>
                            <div class="chart-wrap"><canvas id="windChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Wolken <span>%</span></div>
                            <div class="chart-sub">Gesamtbedeckung in lokaler Zeit</div>
                            <div class="chart-wrap"><canvas id="cloudChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Niederschlag <span>mm</span></div>
                            <div class="chart-sub">Stündliche Summe in lokaler Zeit</div>
                            <div class="chart-wrap"><canvas id="precipChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Thermik & Flyability <span>Score</span></div>
                            <div class="chart-sub">0-1 Skala - lokale Zeit</div>
                            <div class="chart-wrap"><canvas id="maturityChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Inversion & BL <span>m AGL</span></div>
                            <div class="chart-sub">Basis & Schichthöhe</div>
                            <div class="chart-wrap"><canvas id="inversionChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Temperaturgradient <span>C/100m</span></div>
                            <div class="chart-sub">0-1500m AGL</div>
                            <div class="chart-wrap"><canvas id="lapseChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Temperatur auf Höhe <span>C</span></div>
                            <div class="chart-sub">aus Pressure-Levels</div>
                            <div class="chart-wrap"><canvas id="paraAltTempChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Windchill auf Höhe <span>C</span></div>
                            <div class="chart-sub">Fix 40 km/h</div>
                            <div class="chart-wrap"><canvas id="paraAltChillChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Luftdichte / Dichtehöhe <span>kg/m³</span></div>
                            <div class="chart-sub">tageszeitlicher Verlauf</div>
                            <div class="chart-wrap"><canvas id="airDensityChart"></canvas></div>
                        </div>
                    </div>
                </div>
            </section>
            <section class="grid">
                <div class="panel thermik-panel">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                        <h3 style="margin-top:0">Thermik Zeit-Höhen</h3>
                    </div>
                    <div class="chart-sub">Farben = Steigen (m/s), grau = Low-Cloud Deck, rot = Wolkenbasis, blau =
                        Wolkendecke, Pfeile = Wind, ASL</div>
                    <div class="chart-wrap thermik-wrap">
                        <canvas id="thermikMatrix"></canvas>
                        <div id="thermikTooltip" class="thermik-tooltip"></div>
                    </div>
                </div>
            </section>
        </section>

        <section class="page" id="pageMap">
            <section class="map-toolbar">
                <div>
                    <span class="inline-label">Layer</span>
                    <div class="map-layer-group">
                        <button class="map-layer-btn active" data-layer="wind" type="button">Wind</button>
                        <button class="map-layer-btn" data-layer="precip" type="button">Regen</button>
                        <button class="map-layer-btn" data-layer="cloud" type="button">Wolken</button>
                        <button class="map-layer-btn" data-layer="nowcast" type="button">Nowcast</button>
                    </div>
                </div>
                <div class="map-time">
                    <button class="ghost-btn" id="mapPlayBtn" type="button">Play</button>
                    <input id="mapTimeRange" type="range" min="0" max="0" value="0" />
                    <span class="map-time-label" id="mapTimeLabel">--</span>
                </div>
                <div class="map-meta" id="mapMeta"></div>
            </section>
            <section class="grid">
                <div class="panel map-panel map-panel-full">
                    <div id="map"></div>
                    <div class="map-legend" id="mapLegend"></div>
                </div>
            </section>
        </section>

        <section class="page" id="pageCrossCountry">
            <section class="page-filter">
                <div>
                    <label for="xcDaySelect" class="inline-label">Tag</label>
                    <select id="xcDaySelect" class="inline-select"></select>
                </div>
            </section>
            <section class="grid grid-wide">
                <div class="card">
                    <h3>Wachs-Plan</h3>
                    <div class="value" id="waxPlanA">?</div>
                    <div class="subvalue" id="waxPlanB">?</div>
                    <div class="subvalue" id="waxPlanC">?</div>
                </div>
                <div class="card">
                    <h3>Schnee & Risiko</h3>
                    <div class="value" id="snowState">?</div>
                    <div class="subvalue" id="snowConfidence">?</div>
                    <div class="subvalue" id="abrasionRisk">?</div>
                </div>
                <div class="card">
                    <h3>Kontext</h3>
                    <div class="subvalue" id="raceWindow">?</div>
                    <div class="subvalue" id="conditionsSummary">?</div>
                </div>
                <div class="card">
                    <h3>Do / Don't</h3>
                    <ul class="list" id="doDontList"></ul>
                </div>
                <div class="card">
                    <h3>Neuschnee (Proxy)</h3>
                    <div class="value" id="xcSnow24Value">?</div>
                    <div class="subvalue" id="xcSnow48Value">?</div>
                </div>
                <div class="card">
                    <h3>Temperatur</h3>
                    <div class="value" id="xcTempValue">?</div>
                    <div class="subvalue" id="xcTempRange">?</div>
                </div>
                <div class="card">
                    <h3>Nullgrad & Temperatur</h3>
                    <div class="value" id="xcFreezingValue">?</div>
                    <div class="subvalue" id="xcFreezingHint">?</div>
                </div>
                <div class="card">
                    <h3>Nassschnee / Regen</h3>
                    <div class="value" id="xcWetValue">?</div>
                    <div class="subvalue" id="xcWetHint">?</div>
                </div>
            </section>
            <section class="grid">
                <div class="panel">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                        <h3 style="margin:0">48h Verlauf (Langlauf)</h3>
                    </div>
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title">Neuschnee 24h <span>cm</span></div>
                            <div class="chart-sub">Proxy aus Niederschlag + Temperatur + integrierte Summe (gestrichelt)
                            </div>
                            <div class="chart-wrap"><canvas id="xcSnowChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Nassschnee <span>%</span></div>
                            <div class="chart-sub">Regen + Temperatur</div>
                            <div class="chart-wrap"><canvas id="xcWetSnowChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Sicht & Sonne <span>%</span></div>
                            <div class="chart-sub">Wolken / Niederschlag + Sonne</div>
                            <div class="chart-wrap"><canvas id="xcVisibilityChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Nullgrad <span>m</span></div>
                            <div class="chart-sub">ASL</div>
                            <div class="chart-wrap"><canvas id="xcFreezingChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Temperatur <span>C</span></div>
                            <div class="chart-sub">2m Verlauf</div>
                            <div class="chart-wrap"><canvas id="xcTempChart"></canvas></div>
                        </div>
                    </div>
                </div>
            </section>
        </section>
        <section class="page" id="pageSkitour">
            <section class="page-filter">
                <div>
                    <label for="tourDaySelect" class="inline-label">Tag</label>
                    <select id="tourDaySelect" class="inline-select"></select>
                </div>
            </section>
            <section class="grid grid-wide">
                <div class="card accent">
                    <h3>Tour-Score</h3>
                    <div class="value" id="tourScoreValue">?</div>
                    <div class="subvalue" id="tourScoreHint">?</div>
                    <div class="subvalue" id="tourScoreBand">?</div>
                    <div class="subvalue" id="tourHazardValue">?</div>
                    <div class="subvalue" id="tourScoreReasons">?</div>
                </div>
                <div class="card">
                    <h3>Lawinenlagebericht</h3>
                    <div class="value" id="avalancheLevelValue">?</div>
                    <div class="subvalue" id="avalancheValidValue">?</div>
                    <div class="subvalue" id="avalancheProblemsValue">?</div>
                    <div style="margin-top:8px;">
                        <label for="avalancheRegionSelect" class="inline-label">Region</label>
                        <select id="avalancheRegionSelect" class="inline-select"></select>
                    </div>
                </div>
                <div class="card">
                    <h3>Neuschnee (Proxy)</h3>
                    <div class="value" id="snow24Value">?</div>
                    <div class="subvalue" id="snowRateValue">?</div>
                </div>
                <div class="card">
                    <h3>Windverfrachtung</h3>
                    <div class="value" id="windLoadValue">?</div>
                    <div class="subvalue" id="windLoadHint">?</div>
                </div>
                <div class="card">
                    <h3>Wind & Windchill</h3>
                    <div class="value" id="tourWindChillValue">?</div>
                    <div class="subvalue" id="tourWindChillHint">?</div>
                </div>
                <div class="card">
                    <h3>Nassschnee / Regen</h3>
                    <div class="value" id="wetSnowValue">?</div>
                    <div class="subvalue" id="wetSnowHint">?</div>
                </div>
                <div class="card">
                    <h3>Sicht / Whiteout</h3>
                    <div class="value" id="visibilityValue">?</div>
                    <div class="subvalue" id="visibilityHint">?</div>
                </div>
                <div class="card">
                    <h3>Nullgrad & Temperatur</h3>
                    <div class="value" id="freezingLevelValue">?</div>
                    <div class="subvalue" id="freezingLevelHint">?</div>
                </div>
                <div class="card">
                    <h3>Temperatur in Höhe</h3>
                    <div class="value" id="tourAltTempValue">?</div>
                    <div class="subvalue" id="tourAltTempList">?</div>
                    <div class="subvalue" id="tourAltTempHint">?</div>
                    <div style="margin-top:8px;">
                        <span class="inline-label">Höhen</span>
                        <div class="alt-options">
                            <label class="alt-option"><input class="tour-alt-check" type="checkbox" value="2000"
                                    checked>2000m</label>
                            <label class="alt-option"><input class="tour-alt-check" type="checkbox" value="2500"
                                    checked>2500m</label>
                            <label class="alt-option"><input class="tour-alt-check" type="checkbox" value="3000"
                                    checked>3000m</label>
                            <label class="alt-option"><input class="tour-alt-check" type="checkbox" value="3500"
                                    checked>3500m</label>
                        </div>
                    </div>
                </div>
            </section>
            <section class="grid">
                <div class="panel">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                        <h3 style="margin:0">48h Verlauf (Skitour)</h3>
                    </div>
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title">Tour-Score Höhenband <span>Score</span></div>
                            <div class="chart-sub">unter/ober Waldgrenze</div>
                            <div class="chart-wrap"><canvas id="tourBandChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Gefahr Höhenband <span>%</span></div>
                            <div class="chart-sub">LLB + Meteo-Proxy</div>
                            <div class="chart-wrap"><canvas id="tourHazardChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Neuschnee 24h <span>cm</span></div>
                            <div class="chart-sub">Proxy aus Niederschlag + Temperatur + integrierte Summe (gestrichelt)
                            </div>
                            <div class="chart-wrap"><canvas id="snowChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Windverfrachtung <span>%</span></div>
                            <div class="chart-sub">Proxy Risiko</div>
                            <div class="chart-wrap"><canvas id="windLoadChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Nassschnee <span>%</span></div>
                            <div class="chart-sub">Regen + Temperatur</div>
                            <div class="chart-wrap"><canvas id="wetSnowChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Sicht & Sonne <span>%</span></div>
                            <div class="chart-sub">Wolken / Niederschlag + Sonne</div>
                            <div class="chart-wrap"><canvas id="visibilityChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Nullgrad <span>m</span></div>
                            <div class="chart-sub">ASL</div>
                            <div class="chart-wrap"><canvas id="freezingChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Temperatur auf Höhe <span>C</span></div>
                            <div class="chart-sub">aus Pressure-Levels</div>
                            <div class="chart-wrap"><canvas id="tourAltTempChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Windchill auf Höhe <span>C</span></div>
                            <div class="chart-sub">Wind + Temperatur</div>
                            <div class="chart-wrap"><canvas id="tourAltChillChart"></canvas></div>
                        </div>
                    </div>
                </div>
            </section>
        </section>
        <section class="page" id="pageCycling">
            <section class="page-filter">
                <div>
                    <label for="rideDaySelect" class="inline-label">Tag</label>
                    <select id="rideDaySelect" class="inline-select"></select>
                </div>
            </section>
            <section class="grid grid-wide">
                <div class="card accent">
                    <h3>Ride-Score</h3>
                    <div class="value" id="rideScoreValue">?</div>
                    <div class="subvalue" id="rideScoreHint">?</div>
                    <div class="subvalue" id="rideScoreReasons">?</div>
                </div>
                <div class="card">
                    <h3>Bestes Zeitfenster</h3>
                    <div class="value" id="rideWindowValue">?</div>
                    <div class="subvalue" id="rideWindowPeak">?</div>
                    <div class="subvalue" id="rideWindowUncertainty">?</div>
                </div>
                <div class="card">
                    <h3>Temperatur & Komfort</h3>
                    <div class="value" id="rideTempValue">?</div>
                    <div class="subvalue" id="rideFeelsLike">?</div>
                    <div class="subvalue" id="rideTempHint">?</div>
                </div>
                <div class="card">
                    <h3>Wind & Böen</h3>
                    <div class="value" id="rideWindValue">?</div>
                    <div class="subvalue" id="rideWindGust">?</div>
                    <div class="subvalue" id="rideWindHint">?</div>
                </div>
                <div class="card">
                    <h3>Niederschlag & Nässe</h3>
                    <div class="value" id="ridePrecipValue">?</div>
                    <div class="subvalue" id="ridePrecipSum">?</div>
                    <div class="subvalue" id="rideWetValue">?</div>
                </div>
                <div class="card">
                    <h3>Sonne & Wolken</h3>
                    <div class="value" id="rideSunValue">?</div>
                    <div class="subvalue" id="rideCloudValue">?</div>
                    <div class="subvalue" id="rideLightHint">?</div>
                </div>
                <div class="card">
                    <h3>Risiken</h3>
                    <div class="value" id="rideConvRisk">?</div>
                    <div class="subvalue" id="rideVisibilityRisk">?</div>
                </div>
            </section>
            <section class="grid">
                <div class="panel">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
                        <h3 style="margin:0">48h Verlauf (Rennrad)</h3>
                    </div>
                    <div class="chart-grid">
                        <div class="chart-card">
                            <div class="chart-title">Ride-Score & Nässe <span>Score</span></div>
                            <div class="chart-sub">0-100 · lokale Zeit</div>
                            <div class="chart-wrap"><canvas id="rideChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Wind & Böen <span>km/h</span></div>
                            <div class="chart-sub">Wind am Start + Böen</div>
                            <div class="chart-wrap"><canvas id="rideWindChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Niederschlag <span>mm</span></div>
                            <div class="chart-sub">1h + 6h Summe</div>
                            <div class="chart-wrap"><canvas id="ridePrecipChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Temperatur & Gefühl <span>°C</span></div>
                            <div class="chart-sub">Luft vs. gefühlt</div>
                            <div class="chart-wrap"><canvas id="rideTempChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Sonne & Wolken <span>%</span></div>
                            <div class="chart-sub">Sonnenanteil vs. Bewölkung</div>
                            <div class="chart-wrap"><canvas id="rideSunChart"></canvas></div>
                        </div>
                        <div class="chart-card">
                            <div class="chart-title">Risiken <span>%</span></div>
                            <div class="chart-sub">Wind / Nässe</div>
                            <div class="chart-wrap"><canvas id="rideRiskChart"></canvas></div>
                        </div>
                    </div>
                </div>
            </section>
        </section>
    </div>

    <script>
        const dashboard = { "site_meta": [{ "name": "Graz", "lat": 47.0707, "lon": 15.4395, "elevation_m": 350.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }, { "name": "Bad Mitterndorf", "lat": 47.559, "lon": 13.929, "elevation_m": 850.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }, { "name": "Graden (Weststeiermark)", "lat": 46.894, "lon": 15.158, "elevation_m": 650.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }, { "name": "Teichalm", "lat": 47.336, "lon": 15.52, "elevation_m": 1200.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }, { "name": "Schöckl", "lat": 47.204, "lon": 15.464, "elevation_m": 1445.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }, { "name": "St. Magdalena (Gsiesertal)", "lat": 46.8345, "lon": 12.2391, "elevation_m": 1396.0, "takeoff_aspect_deg": 180, "safe_sector_min_deg": 0, "safe_sector_max_deg": 360, "limits": { "max_wind": 7, "max_gust": 10, "max_tailwind": 2.5, "max_crosswind": 4 }, "timing": { "approach_min": 20, "setup_min": 15, "buffer_min": 10 } }], "default_site": "Bad Mitterndorf", "xc": { "Graz": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": ["DO: finer structure, prioritize glide in cold/dry."], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "MED", "abrasion_risk": "HIGH", "scenario_confidence": "HIGH", "scenario_weights": { "cold": 0.25, "transformed": 0.5, "moist": 0.15, "wet": 0.1 } }, "conditions": { "t_p10": 2.8, "t_p50": 3.5, "t_p90": 5.3, "t_min_48h": 1.8, "t_surface": null, "t_wet_bulb": null, "t_snow_est": 1.9163541666666668, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.1784375 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } }, "Bad Mitterndorf": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": ["DO: finer structure, prioritize glide in cold/dry."], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "HIGH", "reasons": [], "abrasion_risk": "HIGH" }, "conditions": { "t_p10": 3.2, "t_p50": 3.6, "t_p90": 4.0, "t_min_48h": -0.8, "t_surface": null, "t_wet_bulb": null, "t_snow_est": 2.016354166666667, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.1784375 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } }, "Graden (Weststeiermark)": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": ["DO: finer structure, prioritize glide in cold/dry."], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "HIGH", "abrasion_risk": "HIGH", "scenario_confidence": "HIGH", "scenario_weights": { "cold": 0.25, "transformed": 0.5, "moist": 0.15, "wet": 0.1 } }, "conditions": { "t_p10": 2.0, "t_p50": 3.2, "t_p90": 3.7, "t_min_48h": 0.0, "t_surface": null, "t_wet_bulb": null, "t_snow_est": 1.616354166666667, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.1784375 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } }, "Teichalm": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "medium broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": [], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "HIGH", "abrasion_risk": "HIGH", "scenario_confidence": "HIGH", "scenario_weights": { "cold": 0.25, "transformed": 0.5, "moist": 0.15, "wet": 0.1 } }, "conditions": { "t_p10": 0.7, "t_p50": 1.3, "t_p90": 1.6, "t_min_48h": -0.8, "t_surface": null, "t_wet_bulb": null, "t_snow_est": 0.08822916666666658, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.33781249999999996 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } }, "Schöckl": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": ["DO: finer structure, prioritize glide in cold/dry."], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "HIGH", "abrasion_risk": "HIGH", "scenario_confidence": "HIGH", "scenario_weights": { "cold": 0.25, "transformed": 0.5, "moist": 0.15, "wet": 0.1 } }, "conditions": { "t_p10": 2.2, "t_p50": 2.9, "t_p90": 3.1, "t_min_48h": -0.2, "t_surface": null, "t_wet_bulb": null, "t_snow_est": 1.3382291666666668, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.18781250000000002 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } }, "St. Magdalena (Gsiesertal)": { "plans": [{ "name": "Plan A", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_MIDDLE", "structure": "medium broken", "trigger": "Default conditions" }, { "name": "Plan B", "base": "HWK Racing LF (Universal)", "block": "HFW2", "powder": "UHX_POWDER_WARM", "structure": "medium to coarse linear", "trigger": "If SnowTemp_est > -1 and WetnessIndex > 0.35" }, { "name": "Plan C", "base": "HWK Racing LF (Universal)", "block": "HFW3", "powder": "UHX_POWDER_MIDDLE", "structure": "fine linear", "trigger": "If night drop or hard glazing (T_min_48h <= -7)" }], "do_dont": [], "durability": "Standard durability.", "snow": { "state": "TRANSFORMED", "confidence": "HIGH", "abrasion_risk": "HIGH", "scenario_confidence": "HIGH", "scenario_weights": { "cold": 0.25, "transformed": 0.5, "moist": 0.15, "wet": 0.1 } }, "conditions": { "t_p10": -1.4, "t_p50": -1.1, "t_p90": -0.6, "t_min_48h": -8.0, "t_surface": null, "t_wet_bulb": null, "t_snow_est": -2.2680208333333334, "t_snow_est_method": "heuristic", "precip_24h": null, "snowfall_6h": null, "rh_med": null, "spread": null, "sunshine_s": null, "cloud_cover": null, "wetness_index": 0.3565625 }, "race_window": { "start_local": "2026-02-08 09:00", "end_local": "13:00", "tz": "Europe/Vienna", "technique": "skating", "distance_km": 10.0 } } } };

        const AVALANCHE_SITE_OVERRIDES = {
            "Graz": "AT-06",
            "Bad Mitterndorf": "AT-06",
            "Graden (Weststeiermark)": "AT-06",
            "Teichalm": "AT-06",
            "Schöckl": "AT-06",
            "Hebalm auf der Pack": "AT-06",
            "St. Magdalena (Gsiesertal)": "IT-32-BZ",
        };

        const HEBALM_SITE = {
            name: "Hebalm auf der Pack",
            lat: 46.915,
            lon: 15.01,
            elevation_m: 1410,
            avalanche_region: "AT-06",
            aliases: ["Hebalm", "Hebalmm auf der Pack"],
        };
        const fallbackSites = [
            { name: "Bad Mitterndorf", lat: 47.559, lon: 13.929, elevation_m: 850, avalanche_region: "AT-06" },
            { name: "Graz", lat: 47.0707, lon: 15.4395, elevation_m: 350, avalanche_region: "AT-06" },
            { name: "Graden (Weststeiermark)", lat: 46.894, lon: 15.158, elevation_m: 650, avalanche_region: "AT-06" },
            { name: "Teichalm", lat: 47.336, lon: 15.52, elevation_m: 1200, avalanche_region: "AT-06" },
            { name: "Schöckl", lat: 47.204, lon: 15.464, elevation_m: 1445, avalanche_region: "AT-06" },
            HEBALM_SITE,
            { name: "St. Magdalena (Gsiesertal)", lat: 46.8345, lon: 12.2391, elevation_m: 1396, avalanche_region: "IT-32-BZ" },
        ];

        const normalizeSiteName = (name) => String(name || "").trim().toLowerCase();
        const siteMetaBase = Array.isArray(dashboard.site_meta) && dashboard.site_meta.length ? dashboard.site_meta : fallbackSites;
        const siteMetaRaw = siteMetaBase.slice();
        if (!siteMetaRaw.some((site) => normalizeSiteName(site?.name) === normalizeSiteName(HEBALM_SITE.name))) {
            siteMetaRaw.push(HEBALM_SITE);
        }
        const siteMeta = siteMetaRaw.map((site) => ({
            name: site.name,
            lat: site.lat,
            lon: site.lon,
            aliases: Array.isArray(site.aliases) ? site.aliases : [],
            elevation_m: site.elevation_m ?? site.elevation ?? site.alt ?? 0,
            avalanche_region: site.avalanche_region ?? AVALANCHE_SITE_OVERRIDES[site.name] ?? null,
            takeoff_aspect_deg: site.takeoff_aspect_deg ?? 180,
            safe_sector_min_deg: site.safe_sector_min_deg ?? 0,
            safe_sector_max_deg: site.safe_sector_max_deg ?? 360,
            limits: {
                max_wind: site.limits?.max_wind ?? 7,
                max_gust: site.limits?.max_gust ?? 10,
                max_tailwind: site.limits?.max_tailwind ?? 2.5,
                max_crosswind: site.limits?.max_crosswind ?? 4,
            },
            timing: {
                approach_min: site.timing?.approach_min ?? 20,
                setup_min: site.timing?.setup_min ?? 15,
                buffer_min: site.timing?.buffer_min ?? 10,
            },
            tz: site.tz || "auto",
        }));

        const xcBySite = dashboard.xc || {};
        const defaultSiteName = "Graz";
        let currentSiteName = defaultSiteName;
        const sitesByName = Object.fromEntries(siteMeta.map((site) => [site.name, site]));

        const addSiteOption = (site) => {
            return;
        };

        const upsertCustomSite = (site) => {
            if (!site) return;
            const existing = sitesByName[site.name];
            if (existing) {
                Object.assign(existing, site);
            } else {
                siteMeta.push(site);
                sitesByName[site.name] = site;
                addSiteOption(site);
            }
        };

        const PINNED_KEY = "alpenwetter_pins_v1";
        const loadPinnedSites = () => {
            try {
                const raw = localStorage.getItem(PINNED_KEY);
                const parsed = raw ? JSON.parse(raw) : [];
                return Array.isArray(parsed) ? parsed : [];
            } catch {
                return [];
            }
        };
        const savePinnedSites = (sites) => {
            try {
                localStorage.setItem(PINNED_KEY, JSON.stringify(sites));
            } catch {
                // ignore
            }
        };
        const siteKey = (site) => `${site.lat.toFixed(4)},${site.lon.toFixed(4)}`;
        const renderPinnedSites = () => {
            if (!pinnedLocations) return;
            const pins = loadPinnedSites();
            pinnedLocations.innerHTML = "";
            pins.forEach((site) => {
                upsertCustomSite(site);
                const chip = document.createElement("button");
                chip.type = "button";
                chip.className = "pin-chip";
                chip.textContent = site.name;
                chip.addEventListener("click", () => updateSite(site.name));
                const remove = document.createElement("span");
                remove.className = "remove";
                remove.textContent = "\u00d7";
                remove.addEventListener("click", (event) => {
                    event.stopPropagation();
                    const next = loadPinnedSites().filter((s) => siteKey(s) !== siteKey(site));
                    savePinnedSites(next);
                    renderPinnedSites();
                });
                chip.appendChild(remove);
                pinnedLocations.appendChild(chip);
            });
        };

        const parseLatLon = (text) => {
            if (!text) return null;
            const match = text.trim().match(/(-?\\d+(?:\\.\\d+)?)\\s*[,;\\s]+\\s*(-?\\d+(?:\\.\\d+)?)/);
            if (!match) return null;
            const lat = Number(match[1]);
            const lon = Number(match[2]);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            return { lat, lon };
        };

        const makeCustomSite = (name, lat, lon, elevation) => {
            const base = siteMeta[0] || {};
            return {
                name,
                lat,
                lon,
                elevation_m: Number.isFinite(elevation) ? elevation : (base.elevation_m ?? 0),
                avalanche_region: null,
                takeoff_aspect_deg: base.takeoff_aspect_deg ?? 180,
                safe_sector_min_deg: base.safe_sector_min_deg ?? 0,
                safe_sector_max_deg: base.safe_sector_max_deg ?? 360,
                limits: { ...(base.limits || { max_wind: 7, max_gust: 10, max_tailwind: 2.5, max_crosswind: 4 }) },
                timing: { ...(base.timing || { approach_min: 20, setup_min: 15, buffer_min: 10 }) },
                tz: "auto",
            };
        };

        const pickBestGeocode = (results) => {
            if (!Array.isArray(results) || !results.length) return null;
            const inAlps = results.find((r) => r.latitude >= 42 && r.latitude <= 49.8 && r.longitude >= 5 && r.longitude <= 17);
            return inAlps || results[0];
        };
        const geocodeInAlps = (r) => r && r.latitude >= 42 && r.latitude <= 49.8 && r.longitude >= 5 && r.longitude <= 17;
        const geocodeLabel = (result) => [result?.name, result?.admin1, result?.country_code].filter(Boolean).join(" | ");
        const geocodeMeta = (result) => {
            const lat = Number(result?.latitude);
            const lon = Number(result?.longitude);
            const elev = Number(result?.elevation);
            const parts = [];
            if (Number.isFinite(lat) && Number.isFinite(lon)) parts.push(`${lat.toFixed(3)}, ${lon.toFixed(3)}`);
            if (Number.isFinite(elev)) parts.push(`${Math.round(elev)} m`);
            return parts.join(" | ");
        };
        const toGeocodeSuggestion = (result) => {
            const lat = Number(result?.latitude);
            const lon = Number(result?.longitude);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            const label = geocodeLabel(result) || `${lat.toFixed(3)}, ${lon.toFixed(3)}`;
            const elevation = Number(result?.elevation);
            return {
                kind: "geocode",
                key: `geo:${lat.toFixed(4)},${lon.toFixed(4)}:${label}`,
                label,
                meta: geocodeMeta(result),
                lat,
                lon,
                elevation: Number.isFinite(elevation) ? elevation : null,
            };
        };
        const toCoordSuggestion = (latlon) => ({
            kind: "coords",
            key: `coord:${latlon.lat.toFixed(4)},${latlon.lon.toFixed(4)}`,
            label: `${latlon.lat.toFixed(3)}, ${latlon.lon.toFixed(3)}`,
            meta: "Koordinaten verwenden",
            lat: latlon.lat,
            lon: latlon.lon,
            elevation: null,
        });
        const toSiteSuggestion = (site) => {
            const lat = Number(site?.lat);
            const lon = Number(site?.lon);
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            const elev = Number(site?.elevation_m ?? site?.elevation ?? site?.alt);
            const meta = [
                `${lat.toFixed(3)}, ${lon.toFixed(3)}`,
                Number.isFinite(elev) ? `${Math.round(elev)} m` : null,
            ]
                .filter(Boolean)
                .join(" | ");
            return {
                kind: "site",
                key: `site:${normalizeSiteName(site.name)}`,
                siteName: site.name,
                label: site.name,
                meta,
                lat,
                lon,
                elevation: Number.isFinite(elev) ? elev : null,
            };
        };
        const appendSiteSuggestions = (items, query, maxItems = 8) => {
            const q = normalizeSiteName(query);
            if (!q || q.length < 2) return;
            const seen = new Set(items.map((item) => item.key));
            siteMeta.forEach((site) => {
                if (items.length >= maxItems) return;
                const searchText = [site?.name, ...(site?.aliases || [])].map((value) => normalizeSiteName(value)).join(" ");
                if (!searchText.includes(q)) return;
                const item = toSiteSuggestion(site);
                if (!item || seen.has(item.key)) return;
                seen.add(item.key);
                items.push(item);
            });
        };
        const simplifyLocationQuery = (query) => {
            const raw = String(query || "").trim();
            if (!raw) return "";
            // Allow users to paste labels like "Name | Region | CC" or "Aktueller Standort · Name".
            let out = raw;
            if (out.includes("|")) out = out.split("|")[0].trim();
            if (out.includes("·")) out = out.split("·")[0].trim();
            return out;
        };
        const findSiteByQuery = (query) => {
            const raw = String(query || "").trim();
            const q = normalizeSiteName(raw);
            if (!q) return null;

            if (q.startsWith("aktueller standort")) {
                const current = sitesByName[currentSiteName];
                if (current) return current;
                const anyDevice = siteMeta.find((s) => normalizeSiteName(s?.name).startsWith("aktueller standort"));
                if (anyDevice) return anyDevice;
            }

            const exact = siteMeta.find((site) => {
                if (!site) return false;
                if (normalizeSiteName(site.name) === q) return true;
                const aliases = Array.isArray(site.aliases) ? site.aliases : [];
                return aliases.some((a) => normalizeSiteName(a) === q);
            });
            if (exact) return exact;

            const simplified = simplifyLocationQuery(raw);
            const qs = normalizeSiteName(simplified);
            if (qs && qs !== q) {
                const simplifiedMatch = siteMeta.find((site) => {
                    if (!site) return false;
                    if (normalizeSiteName(site.name) === qs) return true;
                    const aliases = Array.isArray(site.aliases) ? site.aliases : [];
                    return aliases.some((a) => normalizeSiteName(a) === qs);
                });
                if (simplifiedMatch) return simplifiedMatch;
            }

            return null;
        };
        const hideLocationSuggest = () => {
            locationSuggestItems = [];
            locationSuggestFocus = -1;
            if (!locationSuggest) return;
            locationSuggest.innerHTML = "";
            locationSuggest.hidden = true;
        };
        const setLocationSuggestFocus = (nextIndex) => {
            if (!locationSuggest || !locationSuggestItems.length) return;
            locationSuggestFocus = Math.max(0, Math.min(nextIndex, locationSuggestItems.length - 1));
            const nodes = locationSuggest.querySelectorAll(".location-suggest-item");
            nodes.forEach((node, idx) => {
                const active = idx === locationSuggestFocus;
                node.classList.toggle("active", active);
                node.setAttribute("aria-selected", active ? "true" : "false");
                if (active) node.scrollIntoView({ block: "nearest" });
            });
        };
        const applyLocationSuggestion = async (item) => {
            if (!item) return;
            if (item.kind === "site" && item.siteName && sitesByName[item.siteName]) {
                currentSiteName = item.siteName;
                if (customLocationInput) customLocationInput.value = item.siteName;
                locationInputPrefilled = true;
                hideLocationSuggest();
                updateSite(item.siteName);
                return;
            }
            const siteName = item.kind === "coords" ? `${item.lat.toFixed(3)}, ${item.lon.toFixed(3)}` : item.label;
            const site = makeCustomSite(siteName, item.lat, item.lon, item.elevation);
            upsertCustomSite(site);
            currentSiteName = site.name;
            if (customLocationInput) customLocationInput.value = item.label;
            locationInputPrefilled = true;
            hideLocationSuggest();
            updateSite(site.name);
        };
        const renderLocationSuggest = (items) => {
            if (!locationSuggest) return;
            locationSuggestItems = Array.isArray(items) ? items : [];
            locationSuggestFocus = -1;
            locationSuggest.innerHTML = "";
            if (!locationSuggestItems.length) {
                locationSuggest.hidden = true;
                return;
            }
            locationSuggestItems.forEach((item, idx) => {
                const btn = document.createElement("button");
                btn.type = "button";
                btn.className = "location-suggest-item";
                btn.setAttribute("role", "option");
                btn.setAttribute("aria-selected", "false");
                btn.dataset.index = String(idx);
                const title = document.createElement("div");
                title.className = "location-suggest-title";
                title.textContent = item.label;
                btn.appendChild(title);
                if (item.meta) {
                    const meta = document.createElement("div");
                    meta.className = "location-suggest-meta";
                    meta.textContent = item.meta;
                    btn.appendChild(meta);
                }
                btn.addEventListener("click", () => {
                    applyLocationSuggestion(item);
                });
                locationSuggest.appendChild(btn);
            });
            locationSuggest.hidden = false;
        };
        const fetchLocationSuggest = async (query) => {
            const q = (query || "").trim();
            if (!q) {
                hideLocationSuggest();
                return;
            }
            const reqId = ++locationSuggestReqId;
            const items = [];
            const coord = parseLatLon(q);
            if (coord) items.push(toCoordSuggestion(coord));
            appendSiteSuggestions(items, q, 8);
            if (q.length >= 2) {
                try {
                    const params = { name: q, count: 8, language: "de", format: "json" };
                    const data = await fetchJson(buildUrl(GEOCODE_BASE, params));
                    if (reqId !== locationSuggestReqId) return;
                    const raw = Array.isArray(data?.results) ? data.results.slice() : [];
                    raw.sort((a, b) => {
                        const aRank = geocodeInAlps(a) ? 0 : 1;
                        const bRank = geocodeInAlps(b) ? 0 : 1;
                        return aRank - bRank;
                    });
                    const seen = new Set(items.map((item) => item.key));
                    raw.forEach((result) => {
                        const item = toGeocodeSuggestion(result);
                        if (!item || seen.has(item.key) || items.length >= 8) return;
                        seen.add(item.key);
                        items.push(item);
                    });
                } catch (err) {
                    if (reqId !== locationSuggestReqId) return;
                }
            }
            if (reqId !== locationSuggestReqId) return;
            renderLocationSuggest(items);
        };

        const resolveCustomLocation = async () => {
            if (!customLocationInput) return;
            const query = customLocationInput.value.trim();
            // Clear any previous error while a new search is being attempted.
            if (alertBox) {
                alertBox.textContent = "";
                alertBox.style.display = "none";
            }
            if (!query) {
                if (statusBox && currentPayload) updateStatus(currentPayload);
                return;
            }

            // If the query already matches a known location, avoid a geocoding round-trip.
            const known = findSiteByQuery(query);
            if (known) {
                currentSiteName = known.name;
                if (customLocationInput) customLocationInput.value = known.name;
                locationInputPrefilled = true;
                hideLocationSuggest();
                updateSite(known.name);
                return;
            }

            const prevStatusText = statusBox ? statusBox.textContent : "";
            if (statusBox) statusBox.textContent = "Suche Ort...";
            if (locationSuggestItems.length) {
                const selectedIdx = locationSuggestFocus >= 0 ? locationSuggestFocus : 0;
                await applyLocationSuggestion(locationSuggestItems[selectedIdx]);
                return;
            }
            const latlon = parseLatLon(query);
            if (latlon) {
                const name = `${latlon.lat.toFixed(3)}, ${latlon.lon.toFixed(3)}`;
                const site = makeCustomSite(name, latlon.lat, latlon.lon);
                upsertCustomSite(site);
                currentSiteName = site.name;
                if (customLocationInput) customLocationInput.value = name;
                locationInputPrefilled = true;
                hideLocationSuggest();
                updateSite(site.name);
                return;
            }
            try {
                const params = { name: query, count: 5, language: "de", format: "json" };
                const data = await fetchJson(buildUrl(GEOCODE_BASE, params));
                const best = pickBestGeocode(data?.results || []);
                if (!best) throw new Error("Ort nicht gefunden");
                const label = [best.name, best.admin1, best.country_code].filter(Boolean).join(" | ");
                const siteName = `${label}`;
                const site = makeCustomSite(siteName, best.latitude, best.longitude, best.elevation);
                upsertCustomSite(site);
                currentSiteName = site.name;
                if (customLocationInput) customLocationInput.value = label;
                locationInputPrefilled = true;
                hideLocationSuggest();
                updateSite(site.name);
            } catch (err) {
                if (statusBox) {
                    if (currentPayload) updateStatus(currentPayload);
                    else if (prevStatusText) statusBox.textContent = prevStatusText;
                }
                if (alertBox) {
                    alertBox.textContent = `Ortssuche fehlgeschlagen: ${err.message}`;
                    alertBox.style.display = "block";
                }
            }
        };

        const pinCurrentLocation = () => {
            if (!currentPayload || !currentPayload.site) return;
            const site = currentPayload.site;
            const pins = loadPinnedSites();
            if (!pins.find((s) => siteKey(s) === siteKey(site))) {
                pins.push({
                    name: site.name,
                    lat: site.lat,
                    lon: site.lon,
                    elevation_m: site.elevation_m,
                    takeoff_aspect_deg: site.takeoff_aspect_deg,
                    safe_sector_min_deg: site.safe_sector_min_deg,
                    safe_sector_max_deg: site.safe_sector_max_deg,
                    limits: site.limits,
                    timing: site.timing,
                    tz: site.tz,
                });
                savePinnedSites(pins);
                renderPinnedSites();
            }
        };

        const GEO_BASE = "https://dataset.api.hub.geosphere.at/v1";
        const GEO_TS_ENSEMBLE = `${GEO_BASE}/timeseries/forecast/ensemble-v1-1h-2500m`;
        const GEO_TS_NWP = `${GEO_BASE}/timeseries/forecast/nwp-v1-1h-2500m`;
        const GEO_TS_NOWCAST = `${GEO_BASE}/timeseries/forecast/nowcast-v1-15min-1km`;
        const WARN_BASE = "https://warnungen.zamg.at/wsapp/api";
        const OPEN_METEO_BASE = "https://api.open-meteo.com/v1/forecast";
        const OPEN_METEO_ELEVATION_BASE = "https://api.open-meteo.com/v1/elevation";
        const GEOCODE_BASE = "https://geocoding-api.open-meteo.com/v1/search";
        // Daily EAWS bulletins (folder per date: YYYY-MM-DD/YYYY-MM-DD-<CODE>.json)
        const AVALANCHE_BASE = "https://static.avalanche.report/eaws_bulletins";
        const PRESSURE_LEVELS = [1000, 975, 950, 925, 900, 850, 800, 700, 600, 500];
        const CACHE_TTL_ENSEMBLE_MS = 2 * 60 * 60 * 1000;
        const CACHE_TTL_NWP_MS = 60 * 60 * 1000;
        const CACHE_TTL_NOWCAST_MS = 15 * 60 * 1000;
        const CACHE_TTL_WARN_MS = 15 * 60 * 1000;
        const CACHE_TTL_UPPER_MS = 6 * 60 * 60 * 1000;
        const CACHE_TTL_OPENMETEO_SURFACE_MS = 3 * 60 * 60 * 1000;
        const CACHE_TTL_AVALANCHE_MS = 6 * 60 * 60 * 1000;

        const fetchElevationM = async (lat, lon) => {
            try {
                const params = { latitude: String(lat), longitude: String(lon) };
                const data = await fetchJson(buildUrl(OPEN_METEO_ELEVATION_BASE, params), 8000);
                const raw = Array.isArray(data?.elevation) ? data.elevation[0] : data?.elevation;
                const elev = Number(raw);
                return Number.isFinite(elev) ? elev : null;
            } catch (err) {
                return null;
            }
        };

        const toRad = (deg) => (deg * Math.PI) / 180;
        const haversineKm = (lat1, lon1, lat2, lon2) => {
            const R = 6371;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a =
                Math.sin(dLat / 2) * Math.sin(dLat / 2)
                + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return 2 * R * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        };
        const findNearestKnownSite = (lat, lon, maxKm = 80) => {
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            let best = null;
            let bestKm = Infinity;
            siteMeta.forEach((site) => {
                if (!site || !Number.isFinite(site.lat) || !Number.isFinite(site.lon)) return;
                const name = String(site.name || "").trim();
                if (!name) return;
                if (name.toLowerCase().startsWith("aktueller standort")) return;
                const d = haversineKm(lat, lon, site.lat, site.lon);
                if (!Number.isFinite(d)) return;
                if (d < bestKm) {
                    bestKm = d;
                    best = name;
                }
            });
            if (!best || !(bestKm <= maxKm)) return null;
            return { name: best, km: Math.round(bestKm) };
        };

        let locationInputPrefilled = false;
        let hasTriedDeviceLocation = false;
        const tryLoadDeviceLocationFirst = async () => {
            if (hasTriedDeviceLocation) return false;
            hasTriedDeviceLocation = true;
            if (!window.isSecureContext) return false;
            if (!navigator.geolocation || typeof navigator.geolocation.getCurrentPosition !== "function") return false;

            const prevStatusText = statusBox ? statusBox.textContent : "";
            if (statusBox) statusBox.textContent = "Standort wird ermittelt...";

            try {
                const pos = await new Promise((resolve, reject) => {
                    navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: false,
                        timeout: 8000,
                        maximumAge: 2 * 60 * 1000,
                    });
                });
                const lat = Number(pos?.coords?.latitude);
                const lon = Number(pos?.coords?.longitude);
                if (!Number.isFinite(lat) || !Number.isFinite(lon)) return false;

                const elev = await fetchElevationM(lat, lon);
                const near = findNearestKnownSite(lat, lon);
                const site = makeCustomSite("Aktueller Standort", lat, lon, elev);
                site.is_device_location = true;
                // Keep this short in the UI. Details (coords) are already shown in the subtitle.
                site.device_hint = near?.name || null;
                upsertCustomSite(site);
                currentSiteName = site.name;
                if (customLocationInput) customLocationInput.value = site.name;
                locationInputPrefilled = true;
                hideLocationSuggest();
                await updateSite(site.name);
                return true;
            } catch (err) {
                if (statusBox) {
                    if (currentPayload) updateStatus(currentPayload);
                    else if (prevStatusText) statusBox.textContent = prevStatusText;
                }
                return false;
            }
        };

        const AVALANCHE_REGION_ALL_CODES = [
            "AT-02",
            "AT-03",
            "AT-04",
            "AT-05",
            "AT-06",
            "AT-07",
            "AT-08",
            "IT-32-BZ",
            "IT-32-TN",
        ];
        const AVALANCHE_REGION_LABELS = {
            "AT-02": "AT-02 (Kärnten)",
            "AT-03": "AT-03 (Niederösterreich)",
            "AT-04": "AT-04 (Oberösterreich)",
            "AT-05": "AT-05 (Salzburg)",
            "AT-06": "AT-06 (Steiermark)",
            "AT-07": "AT-07 (Tirol)",
            "AT-08": "AT-08 (Vorarlberg)",
            "IT-32-BZ": "IT-32-BZ (Südtirol)",
            "IT-32-TN": "IT-32-TN (Trentino)",
        };
        const AVALANCHE_REGION_COORDS = {
            "AT-02": { lat: 46.65, lon: 13.9 },
            "AT-03": { lat: 48.15, lon: 15.75 },
            "AT-04": { lat: 48.2, lon: 14.05 },
            "AT-05": { lat: 47.8, lon: 13.05 },
            "AT-06": { lat: 47.05, lon: 15.0 },
            "AT-07": { lat: 47.2, lon: 11.5 },
            "AT-08": { lat: 47.25, lon: 9.9 },
            "IT-32-BZ": { lat: 46.7, lon: 11.4 },
            "IT-32-TN": { lat: 46.1, lon: 11.1 },
        };
        const AVALANCHE_AVAILABLE_CODES = ["AT-02", "AT-03", "AT-04", "AT-05", "AT-06", "AT-07", "AT-08", "IT-32-BZ", "IT-32-TN"];
        const nearestAvalancheCode = (site, codes) => {
            if (!site || !Array.isArray(codes) || !codes.length) return null;
            let best = null;
            let bestDist = Infinity;
            codes.forEach((code) => {
                const coord = AVALANCHE_REGION_COORDS[code];
                if (!coord) return;
                const dLat = site.lat - coord.lat;
                const dLon = site.lon - coord.lon;
                const dist = dLat * dLat + dLon * dLon;
                if (dist < bestDist) {
                    bestDist = dist;
                    best = code;
                }
            });
            return best;
        };
        const AVALANCHE_REGIONS = AVALANCHE_REGION_ALL_CODES.map((code) => ({
            code,
            label: AVALANCHE_REGION_LABELS[code] || code,
            lat: AVALANCHE_REGION_COORDS[code]?.lat,
            lon: AVALANCHE_REGION_COORDS[code]?.lon,
        }));


        const AVALANCHE_PROBLEM_LABELS = {
            "new snow": "Neuschnee",
            "new_snow": "Neuschnee",
            "wind slab": "Triebschnee",
            "wind_slab": "Triebschnee",
            "persistent weak layer": "Altschnee",
            "persistent_weak_layers": "Altschnee",
            "old snow": "Altschnee",
            "old_snow": "Altschnee",
            "wet snow": "Nassschnee",
            "wet_snow": "Nassschnee",
            "gliding snow": "Gleitschnee",
            "gliding_snow": "Gleitschnee",
            "favourable": "Guenstig",
        };

        const DANGER_LEVELS = {
            low: 1,
            moderate: 2,
            considerable: 3,
            high: 4,
            very_high: 5,
            extreme: 5,
        };
        const parseDangerLevel = (value) => {
            if (value === null || value === undefined) return null;
            if (typeof value === "number") return value;
            const text = String(value).trim().toLowerCase();
            if (/^\d+$/.test(text)) return Number(text);
            return DANGER_LEVELS[text] ?? null;
        };
        const parseElevationBound = (value) => {
            if (value === null || value === undefined) return null;
            if (typeof value === "number") return value;
            const text = String(value).trim().toLowerCase();
            if (/^\d+(\.\d+)?$/.test(text)) return Number(text);
            if (text === "treeline") return "treeline";
            return null;
        };
        const DEFAULT_TREELINE_M = 2100;
        const getDangerLevelsByBand = (bulletin, site) => {
            const treeline = site?.treeline_m ?? DEFAULT_TREELINE_M;
            if (!bulletin) return { below: null, above: null, maxLevel: null, treeline };
            const ratings = Array.isArray(bulletin.ratings) ? bulletin.ratings : [];
            const maxLevel = bulletin.maxLevel ?? null;
            if (!ratings.length) return { below: null, above: null, maxLevel, treeline };
            let below = null;
            let above = null;
            ratings.forEach((r) => {
                const level = r.level;
                if (level === null || level === undefined) return;
                const lower = r.lower === "treeline" ? treeline : r.lower;
                const upper = r.upper === "treeline" ? treeline : r.upper;
                const appliesBelow = lower === null || lower === undefined || lower < treeline;
                const appliesAbove = upper === null || upper === undefined || upper > treeline;
                if (appliesBelow) below = below === null ? level : Math.max(below, level);
                if (appliesAbove) above = above === null ? level : Math.max(above, level);
            });
            return { below, above, maxLevel, treeline };
        };
        const getDangerLevelForSite = (bulletin, site) => {
            if (!bulletin) return { level: null, note: "", maxLevel: null };
            const maxLevel = bulletin.maxLevel ?? null;
            const ratings = Array.isArray(bulletin.ratings) ? bulletin.ratings : [];
            const elev = site?.elevation_m;
            const treeline = site?.treeline_m ?? DEFAULT_TREELINE_M;
            if (!ratings.length || elev === null || elev === undefined) {
                return { level: maxLevel, note: "", maxLevel };
            }
            const matches = ratings.filter((r) => {
                const lower = r.lower === "treeline" ? treeline : r.lower;
                const upper = r.upper === "treeline" ? treeline : r.upper;
                if (lower !== null && lower !== undefined && elev < lower) return false;
                if (upper !== null && upper !== undefined && elev > upper) return false;
                return true;
            });
            if (!matches.length) {
                return { level: maxLevel, note: "", maxLevel };
            }
            let best = matches[0];
            matches.forEach((m) => {
                if ((m.level ?? 0) > (best.level ?? 0)) best = m;
            });
            let note = "";
            if (best.upper === "treeline") note = "unter Waldgrenze";
            if (best.lower === "treeline") note = "ober Waldgrenze";
            return { level: best.level ?? maxLevel, note, maxLevel };
        };
        const normalizeProblemLabel = (value) => {
            if (!value) return null;
            const raw = String(value).trim().toLowerCase();
            const key = raw.replace(/\s+/g, " ");
            const keyUnderscore = raw.replace(/\s+/g, "_");
            return AVALANCHE_PROBLEM_LABELS[key] || AVALANCHE_PROBLEM_LABELS[keyUnderscore] || raw;
        };
        const extractRegionCode = (entry) => {
            if (!entry) return null;
            if (typeof entry === "string") return entry;
            return entry.regionID || entry.regionId || entry.id || entry.code || null;
        };
        const regionMatchesCode = (entry, regionCode) => {
            if (!regionCode) return false;
            const region = extractRegionCode(entry);
            if (!region) return false;
            const a = String(region).toUpperCase();
            const b = String(regionCode).toUpperCase();
            return a === b || a.startsWith(`${b}-`);
        };
        const findBulletinForRegion = (bulletins, regionCode) => {
            if (!Array.isArray(bulletins) || !regionCode) return null;
            for (const b of bulletins) {
                const regions = Array.isArray(b.regions) ? b.regions : [];
                const match = regions.find((r) => regionMatchesCode(r, regionCode));
                if (match) return b;
            }
            return null;
        };
        const periodToRatings = (period) => {
            if (!period || typeof period !== "object") return [];
            const out = [];
            const levelBelow = parseDangerLevel(period.dangerRatingBelow ?? null);
            const levelAbove = parseDangerLevel(period.dangerRatingAbove ?? period.dangerRating ?? null);
            const elevation = period.elevation;
            const hasTreeline = period.treeline === true;
            if (hasTreeline) {
                if (levelBelow !== null) out.push({ level: levelBelow, lower: null, upper: "treeline" });
                if (levelAbove !== null) out.push({ level: levelAbove, lower: "treeline", upper: null });
                return out;
            }
            if (elevation !== null && elevation !== undefined && !Number.isNaN(elevation)) {
                if (levelBelow !== null) out.push({ level: levelBelow, lower: null, upper: Number(elevation) });
                if (levelAbove !== null) out.push({ level: levelAbove, lower: Number(elevation), upper: null });
                return out;
            }
            if (levelAbove !== null) out.push({ level: levelAbove, lower: null, upper: null });
            else if (levelBelow !== null) out.push({ level: levelBelow, lower: null, upper: null });
            return out;
        };
        const parseAvalancheJson = (data, preferredRegion, fallbackRegion) => {
            if (!data) return null;
            const bulletins = Array.isArray(data.bulletins) ? data.bulletins : (Array.isArray(data) ? data : [data]);
            if (!bulletins.length) return null;
            let bulletin = preferredRegion ? findBulletinForRegion(bulletins, preferredRegion) : null;
            if (!bulletin && fallbackRegion) bulletin = findBulletinForRegion(bulletins, fallbackRegion);
            if (!bulletin) bulletin = bulletins[0];
            const ratingsRaw = Array.isArray(bulletin.dangerRatings) ? bulletin.dangerRatings : (Array.isArray(bulletin.dangerRating) ? bulletin.dangerRating : []);
            let ratings = ratingsRaw.map((entry) => ({
                level: parseDangerLevel(entry?.mainValue ?? entry?.value ?? entry?.level),
                lower: parseElevationBound(entry?.elevation?.lowerBound),
                upper: parseElevationBound(entry?.elevation?.upperBound),
            }));
            if (!ratings.length) {
                const periods = [bulletin.forenoon, bulletin.afternoon, bulletin.evening].filter(Boolean);
                periods.forEach((p) => {
                    ratings = ratings.concat(periodToRatings(p));
                });
            }
            const levels = ratings
                .map((entry) => entry.level)
                .filter((v) => v !== null && v !== undefined && !Number.isNaN(v));
            const maxLevel = levels.length ? Math.max(...levels) : null;
            const problemsRaw = Array.isArray(bulletin.avalancheProblems) ? bulletin.avalancheProblems : [];
            let problems = problemsRaw.map((p) => normalizeProblemLabel(p?.problemType || p?.problem || p)).filter(Boolean);
            if (!problems.length) {
                const periods = [bulletin.forenoon, bulletin.afternoon, bulletin.evening].filter(Boolean);
                periods.forEach((period) => {
                    [period.avalancheProblem1, period.avalancheProblem2, period.avalancheProblem3].forEach((p) => {
                        const label = normalizeProblemLabel(p?.avalancheProblem || p?.problemType || p?.problem);
                        if (label) problems.push(label);
                    });
                });
            }
            const uniqueProblems = Array.from(new Set(problems));
            const reportTime = bulletin.publicationTime || bulletin.reportTime || bulletin.publicationDate || "";
            const validStart = bulletin.validTime?.startTime || bulletin.validStart || bulletin.validity?.from || "";
            const validEnd = bulletin.validTime?.endTime || bulletin.validEnd || bulletin.validity?.until || "";
            const regionMatched = preferredRegion && findBulletinForRegion([bulletin], preferredRegion)
                ? preferredRegion
                : (fallbackRegion && findBulletinForRegion([bulletin], fallbackRegion) ? fallbackRegion : null);
            return {
                ratings,
                maxLevel,
                levels,
                problems: uniqueProblems,
                reportTime,
                validStart,
                validEnd,
                regionUsed: preferredRegion || fallbackRegion || null,
                regionMatched,
                raw: bulletin,
            };
        };
        const getStoredAvalancheRegion = (site) => {
            if (!site) return null;
            try {
                return localStorage.getItem(`avalanche_region_${site.name}`) || null;
            } catch (err) {
                return null;
            }
        };
        const setStoredAvalancheRegion = (site, region) => {
            if (!site) return;
            try {
                localStorage.setItem(`avalanche_region_${site.name}`, region);
            } catch (err) {
                // ignore
            }
        };
        const getAvalancheRegion = (site) => {
            if (!site) return null;
            return getStoredAvalancheRegion(site)
                || site.avalanche_region
                || nearestAvalancheCode(site, AVALANCHE_AVAILABLE_CODES)
                || (AVALANCHE_AVAILABLE_CODES.length ? AVALANCHE_AVAILABLE_CODES[0] : null);
        };

        const localIsoDate = (d) => {
            const y = d.getFullYear();
            const m = String(d.getMonth() + 1).padStart(2, "0");
            const day = String(d.getDate()).padStart(2, "0");
            return `${y}-${m}-${day}`;
        };
        const avalancheDateCandidates = () => {
            const now = new Date();
            const dayMs = 24 * 60 * 60 * 1000;
            const dates = [
                localIsoDate(now),
                localIsoDate(new Date(now.getTime() - dayMs)),
                localIsoDate(new Date(now.getTime() - 2 * dayMs)),
            ];
            return Array.from(new Set(dates));
        };
        const buildAvalancheUrl = (dateStr, code) => `${AVALANCHE_BASE}/${dateStr}/${dateStr}-${code}.json`;
        const fetchAvalancheBulletin = async (region, site) => {
            const candidates = [];
            if (region) candidates.push(region);
            if (region && /^AT-\d{2}-/i.test(region)) {
                const baseAt = region.split("-").slice(0, 2).join("-").toUpperCase();
                if (!candidates.includes(baseAt)) candidates.push(baseAt);
            }
            if (region && region.startsWith("IT-32-BZ-") && !candidates.includes("IT-32-BZ")) {
                candidates.push("IT-32-BZ");
            }
            const nearest = nearestAvalancheCode(site, AVALANCHE_AVAILABLE_CODES);
            if (nearest && !candidates.includes(nearest)) candidates.push(nearest);
            for (const code of candidates) {
                for (const dateStr of avalancheDateCandidates()) {
                    const key = cacheKeyGeneric("avalanche", `${dateStr}:${code}`);
                    let cached = cacheGet(key, CACHE_TTL_AVALANCHE_MS);
                    if (cached) return cached;
                    const url = buildAvalancheUrl(dateStr, code);
                    try {
                        const data = await fetchJson(url);
                        const parsed = parseAvalancheJson(data, region, code);
                        if (parsed) {
                            cacheSet(key, parsed);
                            return parsed;
                        }
                    } catch (err) {
                        // ignore and try next
                    }
                }
            }
            return null;
        };

        const alertBox = document.getElementById("alertBox");
        const statusBox = document.getElementById("dataStatus");
        const locationSelect = document.getElementById("locationSelect");
        const heroTitle = document.getElementById("heroTitle");
        const heroSubtitle = document.getElementById("heroSubtitle");
        const avalancheRegionSelect = document.getElementById("avalancheRegionSelect");
        const tourDaySelect = document.getElementById("tourDaySelect");
        const xcDaySelect = document.getElementById("xcDaySelect");
        const rideDaySelect = document.getElementById("rideDaySelect");
        const tourAltChecks = Array.from(document.querySelectorAll(".tour-alt-check"));
        const thermikMatrix = document.getElementById("thermikMatrix");
        const paraDaySelect = document.getElementById("paraDaySelect");
        const thermikTooltip = document.getElementById("thermikTooltip");
        const customLocationInput = document.getElementById("customLocationInput");
        const locationSuggest = document.getElementById("locationSuggest");
        const customLocationBtn = document.getElementById("customLocationBtn");
        const pinLocationBtn = document.getElementById("pinLocationBtn");
        const pinnedLocations = document.getElementById("pinnedLocations");

        const tabOverview = document.getElementById("tabOverview");
        const tabParagliding = document.getElementById("tabParagliding");
        const tabMap = document.getElementById("tabMap");
        const tabCrossCountry = document.getElementById("tabCrossCountry");
        const tabSkitour = document.getElementById("tabSkitour");
        const tabCycling = document.getElementById("tabCycling");
        const pageOverview = document.getElementById("pageOverview");
        const pageParagliding = document.getElementById("pageParagliding");
        const pageMap = document.getElementById("pageMap");
        const pageCrossCountry = document.getElementById("pageCrossCountry");
        const pageSkitour = document.getElementById("pageSkitour");
        const pageCycling = document.getElementById("pageCycling");
        const mapMeta = document.getElementById("mapMeta");
        const mapLegend = document.getElementById("mapLegend");
        const mapLayerButtons = Array.from(document.querySelectorAll(".map-layer-btn"));
        const mapTimeRange = document.getElementById("mapTimeRange");
        const mapTimeLabel = document.getElementById("mapTimeLabel");
        const mapPlayBtn = document.getElementById("mapPlayBtn");

        let currentPayload = null;
        let mapInstance = null;
        let markerInstance = null;
        let mapOverlayLayer = null;
        let mapOverlayKey = "wind";
        let mapOverlayTimer = null;
        let mapOverlayRequestId = 0;
        let mapOverlayIndex = 0;
        let mapOverlayCache = {};
        let mapOverlayTimestamps = [];
        let mapPlayTimer = null;
        let mapPlayActive = false;
        const MAP_PLAY_INTERVAL_MS = 850;
        const MAP_FRAME_CACHE_LIMIT = 28;
        const MAP_RENDER_TARGET_POINTS = { high: 28000, mid: 18000, low: 10000 };
        const GEO_BBOX_NWP = { south: 42.981, west: 5.498, north: 51.819, east: 22.102 };
        const GEO_BBOX_NOWCAST = { south: 45.50288351657135, west: 8.098133748352293, north: 49.47817568460958, east: 17.742270413233744 };
        const MAP_OVERLAYS = {
            wind: {
                label: "Wind 10m",
                resource: "nwp-v1-1h-2500m",
                params: ["u10m", "v10m"],
                unit: "km/h",
                min: 0,
                max: 60,
                opacity: 0.65,
                colors: ["#38bdf8", "#22d3ee", "#facc15", "#fb923c", "#ef4444"],
                crs: "EPSG:4326",
                bounds: GEO_BBOX_NWP,
                ttlMs: 20 * 60 * 1000,
                padRatio: 0.24,
                targetKey: "high",
                maxSpanLat: 2.4,
                maxSpanLon: 3.4,
                fetchTimeoutMs: 22000,
                pastHours: 0.5,
                futureHours: 10,
                value: (params, idx) => {
                    const u = params.u10m?.data?.[idx];
                    const v = params.v10m?.data?.[idx];
                    if (u === null || v === null || u === undefined || v === undefined) return null;
                    if (Number.isNaN(u) || Number.isNaN(v)) return null;
                    return Math.sqrt(u * u + v * v) * 3.6;
                },
                vector: (params, idx) => {
                    const u = params.u10m?.data?.[idx];
                    const v = params.v10m?.data?.[idx];
                    if (u === null || v === null || u === undefined || v === undefined) return null;
                    if (Number.isNaN(u) || Number.isNaN(v)) return null;
                    return { u, v };
                },
            },
            precip: {
                label: "Regen (acc)",
                resource: "nwp-v1-1h-2500m",
                params: ["rr_acc"],
                unit: "mm",
                min: 0,
                max: 10,
                opacity: 0.6,
                colors: ["#0ea5e9", "#38bdf8", "#facc15", "#f97316", "#ef4444"],
                crs: "EPSG:4326",
                bounds: GEO_BBOX_NWP,
                ttlMs: 20 * 60 * 1000,
                padRatio: 0.24,
                targetKey: "high",
                maxSpanLat: 2.4,
                maxSpanLon: 3.4,
                fetchTimeoutMs: 22000,
                pastHours: 0.5,
                futureHours: 10,
                value: (params, idx) => params.rr_acc?.data?.[idx] ?? null,
            },
            cloud: {
                label: "Wolken",
                resource: "nwp-v1-1h-2500m",
                params: ["tcc"],
                paramCandidates: [["tcc"], ["clct"]],
                unit: "%",
                min: 0,
                max: 100,
                opacity: 0.55,
                colors: ["#0f172a", "#334155", "#94a3b8", "#e2e8f0"],
                crs: "EPSG:4326",
                bounds: GEO_BBOX_NWP,
                ttlMs: 20 * 60 * 1000,
                padRatio: 0.24,
                targetKey: "high",
                maxSpanLat: 2.4,
                maxSpanLon: 3.4,
                fetchTimeoutMs: 24000,
                pastHours: 0.5,
                futureHours: 10,
                value: (params, idx) => {
                    const raw = params.tcc?.data?.[idx] ?? params.clct?.data?.[idx];
                    if (raw === null || raw === undefined) return null;
                    return raw <= 1 ? raw * 100 : raw;
                },
            },
            nowcast: {
                label: "Nowcast Regen",
                resource: "nowcast-v1-15min-1km",
                params: ["rr"],
                unit: "mm",
                min: 0,
                max: 5,
                opacity: 0.65,
                colors: ["#0ea5e9", "#38bdf8", "#facc15", "#f97316", "#ef4444"],
                crs: "EPSG:31287",
                bounds: GEO_BBOX_NOWCAST,
                ttlMs: 4 * 60 * 1000,
                padRatio: 0.18,
                targetKey: "mid",
                maxSpanLat: 1.6,
                maxSpanLon: 2.2,
                fetchTimeoutMs: 22000,
                pastHours: 0.25,
                futureHours: 3,
                value: (params, idx) => params.rr?.data?.[idx] ?? null,
            },
        };
        let thermikHoverState = null;
        let thermikRenderRaf = null;
        let thermikRenderTimer = null;
        let locationSuggestItems = [];
        let locationSuggestFocus = -1;
        let locationSuggestReqId = 0;
        let locationSuggestDebounce = null;
        // Don't refresh the whole dashboard every minute (rate limits + flicker).
        // Instead, poll a lightweight "dataset stamp" and only reload when new data exists.
        const DATASET_POLL_INTERVAL_MS = 5 * 60 * 1000;
        let autoRefreshTimer = null;
        let activeSiteRequests = 0;

        const MOJIBAKE_RE = /(?:[\u00c3\u00c2\u00ce\u00e2]|\uFFFD)/;
        const repairMojibake = (value) => {
            if (typeof value !== "string" || !MOJIBAKE_RE.test(value) || typeof TextDecoder === "undefined") return value;
            try {
                const bytes = Uint8Array.from(value, (ch) => ch.charCodeAt(0) & 0xff);
                const decoded = new TextDecoder("utf-8", { fatal: false }).decode(bytes);
                const score = (text) => ((text.match(/[\u00c3\u00c2\u00ce\u00e2]/g) || []).length + (text.match(/\uFFFD/g) || []).length * 2);
                return score(decoded) < score(value) ? decoded : value;
            } catch (err) {
                return value;
            }
        };
        const normalizeDisplayText = (value) => {
            if (value === null || value === undefined) return value;
            let out = String(value);
            out = repairMojibake(out);
            out = out
                .replace(/\u00c3\u0084/g, "\u00c4")
                .replace(/\u00c3\u0096/g, "\u00d6")
                .replace(/\u00c3\u009c/g, "\u00dc")
                .replace(/\u00c3\u00a4/g, "\u00e4")
                .replace(/\u00c3\u00b6/g, "\u00f6")
                .replace(/\u00c3\u00bc/g, "\u00fc")
                .replace(/\u00c3\u009f/g, "\u00df")
                .replace(/\u00c3\u0097/g, "\u00d7")
                .replace(/\u00c2\u00b0/g, "\u00b0")
                .replace(/\u00c2\u00b1/g, "\u00b1")
                .replace(/\u00c2\u00b7/g, "\u00b7")
                .replace(/\u00c2\u00b3/g, "\u00b3");
            out = out.replace(/\?bersicht/g, "\u00dcbersicht");
            out = out.replace(/ \+\/-(\d+)/g, " \u00b1$1");
            out = out.replace(/Unsicherheit \?(\d+)/g, "Unsicherheit \u00b1$1");
            out = out.replace(/(\d{1,3})\?\s*(NNE|NE|ENE|ESE|SE|SSE|SSW|SW|WSW|WNW|NW|NNW|N|E|S|W)\b/g, "$1\u00b0 $2");
            out = out.replace(/\bdeg\b/g, "\u00b0");
            return out;
        };
        const normalizeStaticDomText = () => {
            if (!document.body || typeof NodeFilter === "undefined") return;
            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_TEXT);
            let node = walker.nextNode();
            while (node) {
                const parentTag = node.parentElement ? node.parentElement.tagName : "";
                if (parentTag !== "SCRIPT" && parentTag !== "STYLE" && parentTag !== "NOSCRIPT") {
                    const normalized = normalizeDisplayText(node.nodeValue || "");
                    if (normalized !== node.nodeValue) node.nodeValue = normalized;
                }
                node = walker.nextNode();
            }
            document.querySelectorAll("[placeholder],[title],[aria-label]").forEach((el) => {
                ["placeholder", "title", "aria-label"].forEach((attr) => {
                    const raw = el.getAttribute(attr);
                    if (!raw) return;
                    const normalized = normalizeDisplayText(raw);
                    if (normalized !== raw) el.setAttribute(attr, normalized);
                });
            });
        };

        const setText = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = normalizeDisplayText(value ?? "-");
        };
        const setHTML = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.innerHTML = normalizeDisplayText(value ?? "-");
        };
        normalizeStaticDomText();

        const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
        const avg = (arr) => {
            if (!Array.isArray(arr)) return null;
            const nums = arr.filter((v) => v !== null && v !== undefined && !Number.isNaN(v));
            if (!nums.length) return null;
            return nums.reduce((a, b) => a + b, 0) / nums.length;
        };
        const minMax = (arr) => {
            if (!Array.isArray(arr)) return { min: null, max: null };
            const nums = arr.filter((v) => v !== null && v !== undefined && !Number.isNaN(v));
            if (!nums.length) return { min: null, max: null };
            return { min: Math.min(...nums), max: Math.max(...nums) };
        };
        const formatValue = (value, unit = "", digits = 1) => {
            if (value === null || value === undefined || Number.isNaN(value)) return "-";
            const suffix = unit ? ` ${unit}` : "";
            return `${Number(value).toFixed(digits)}${suffix}`;
        };
        const spanText = (p10, p90, unit = "m/s", digits = 1) => {
            if (p10 === null || p10 === undefined || Number.isNaN(p10) || p90 === null || p90 === undefined || Number.isNaN(p90)) {
                return "Spanne -";
            }
            return `Spanne ${formatValue(p10, unit, digits)} - ${formatValue(p90, unit, digits)}`;
        };
        const windSpanText = (speed, p10, p90, unit = "m/s", digits = 1) => {
            if (p10 !== null && p10 !== undefined && !Number.isNaN(p10) && p90 !== null && p90 !== undefined && !Number.isNaN(p90)) {
                return spanText(p10, p90, unit, digits);
            }
            const q = approximateQuantiles(speed, 0.35 * (speed || 0) + 0.4);
            return spanText(q.p10, q.p90, unit, digits);
        };
        const windSpanTextKmh = (speedMs, p10Ms, p90Ms) => {
            if (p10Ms !== null && p10Ms !== undefined && !Number.isNaN(p10Ms) && p90Ms !== null && p90Ms !== undefined && !Number.isNaN(p90Ms)) {
                return `Spanne ${formatValue(toKmh(p10Ms), "km/h", 0)} - ${formatValue(toKmh(p90Ms), "km/h", 0)}`;
            }
            const q = approximateQuantiles(speedMs, 0.35 * (speedMs || 0) + 0.4);
            return `Spanne ${formatValue(toKmh(q.p10), "km/h", 0)} - ${formatValue(toKmh(q.p90), "km/h", 0)}`;
        };
        const toKmh = (ms) => (ms === null || ms === undefined || Number.isNaN(ms) ? null : ms * 3.6);
        const windChillC = (tempC, windKmh) => {
            if (tempC === null || tempC === undefined || Number.isNaN(tempC)) return null;
            if (windKmh === null || windKmh === undefined || Number.isNaN(windKmh)) return null;
            if (windKmh < 4.8 || tempC > 10) return null;
            const vPow = Math.pow(windKmh, 0.16);
            return 13.12 + 0.6215 * tempC - 11.37 * vPow + 0.3965 * tempC * vPow;
        };
        const dewpointC = (tempC, rhPct) => {
            if (tempC === null || tempC === undefined || Number.isNaN(tempC)) return null;
            if (rhPct === null || rhPct === undefined || Number.isNaN(rhPct)) return null;
            const rh = clamp(rhPct, 1, 100);
            const a = 17.27;
            const b = 237.7;
            const gamma = Math.log(rh / 100) + (a * tempC) / (b + tempC);
            return (b * gamma) / (a - gamma);
        };
        const pressureAtElevation = (z) => {
            const zM = z ?? 0;
            return 101325 * Math.pow(1 - 2.25577e-5 * zM, 5.25588);
        };
        const airDensity = (tempC, rhPct, elevM) => {
            if (tempC === null || tempC === undefined || Number.isNaN(tempC)) return null;
            const T = tempC + 273.15;
            const P = pressureAtElevation(elevM ?? 0);
            const rh = rhPct !== null && rhPct !== undefined && !Number.isNaN(rhPct) ? clamp(rhPct, 0, 100) / 100 : 0.6;
            const es = 611.2 * Math.exp((17.62 * tempC) / (243.12 + tempC));
            const e = rh * es;
            const Rd = 287.05;
            const Rv = 461.5;
            return (P - e) / (Rd * T) + e / (Rv * T);
        };
        const densityAltitude = (tempC, rhPct, elevM) => {
            const rho = airDensity(tempC, rhPct, elevM);
            if (rho === null || rho === undefined) return null;
            const rho0 = 1.225;
            return 44330 * (1 - Math.pow(rho / rho0, 0.235));
        };
        const lclHeightAgl = (tempC, rhPct) => {
            const td = dewpointC(tempC, rhPct);
            if (td === null || td === undefined) return null;
            const delta = tempC - td;
            if (delta < 0) return 0;
            return delta * 125;
        };
        const THERMIK_HEIGHTS = Array.from({ length: 15 }, (_, i) => (i + 1) * 200);
        const THERMIK_STEPS = [0, 0.5, 1, 1.5, 2, 2.5];
        const THERMIK_COLORS = ["#f4e6c3", "#d7f2c1", "#a6e4b6", "#6dd3c3", "#4fb4d1", "#2b7db8"];
        const cloudToStep = (pct) => {
            if (pct === null || pct === undefined || Number.isNaN(pct)) return null;
            const v = pct / 100;
            if (v < 0.1) return 0;
            if (v < 0.25) return 1;
            if (v < 0.45) return 2;
            if (v < 0.65) return 3;
            if (v < 0.85) return 4;
            return 5;
        };
        const colorForThermik = (value) => {
            if (value === null || value === undefined || Number.isNaN(value)) return THERMIK_COLORS[0];
            for (let i = THERMIK_STEPS.length - 1; i >= 0; i -= 1) {
                if (value >= THERMIK_STEPS[i]) return THERMIK_COLORS[i];
            }
            return THERMIK_COLORS[0];
        };
        const drawArrow = (ctx, x, y, angleRad, length, color) => {
            const x2 = x + Math.cos(angleRad) * length;
            const y2 = y + Math.sin(angleRad) * length;
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.2;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            const head = 4;
            const a1 = angleRad + Math.PI * 0.75;
            const a2 = angleRad - Math.PI * 0.75;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 + Math.cos(a1) * head, y2 + Math.sin(a1) * head);
            ctx.lineTo(x2 + Math.cos(a2) * head, y2 + Math.sin(a2) * head);
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
        };
        const drawCloudIcon = (ctx, x, y, size, color) => {
            const r = size * 0.22;
            const baseY = y + r * 0.6;
            ctx.fillStyle = color;
            ctx.beginPath();
            ctx.arc(x - r * 1.4, baseY, r, Math.PI * 0.3, Math.PI * 1.3);
            ctx.arc(x - r * 0.2, baseY - r * 0.6, r * 1.1, Math.PI * 0.9, Math.PI * 1.9);
            ctx.arc(x + r * 1.2, baseY, r * 0.95, Math.PI * 1.1, Math.PI * 0.1);
            ctx.closePath();
            ctx.fill();
        };
        const DEFAULT_TOUR_ALTITUDES = [2000, 2500, 3000, 3500];
        const TOUR_ALT_COLORS = ["#38bdf8", "#f59e0b", "#a78bfa", "#22d3ee", "#fb7185"];
        const getSelectedTourAltitudes = () => {
            if (!tourAltChecks || !tourAltChecks.length) return DEFAULT_TOUR_ALTITUDES.slice();
            const values = tourAltChecks
                .filter((el) => el && el.checked)
                .map((el) => Number(el.value))
                .filter((v) => Number.isFinite(v) && v >= 0);
            return values.length ? values : DEFAULT_TOUR_ALTITUDES.slice();
        };
        const formatPercent = (value, digits = 0) => {
            if (value === null || value === undefined || Number.isNaN(value)) return "-";
            return `${Number(value).toFixed(digits)}%`;
        };
        const formatLabel = (iso) => {
            if (!iso) return "-";
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return iso.replace("T", " ");
            const pad = (v) => String(v).padStart(2, "0");
            return `${dt.getFullYear()}-${pad(dt.getMonth() + 1)}-${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
        };
        const parseLocal = (label) => {
            if (!label) return null;
            const iso = label.includes("T") ? label : label.replace(" ", "T");
            const dt = new Date(iso);
            return Number.isNaN(dt.getTime()) ? null : dt;
        };
        const pickCurrentIndex = (labelsIso) => {
            if (!Array.isArray(labelsIso) || !labelsIso.length) return 0;
            const now = Date.now();
            let bestIdx = 0;
            let bestDiff = Infinity;
            for (let i = 0; i < labelsIso.length; i += 1) {
                const label = labelsIso[i];
                if (!label) continue;
                const dt = new Date(label);
                if (Number.isNaN(dt.getTime())) continue;
                const diff = Math.abs(dt.getTime() - now);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestIdx = i;
                }
            }
            return bestDiff === Infinity ? 0 : bestIdx;
        };
        const WEEKDAYS = ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"];
        const dayKeyFromIso = (iso) => {
            if (!iso) return null;
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return null;
            const pad = (v) => String(v).padStart(2, "0");
            return `${dt.getFullYear()}-${pad(dt.getMonth() + 1)}-${pad(dt.getDate())}`;
        };
        const dayLabelFromIso = (iso) => {
            if (!iso) return "-";
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return iso;
            const key = dayKeyFromIso(iso);
            const wd = WEEKDAYS[dt.getDay()];
            return `${key} (${wd})`;
        };
        const getDayOptions = (labelsIso) => {
            const map = new Map();
            (labelsIso || []).forEach((iso) => {
                const key = dayKeyFromIso(iso);
                if (!key || map.has(key)) return;
                map.set(key, iso);
            });
            return Array.from(map.entries()).map(([key, iso]) => ({ key, label: dayLabelFromIso(iso) }));
        };
        const getDayIndices = (labelsIso, dayKey) => {
            if (!labelsIso || !dayKey) return [];
            const indices = [];
            for (let i = 0; i < labelsIso.length; i += 1) {
                if (dayKeyFromIso(labelsIso[i]) === dayKey) indices.push(i);
            }
            return indices;
        };
        const filterByIndices = (arr, indices) => {
            if (!Array.isArray(arr) || !indices || !indices.length) return arr || [];
            return indices.map((i) => arr[i]);
        };
        const formatShortDateTime = (iso, fallbackLabel) => {
            const dt = parseLocal(iso || fallbackLabel);
            if (!dt) return fallbackLabel || iso || "-";
            const dd = String(dt.getDate()).padStart(2, "0");
            const mm = String(dt.getMonth() + 1).padStart(2, "0");
            const hh = String(dt.getHours()).padStart(2, "0");
            return `${dd}.${mm} ${hh}:00`;
        };
        const chartLabelsForDayFilter = (labelsIso, labels, indices, dayKey) => {
            if (!indices || !indices.length) return labels || labelsIso || [];
            // When a specific day is selected, emit explicit date+time labels so the x-axis
            // cannot drift from the selected day due to automatic tick formatting.
            if (dayKey && dayKey !== "all") {
                return indices.map((i) => formatShortDateTime(labelsIso?.[i], labels?.[i]));
            }
            return indices.map((i) => (labels && labels[i] !== undefined ? labels[i] : labelsIso?.[i]));
        };
        const pickBestIndexForDay = (labelsIso, dayKey, scoreArr) => {
            const indices = getDayIndices(labelsIso, dayKey);
            if (!indices.length) return null;
            let bestIdx = indices[0];
            let bestVal = scoreArr && scoreArr[bestIdx] !== null && scoreArr[bestIdx] !== undefined ? scoreArr[bestIdx] : -999;
            for (let i = 1; i < indices.length; i += 1) {
                const idx = indices[i];
                const val = scoreArr && scoreArr[idx] !== null && scoreArr[idx] !== undefined ? scoreArr[idx] : -999;
                if (val > bestVal) {
                    bestVal = val;
                    bestIdx = idx;
                }
            }
            return bestIdx;
        };
        let currentTourDay = "all";
        let currentParaDay = "all";
        let currentXcDay = "all";
        let currentRideDay = "all";
        const formatDate = (dt) => {
            if (!dt) return "-";
            const pad = (v) => String(v).padStart(2, "0");
            return `${dt.getFullYear()}-${pad(dt.getMonth() + 1)}-${pad(dt.getDate())} ${pad(dt.getHours())}:${pad(dt.getMinutes())}`;
        };
        const wrapAngle = (deg) => {
            if (deg === null || deg === undefined || Number.isNaN(deg)) return null;
            const v = deg % 360;
            return v < 0 ? v + 360 : v;
        };
        const angleDiff = (a, b) => {
            const da = wrapAngle(a);
            const db = wrapAngle(b);
            if (da === null || db === null) return null;
            let diff = da - db;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return diff;
        };
        const dirInSector = (dir, min, max) => {
            const d = wrapAngle(dir);
            if (d === null) return false;
            const a = wrapAngle(min);
            const b = wrapAngle(max);
            if (a === null || b === null) return false;
            if (a <= b) return d >= a && d <= b;
            return d >= a || d <= b;
        };
        const toCompass = (deg) => {
            if (deg === null || deg === undefined || Number.isNaN(deg)) return "-";
            const d = wrapAngle(deg);
            if (d === null) return "-";
            const dirs = ["N", "NNE", "NE", "ENE", "E", "ESE", "SE", "SSE", "S", "SSW", "SW", "WSW", "W", "WNW", "NW", "NNW", "N"];
            const idx = Math.round(d / 22.5);
            return `${Math.round(d)}\u00b0 ${dirs[idx]}`;
        };
        const windToUV = (speed, dir) => {
            if (speed === null || dir === null || Number.isNaN(speed) || Number.isNaN(dir)) return null;
            const rad = (dir * Math.PI) / 180;
            const u = -speed * Math.sin(rad);
            const v = -speed * Math.cos(rad);
            return { u, v };
        };
        const uvToWind = (u, v) => {
            if (u === null || v === null || Number.isNaN(u) || Number.isNaN(v)) return null;
            const speed = Math.sqrt(u * u + v * v);
            const dir = (Math.atan2(-u, -v) * 180) / Math.PI;
            return { speed, dir: wrapAngle(dir) };
        };
        const interp = (x, xs, ys) => {
            if (!Array.isArray(xs) || !Array.isArray(ys) || xs.length !== ys.length || xs.length === 0) return null;
            if (x <= xs[0]) return ys[0];
            if (x >= xs[xs.length - 1]) return ys[ys.length - 1];
            for (let i = 1; i < xs.length; i += 1) {
                if (x <= xs[i]) {
                    const x0 = xs[i - 1];
                    const x1 = xs[i];
                    const y0 = ys[i - 1];
                    const y1 = ys[i];
                    if (y0 === null || y1 === null || Number.isNaN(y0) || Number.isNaN(y1)) return null;
                    const t = (x - x0) / (x1 - x0);
                    return y0 + (y1 - y0) * t;
                }
            }
            return null;
        };
        const FORCE_LIVE = location.protocol.startsWith("http");
        const cacheGet = (key, ttlMs) => {
            if (FORCE_LIVE) return null;
            try {
                const raw = localStorage.getItem(key);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                if (!parsed || !parsed.ts) return null;
                if (Date.now() - parsed.ts > ttlMs) return null;
                return parsed.data;
            } catch (err) {
                return null;
            }
        };
        const cacheSet = (key, data) => {
            try {
                localStorage.setItem(key, JSON.stringify({ ts: Date.now(), data }));
            } catch (err) {
                // ignore cache errors
            }
        };
        const cacheKey = (kind, site, tag) => `${kind}:${site.lat.toFixed(3)}:${site.lon.toFixed(3)}:${tag}`;
        const cacheKeyGeneric = (kind, tag) => `${kind}:${tag}`;
        const FETCH_TIMEOUT_MS = 15000;
        const fetchWithTimeout = async (url, timeoutMs = FETCH_TIMEOUT_MS) => {
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            try {
                return await fetch(url, { signal: controller.signal });
            } finally {
                clearTimeout(id);
            }
        };
        const fetchJson = async (url, timeoutMs) => {
            const res = await fetchWithTimeout(url, timeoutMs);
            if (!res.ok) {
                throw new Error(`Request failed (${res.status})`);
            }
            return res.json();
        };
        const fetchText = async (url, timeoutMs) => {
            const res = await fetchWithTimeout(url, timeoutMs);
            if (!res.ok) {
                throw new Error(`Request failed (${res.status})`);
            }
            return res.text();
        };
        const buildUrl = (base, params) => `${base}?${new URLSearchParams(params).toString()}`;

        const DATASET_STAMP_KEY_PREFIX = "alpenwetter_dataset_stamp_v1";
        const datasetStampStorageKey = (site) => {
            if (!site) return `${DATASET_STAMP_KEY_PREFIX}:unknown`;
            return `${DATASET_STAMP_KEY_PREFIX}:${site.lat.toFixed(3)}:${site.lon.toFixed(3)}`;
        };
        const getStoredDatasetStamp = (site) => {
            try {
                return localStorage.getItem(datasetStampStorageKey(site)) || null;
            } catch (err) {
                return null;
            }
        };
        const setStoredDatasetStamp = (site, stamp) => {
            try {
                localStorage.setItem(datasetStampStorageKey(site), stamp);
            } catch (err) {
                // ignore
            }
        };
        const csvFirstTimeIso = (raw) => {
            if (!raw) return null;
            const lines = String(raw).split(/\r?\n/);
            // line 0 = header
            for (let i = 1; i < lines.length; i += 1) {
                const line = lines[i].trim();
                if (!line) continue;
                const idx = line.indexOf(",");
                if (idx <= 0) continue;
                return line.slice(0, idx);
            }
            return null;
        };
        const fetchTimeseriesStamp = async (endpoint, site, parameter) => {
            const query = {
                lat_lon: `${site.lat},${site.lon}`,
                parameters: parameter,
                output_format: "csv",
                forecast_offset: 0,
            };
            const url = buildUrl(endpoint, query);
            const raw = await fetchText(url, 12000);
            const firstIso = csvFirstTimeIso(raw);
            if (!firstIso) throw new Error("Stamp parse failed");
            return firstIso;
        };
        const pickStampSourcesForSite = (site) => {
            const sources = [
                { kind: "inca", endpoint: GEO_TS_NOWCAST, parameter: "t2m" },
                { kind: "nwp", endpoint: GEO_TS_NWP, parameter: "t2m" },
                { kind: "ens", endpoint: GEO_TS_ENSEMBLE, parameter: "t2m_p50" },
            ];
            const payload = currentPayload;
            if (payload && payload.site && payload.site.name === site?.name && payload.missing) {
                if (payload.missing.nowcast === false) return [sources[0], sources[1], sources[2]];
                if (payload.missing.nwp === false) return [sources[1], sources[0], sources[2]];
                if (payload.missing.ensemble === false) return [sources[2], sources[1], sources[0]];
            }
            return sources;
        };
        const fetchRemoteDatasetStamp = async (site) => {
            if (!site) return null;
            const sources = pickStampSourcesForSite(site);
            for (const src of sources) {
                try {
                    const iso = await fetchTimeseriesStamp(src.endpoint, site, src.parameter);
                    if (iso) return `${src.kind}:${iso}`;
                } catch (err) {
                    // try next source
                }
            }
            return null;
        };

        const parseCsv = (raw) => {
            if (!raw) return [];
            const lines = raw.trim().split(/\r?\n/).filter(Boolean);
            return lines.map((line) => line.split(","));
        };

        const parseGeosphereCsv = (raw) => {
            const rows = parseCsv(raw);
            if (!rows.length) return { labels_iso: [], data: {} };
            const headers = rows[0].map((h) => h.split(" [")[0].trim());
            if (headers.length) {
                headers[0] = headers[0].replace(/^\uFEFF/, "");
            }
            const data = {};
            headers.forEach((h) => { data[h] = []; });
            for (let i = 1; i < rows.length; i += 1) {
                const row = rows[i];
                if (!row || !row.length) continue;
                for (let c = 0; c < headers.length; c += 1) {
                    const key = headers[c];
                    const val = row[c];
                    if (c == 0) {
                        data[key].push(val);
                    } else {
                        if (val === undefined || val === "") {
                            data[key].push(null);
                        } else {
                            const num = Number(val);
                            data[key].push(Number.isNaN(num) ? null : num);
                        }
                    }
                }
            }
            const labelsIso = data.time || data.valid_time || [];
            return { labels_iso: labelsIso, data };
        };

        const hasValues = (arr) => Array.isArray(arr) && arr.some((v) => v !== null && v !== undefined && !Number.isNaN(v));

        const fetchGeosphereTimeseries = async (endpoint, site, params, ttlMs, tag) => {
            const key = cacheKey("geo", site, `${tag}:${params.join("|")}`);
            let raw = cacheGet(key, ttlMs);
            if (!raw) {
                const query = {
                    lat_lon: `${site.lat},${site.lon}`,
                    parameters: params.join(","),
                    output_format: "csv",
                    forecast_offset: 0,
                };
                const url = buildUrl(endpoint, query);
                const res = await fetchWithTimeout(url);
                if (!res.ok) {
                    throw new Error(`Geosphere ${tag} failed (${res.status})`);
                }
                raw = await res.text();
                cacheSet(key, raw);
            }
            return parseGeosphereCsv(raw);
        };

        const hourKey = (iso) => {
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return null;
            return Math.floor(dt.getTime() / 3600000);
        };

        const alignSeries = (labelsIsoTarget, source, key) => {
            const out = new Array(labelsIsoTarget.length).fill(null);
            if (!source || !source.labels_iso || !source.labels_iso.length) return out;
            const values = source.data[key] || [];
            const map = new Map();
            for (let i = 0; i < source.labels_iso.length; i += 1) {
                const h = hourKey(source.labels_iso[i]);
                if (h === null) continue;
                map.set(h, values[i] ?? null);
            }
            for (let i = 0; i < labelsIsoTarget.length; i += 1) {
                const h = hourKey(labelsIsoTarget[i]);
                out[i] = map.get(h) ?? null;
            }
            return out;
        };

        const diffAccum = (arr) => {
            const out = [];
            let prev = null;
            for (let i = 0; i < arr.length; i += 1) {
                const val = arr[i];
                if (val === null || val === undefined || Number.isNaN(val)) {
                    out.push(null);
                    prev = null;
                    continue;
                }
                if (prev === null) {
                    out.push(val);
                } else {
                    const diff = val - prev;
                    out.push(diff < 0 ? 0 : diff);
                }
                prev = val;
            }
            return out;
        };

        const aggregateNowcast = (raw) => {
            if (!raw || !raw.labels_iso || !raw.labels_iso.length) return { labels_iso: [], data: {} };
            const groups = new Map();
            const labels = raw.labels_iso;
            const t2m = raw.data.t2m || [];
            const rh2m = raw.data.rh2m || [];
            const rr = raw.data.rr || [];
            const ff = raw.data.ff || [];
            const dd = raw.data.dd || [];
            const fx = raw.data.fx || [];
            for (let i = 0; i < labels.length; i += 1) {
                const h = hourKey(labels[i]);
                if (h === null) continue;
                if (!groups.has(h)) {
                    groups.set(h, {
                        t2mSum: 0, t2mCount: 0,
                        rhSum: 0, rhCount: 0,
                        rrSum: 0,
                        ffSum: 0, ffCount: 0,
                        uSum: 0, vSum: 0, dirCount: 0,
                        gustMax: null,
                    });
                }
                const g = groups.get(h);
                const tVal = t2m[i];
                if (tVal !== null && tVal !== undefined && !Number.isNaN(tVal)) {
                    g.t2mSum += tVal; g.t2mCount += 1;
                }
                const rVal = rh2m[i];
                if (rVal !== null && rVal !== undefined && !Number.isNaN(rVal)) {
                    g.rhSum += rVal; g.rhCount += 1;
                }
                const rrVal = rr[i];
                if (rrVal !== null && rrVal !== undefined && !Number.isNaN(rrVal)) {
                    g.rrSum += rrVal;
                }
                const ffVal = ff[i];
                if (ffVal !== null && ffVal !== undefined && !Number.isNaN(ffVal)) {
                    g.ffSum += ffVal; g.ffCount += 1;
                }
                const ddVal = dd[i];
                if (ddVal !== null && ddVal !== undefined && !Number.isNaN(ddVal)) {
                    const speed = (ffVal !== null && ffVal !== undefined && !Number.isNaN(ffVal)) ? ffVal : 1;
                    const uv = windToUV(speed, ddVal);
                    if (uv) {
                        g.uSum += uv.u; g.vSum += uv.v; g.dirCount += 1;
                    }
                }
                const fxVal = fx[i];
                if (fxVal !== null && fxVal !== undefined && !Number.isNaN(fxVal)) {
                    g.gustMax = g.gustMax === null ? fxVal : Math.max(g.gustMax, fxVal);
                }
            }
            const hourKeys = Array.from(groups.keys()).sort((a, b) => a - b);
            const out = { labels_iso: [], data: { t2m: [], rh2m: [], rr: [], ff: [], dd: [], fx: [] } };
            hourKeys.forEach((h) => {
                const g = groups.get(h);
                const iso = new Date(h * 3600000).toISOString();
                out.labels_iso.push(iso);
                out.data.t2m.push(g.t2mCount ? g.t2mSum / g.t2mCount : null);
                out.data.rh2m.push(g.rhCount ? g.rhSum / g.rhCount : null);
                out.data.rr.push(g.rrSum);
                out.data.ff.push(g.ffCount ? g.ffSum / g.ffCount : null);
                if (g.dirCount) {
                    const wind = uvToWind(g.uSum / g.dirCount, g.vSum / g.dirCount);
                    out.data.dd.push(wind ? wind.dir : null);
                } else {
                    out.data.dd.push(null);
                }
                out.data.fx.push(g.gustMax);
            });
            return out;
        };

        const normalizeCloudPct = (arr) => {
            if (!Array.isArray(arr) || !arr.length) return arr;
            let max = null;
            for (let i = 0; i < arr.length; i += 1) {
                const v = arr[i];
                if (v === null || v === undefined || Number.isNaN(v)) continue;
                max = max === null ? v : Math.max(max, v);
            }
            if (max === null) return arr;
            if (max <= 1.5) {
                return arr.map((v) => (v === null || v === undefined || Number.isNaN(v) ? null : v * 100));
            }
            return arr;
        };

        const rollingSum = (arr, windowSize) => {
            if (!Array.isArray(arr) || !arr.length) return [];
            const out = new Array(arr.length).fill(null);
            for (let i = 0; i < arr.length; i += 1) {
                let sum = 0;
                let count = 0;
                const start = Math.max(0, i - windowSize + 1);
                for (let j = start; j <= i; j += 1) {
                    const v = arr[j];
                    if (v === null || v === undefined || Number.isNaN(v)) continue;
                    sum += v;
                    count += 1;
                }
                out[i] = count ? sum : null;
            }
            return out;
        };

        const integrateSnow24Series = (snow24Series, labelsIso, windowHours = 24) => {
            if (!Array.isArray(snow24Series) || !snow24Series.length) return [];
            const out = new Array(snow24Series.length).fill(null);
            const safeWindow = Math.max(1, windowHours || 24);
            let sum = 0;
            let hasValue = false;
            let prevTs = null;
            for (let i = 0; i < snow24Series.length; i += 1) {
                const v = snow24Series[i];
                const iso = Array.isArray(labelsIso) ? labelsIso[i] : null;
                const ts = typeof iso === "string" ? Date.parse(iso) : NaN;
                let dtHours = 1;
                if (Number.isFinite(ts) && prevTs !== null && ts > prevTs) {
                    dtHours = clamp((ts - prevTs) / 3600000, 0.25, 6);
                }
                if (v !== null && v !== undefined && !Number.isNaN(v)) {
                    sum += Math.max(0, v) * (dtHours / safeWindow);
                    hasValue = true;
                }
                out[i] = hasValue ? sum : null;
                if (Number.isFinite(ts)) prevTs = ts;
            }
            return out;
        };

        const findZeroLevel = (gridZ, gridT) => {
            if (!Array.isArray(gridZ) || !Array.isArray(gridT) || gridZ.length < 2) return null;
            let below = true;
            let above = true;
            for (let i = 0; i < gridT.length; i += 1) {
                const t = gridT[i];
                if (t === null || t === undefined || Number.isNaN(t)) continue;
                if (t > 0) below = false;
                if (t < 0) above = false;
            }
            if (above) return gridZ[gridZ.length - 1];
            if (below) return 0;
            for (let i = 1; i < gridT.length; i += 1) {
                const t0 = gridT[i - 1];
                const t1 = gridT[i];
                if (t0 === null || t1 === null || Number.isNaN(t0) || Number.isNaN(t1)) continue;
                if ((t0 <= 0 && t1 >= 0) || (t0 >= 0 && t1 <= 0)) {
                    const z0 = gridZ[i - 1];
                    const z1 = gridZ[i];
                    const ratio = t1 === t0 ? 0 : (0 - t0) / (t1 - t0);
                    return z0 + (z1 - z0) * ratio;
                }
            }
            return null;
        };

        async function fetchOpenMeteoSurfaceCloud(site) {
            const params = {
                latitude: site.lat,
                longitude: site.lon,
                hourly: "cloud_cover_low,cloud_cover_mid,cloud_cover_high",
                timezone: site.tz || "auto",
                forecast_days: 3,
            };
            const key = cacheKey("open_surface_cloud", site, params.forecast_days);
            let data = cacheGet(key, CACHE_TTL_OPENMETEO_SURFACE_MS);
            if (!data) {
                data = await fetchJson(buildUrl(OPEN_METEO_BASE, params));
                cacheSet(key, data);
            }
            const hourly = data && data.hourly ? data.hourly : {};
            return {
                labels_iso: Array.isArray(hourly.time) ? hourly.time : [],
                data: {
                    cloud_cover_low: hourly.cloud_cover_low || [],
                    cloud_cover_mid: hourly.cloud_cover_mid || [],
                    cloud_cover_high: hourly.cloud_cover_high || [],
                },
            };
        }

        async function fetchOpenMeteoSurface(site) {
            const params = {
                latitude: site.lat,
                longitude: site.lon,
                hourly: [
                    "temperature_2m",
                    "relative_humidity_2m",
                    "precipitation",
                    "cloud_cover",
                    "wind_speed_10m",
                    "wind_direction_10m",
                    "wind_gusts_10m",
                    "sunshine_duration",
                    "shortwave_radiation",
                ].join(","),
                wind_speed_unit: "ms",
                timezone: site.tz || "auto",
                forecast_days: 3,
            };
            const key = cacheKey("open_surface_ms_v2", site, params.forecast_days);
            let data = cacheGet(key, CACHE_TTL_OPENMETEO_SURFACE_MS);
            if (!data) {
                data = await fetchJson(buildUrl(OPEN_METEO_BASE, params));
                cacheSet(key, data);
            }
            const hourly = data && data.hourly ? data.hourly : {};
            return {
                labels_iso: Array.isArray(hourly.time) ? hourly.time : [],
                data: {
                    t2m: hourly.temperature_2m || [],
                    rh2m: hourly.relative_humidity_2m || [],
                    precip: hourly.precipitation || [],
                    cloud: hourly.cloud_cover || [],
                    wind_speed: hourly.wind_speed_10m || [],
                    wind_dir: hourly.wind_direction_10m || [],
                    wind_gusts: hourly.wind_gusts_10m || [],
                    sunshine: hourly.sunshine_duration || [],
                    shortwave: hourly.shortwave_radiation || [],
                },
            };
        }

        const nowcastWeight = (labelIso) => {
            const dt = new Date(labelIso);
            if (Number.isNaN(dt.getTime())) return 0;
            const diffH = (dt.getTime() - Date.now()) / 3600000;
            if (diffH <= 3) return 1;
            if (diffH >= 6) return 0;
            return (6 - diffH) / 3;
        };

        const blendValue = (a, b, w) => {
            if (a === null || a === undefined || Number.isNaN(a)) return b ?? null;
            if (b === null || b === undefined || Number.isNaN(b)) return a ?? null;
            return w * a + (1 - w) * b;
        };

        const uvSeriesToWind = (uSeries, vSeries) => {
            const speed = [];
            const dir = [];
            for (let i = 0; i < uSeries.length; i += 1) {
                const w = uvToWind(uSeries[i], vSeries[i]);
                speed.push(w ? w.speed : null);
                dir.push(w ? w.dir : null);
            }
            return { speed, dir };
        };

        const blendWind = (aSpeed, aDir, bSpeed, bDir, w) => {
            const uvA = windToUV(aSpeed, aDir);
            const uvB = windToUV(bSpeed, bDir);
            if (uvA && uvB) {
                const u = w * uvA.u + (1 - w) * uvB.u;
                const v = w * uvA.v + (1 - w) * uvB.v;
                const wind = uvToWind(u, v);
                return wind ? wind : { speed: null, dir: null };
            }
            if (uvA) return { speed: aSpeed, dir: aDir };
            if (uvB) return { speed: bSpeed, dir: bDir };
            return { speed: null, dir: null };
        };
        const alignToLabels = (labels, arr, fillValue = null) => {
            const out = new Array(labels.length).fill(fillValue);
            if (!Array.isArray(arr)) return out;
            for (let i = 0; i < labels.length && i < arr.length; i += 1) {
                out[i] = arr[i];
            }
            return out;
        };
        const solarFactor = (iso, lat) => {
            if (!iso) return 0;
            const dt = new Date(iso);
            if (Number.isNaN(dt.getTime())) return 0;
            const dayOfYear = Math.floor((Date.UTC(dt.getFullYear(), dt.getMonth(), dt.getDate()) - Date.UTC(dt.getFullYear(), 0, 0)) / 86400000);
            const hour = dt.getHours() + dt.getMinutes() / 60;
            const decl = 23.45 * Math.sin(((360 / 365) * (dayOfYear - 81) * Math.PI) / 180);
            const latRad = (lat * Math.PI) / 180;
            const declRad = (decl * Math.PI) / 180;
            const haRad = ((hour - 12) * 15 * Math.PI) / 180;
            const sinAlt = Math.sin(latRad) * Math.sin(declRad) + Math.cos(latRad) * Math.cos(declRad) * Math.cos(haRad);
            return clamp(sinAlt, 0, 1);
        };

        const scoreLabel = (score) => {
            if (score === null || score === undefined || Number.isNaN(score)) return "-";
            if (score >= 70) return "Stark";
            if (score >= 45) return "Okay";
            return "Schwach";
        };
        const scoreClass = (score) => {
            if (score === null || score === undefined || Number.isNaN(score)) return null;
            if (score >= 70) return "score-good";
            if (score >= 45) return "score-mid";
            return "score-bad";
        };
        const applyScoreClass = (target, score) => {
            const el = typeof target === "string" ? document.getElementById(target) : target;
            if (!el) return;
            el.classList.remove("score-good", "score-mid", "score-bad");
            const cls = scoreClass(score);
            if (cls) el.classList.add(cls);
        };

        const approximateQuantiles = (value, spread) => {
            if (value === null || value === undefined || Number.isNaN(value)) return { p10: null, p50: null, p90: null };
            const s = Math.max(0.3, spread ?? (0.35 * Math.abs(value) + 0.3));
            return { p10: Math.max(0, value - s), p50: value, p90: value + s };
        };
        const sanitizeWindQuant = (q, fallbackSpeed) => {
            if (!q || q.p10 === null || q.p10 === undefined || q.p90 === null || q.p90 === undefined) return q;
            const p50 = q.p50 ?? fallbackSpeed ?? 0;
            const width = q.p90 - q.p10;
            const maxWidth = Math.max(6, 2.2 * Math.max(1, p50));
            if (width > maxWidth) {
                return approximateQuantiles(fallbackSpeed, 0.25 * (fallbackSpeed || 0) + 0.5);
            }
            return q;
        };
        const probGtFromQuantiles = (threshold, q) => {
            if (!q || q.p50 === null || q.p50 === undefined) return null;
            if (threshold <= q.p10) return 0.9;
            if (threshold >= q.p90) return 0.1;
            if (threshold <= q.p50) {
                const span = q.p50 - q.p10;
                return span ? 0.5 + 0.4 * (q.p50 - threshold) / span : 0.5;
            }
            const span = q.p90 - q.p50;
            return span ? 0.5 - 0.4 * (threshold - q.p50) / span : 0.5;
        };

        async function fetchSurfaceForecast(site) {
            const ensParams = [
                "t2m_p10", "t2m_p50", "t2m_p90",
                "u10m_p10", "u10m_p50", "u10m_p90",
                "v10m_p10", "v10m_p50", "v10m_p90",
                "tcc_p10", "tcc_p50", "tcc_p90",
                "rr_p10", "rr_p50", "rr_p90",
                "sundur_p10", "sundur_p50", "sundur_p90",
            ];
            const nwpParams = ["t2m", "rh2m", "u10m", "v10m", "tcc", "rr_acc", "sundur_acc", "ugust", "vgust"];
            const incaParams = ["t2m", "rh2m", "rr", "ff", "dd", "fx"];

            let ens = { labels_iso: [], data: {} };
            let nwp = { labels_iso: [], data: {} };
            let incaRaw = { labels_iso: [], data: {} };
            let openCloudLayers = { labels_iso: [], data: {} };
            let openSurface = { labels_iso: [], data: {} };

            try {
                ens = await fetchGeosphereTimeseries(GEO_TS_ENSEMBLE, site, ensParams, CACHE_TTL_ENSEMBLE_MS, "ens");
            } catch (err) {
                ens = { labels_iso: [], data: {} };
            }
            try {
                nwp = await fetchGeosphereTimeseries(GEO_TS_NWP, site, nwpParams, CACHE_TTL_NWP_MS, "nwp");
            } catch (err) {
                nwp = { labels_iso: [], data: {} };
            }
            try {
                incaRaw = await fetchGeosphereTimeseries(GEO_TS_NOWCAST, site, incaParams, CACHE_TTL_NOWCAST_MS, "inca");
            } catch (err) {
                incaRaw = { labels_iso: [], data: {} };
            }
            try {
                openCloudLayers = await fetchOpenMeteoSurfaceCloud(site);
            } catch (err) {
                openCloudLayers = { labels_iso: [], data: {} };
            }
            try {
                openSurface = await fetchOpenMeteoSurface(site);
            } catch (err) {
                openSurface = { labels_iso: [], data: {} };
            }

            const inca = aggregateNowcast(incaRaw);

            const labelsIso = ens.labels_iso.length
                ? ens.labels_iso
                : (nwp.labels_iso.length
                    ? nwp.labels_iso
                    : (inca.labels_iso.length ? inca.labels_iso : openSurface.labels_iso));
            const labels = labelsIso.map(formatLabel);

            const ensT2m = alignSeries(labelsIso, ens, "t2m_p50");
            const ensU10 = alignSeries(labelsIso, ens, "u10m_p10");
            const ensV10 = alignSeries(labelsIso, ens, "v10m_p10");
            const ensU = alignSeries(labelsIso, ens, "u10m_p50");
            const ensV = alignSeries(labelsIso, ens, "v10m_p50");
            const ensU90 = alignSeries(labelsIso, ens, "u10m_p90");
            const ensV90 = alignSeries(labelsIso, ens, "v10m_p90");
            const ensWind = uvSeriesToWind(ensU, ensV);
            const ensWindP10 = uvSeriesToWind(ensU10, ensV10).speed;
            const ensWindP90 = uvSeriesToWind(ensU90, ensV90).speed;
            const ensCloud = normalizeCloudPct(alignSeries(labelsIso, ens, "tcc_p50"));
            const ensRr = alignSeries(labelsIso, ens, "rr_p50");
            const ensSun = alignSeries(labelsIso, ens, "sundur_p50");

            const nwpT2m = alignSeries(labelsIso, nwp, "t2m");
            const nwpRh = alignSeries(labelsIso, nwp, "rh2m");
            const nwpU = alignSeries(labelsIso, nwp, "u10m");
            const nwpV = alignSeries(labelsIso, nwp, "v10m");
            const nwpWind = uvSeriesToWind(nwpU, nwpV);
            const nwpCloud = normalizeCloudPct(alignSeries(labelsIso, nwp, "tcc"));
            const nwpRrAcc = alignSeries(labelsIso, nwp, "rr_acc");
            const nwpSunAcc = alignSeries(labelsIso, nwp, "sundur_acc");
            const nwpRr = diffAccum(nwpRrAcc);
            const nwpSun = diffAccum(nwpSunAcc);
            const nwpGustU = alignSeries(labelsIso, nwp, "ugust");
            const nwpGustV = alignSeries(labelsIso, nwp, "vgust");
            const nwpGust = uvSeriesToWind(nwpGustU, nwpGustV).speed;

            const openCloudLow = normalizeCloudPct(alignSeries(labelsIso, openCloudLayers, "cloud_cover_low"));
            const openCloudMid = normalizeCloudPct(alignSeries(labelsIso, openCloudLayers, "cloud_cover_mid"));
            const openCloudHigh = normalizeCloudPct(alignSeries(labelsIso, openCloudLayers, "cloud_cover_high"));
            const openT2m = alignSeries(labelsIso, openSurface, "t2m");
            const openRh = alignSeries(labelsIso, openSurface, "rh2m");
            const openPrecip = alignSeries(labelsIso, openSurface, "precip");
            const openCloudTotal = normalizeCloudPct(alignSeries(labelsIso, openSurface, "cloud"));
            const openWindSpeed = alignSeries(labelsIso, openSurface, "wind_speed");
            const openWindDir = alignSeries(labelsIso, openSurface, "wind_dir");
            const openGust = alignSeries(labelsIso, openSurface, "wind_gusts");
            const openSun = alignSeries(labelsIso, openSurface, "sunshine");
            const openShortwave = alignSeries(labelsIso, openSurface, "shortwave");

            const incaT2m = alignSeries(labelsIso, inca, "t2m");
            const incaRh = alignSeries(labelsIso, inca, "rh2m");
            const incaRr = alignSeries(labelsIso, inca, "rr");
            const incaWindSpeed = alignSeries(labelsIso, inca, "ff");
            const incaWindDir = alignSeries(labelsIso, inca, "dd");
            const incaGust = alignSeries(labelsIso, inca, "fx");

            const t2m = [];
            const rh = [];
            const precip = [];
            const windSpeed = [];
            const windDir = [];
            const gust = [];
            const cloud = [];
            const sun = [];

            for (let i = 0; i < labelsIso.length; i += 1) {
                const w = nowcastWeight(labelsIso[i]);
                const tBase = ensT2m[i] ?? nwpT2m[i] ?? openT2m[i];
                t2m.push(blendValue(incaT2m[i], tBase, w));

                const rhBase = nwpRh[i] ?? openRh[i];
                rh.push(blendValue(incaRh[i], rhBase, w));

                const rrEns = ensRr[i];
                const rrNwp = nwpRr[i];
                let rrBase = rrEns ?? rrNwp ?? openPrecip[i];
                if (rrBase === null || rrBase === undefined || (rrBase === 0 && rrNwp !== null && rrNwp !== undefined && rrNwp > 0.05)) {
                    rrBase = rrNwp;
                }
                precip.push(blendValue(incaRr[i], rrBase, w));

                const baseSpeed = ensWind.speed[i] ?? nwpWind.speed[i] ?? openWindSpeed[i];
                const baseDir = ensWind.dir[i] ?? nwpWind.dir[i] ?? openWindDir[i];
                const blendedWind = blendWind(incaWindSpeed[i], incaWindDir[i], baseSpeed, baseDir, w);
                windSpeed.push(blendedWind.speed);
                windDir.push(blendedWind.dir);

                gust.push(incaGust[i] ?? nwpGust[i] ?? openGust[i] ?? null);

                cloud.push(ensCloud[i] ?? nwpCloud[i] ?? openCloudTotal[i] ?? null);
                sun.push(ensSun[i] ?? nwpSun[i] ?? openSun[i] ?? null);
            }

            const series = {
                labels,
                labels_iso: labelsIso,
                timezone: site.tz || "UTC",
                t2m_C: t2m,
                rh2m_pct: rh,
                cloud_total_pct: cloud,
                cloud_low_pct: openCloudLow,
                cloud_mid_pct: openCloudMid,
                cloud_high_pct: openCloudHigh,
                precip_mm: precip,
                precip_prob_pct: new Array(labelsIso.length).fill(null),
                wind10_speed_ms: windSpeed,
                wind10_dir_deg: windDir,
                wind10_p10: ensWindP10,
                wind10_p50: ensWind.speed,
                wind10_p90: ensWindP90,
                wind_gusts_ms: gust,
                sunshine_s: sun,
                shortwave_Wm2: hasValues(openShortwave) ? openShortwave : new Array(labelsIso.length).fill(null),
                source: "GeoSphere/INCA",
            };

            if (!ens.labels_iso.length && !nwp.labels_iso.length && !inca.labels_iso.length) {
                series.source = "Open-Meteo";
            } else if (!ens.labels_iso.length && !nwp.labels_iso.length) {
                series.source = "INCA + Open-Meteo";
            }

            const missing = {
                ensemble: !ens.labels_iso.length,
                nwp: !nwp.labels_iso.length,
                nowcast: !inca.labels_iso.length,
                precip: !hasValues(precip),
                sun: !hasValues(sun),
                cloud_low: !hasValues(openCloudLow),
                wind_gusts: !hasValues(gust),
            };

            return { series, missing };
        }


        async function fetchUpperAir(site, labelsIso) {
            const fields = [];
            for (const lvl of PRESSURE_LEVELS) {
                fields.push(`temperature_${lvl}hPa`);
                fields.push(`geopotential_height_${lvl}hPa`);
                fields.push(`wind_speed_${lvl}hPa`);
                fields.push(`wind_direction_${lvl}hPa`);
            }
            const params = {
                latitude: site.lat,
                longitude: site.lon,
                hourly: fields.join(","),
                wind_speed_unit: "ms",
                timezone: site.tz || "auto",
                forecast_days: 3,
            };
            const key = cacheKey("upper_ms_v2", site, params.forecast_days);
            let data = cacheGet(key, CACHE_TTL_UPPER_MS);
            if (!data) {
                data = await fetchJson(buildUrl(OPEN_METEO_BASE, params));
                cacheSet(key, data);
            }
            const hourly = data && data.hourly ? data.hourly : {};
            const labelsUse = labelsIso && labelsIso.length ? labelsIso : (Array.isArray(hourly.time) ? hourly.time : []);
            const labels = labelsUse.map(formatLabel);
            const upper = {
                labels,
                labels_iso: labelsUse,
                levels: PRESSURE_LEVELS,
                temperature_C: {},
                geopotential_m: {},
                wind_speed_ms: {},
                wind_dir_deg: {},
            };
            for (const lvl of PRESSURE_LEVELS) {
                upper.temperature_C[lvl] = alignToLabels(labelsUse, hourly[`temperature_${lvl}hPa`]);
                upper.geopotential_m[lvl] = alignToLabels(labelsUse, hourly[`geopotential_height_${lvl}hPa`]);
                upper.wind_speed_ms[lvl] = alignToLabels(labelsUse, hourly[`wind_speed_${lvl}hPa`]);
                upper.wind_dir_deg[lvl] = alignToLabels(labelsUse, hourly[`wind_direction_${lvl}hPa`]);
            }
            const anyTemp = PRESSURE_LEVELS.some((lvl) => upper.temperature_C[lvl].some((v) => v !== null && v !== undefined));
            const anyGeo = PRESSURE_LEVELS.some((lvl) => upper.geopotential_m[lvl].some((v) => v !== null && v !== undefined));
            const anyWind = PRESSURE_LEVELS.some((lvl) => upper.wind_speed_ms[lvl].some((v) => v !== null && v !== undefined));
            const missing = {
                profile: !(anyTemp && anyGeo),
                wind: !anyWind,
            };
            return { upper, missing };
        }

        async function ensureSite(site) {
            const surface = await fetchSurfaceForecast(site);
            const series = surface.series;
            if (!series || !series.labels || !series.labels.length) {
                throw new Error("Keine Forecast-Daten");
            }
            let upper = null;
            let upperMissing = { profile: true, wind: true };
            try {
                const upperRes = await fetchUpperAir(site, series.labels_iso);
                upper = upperRes.upper;
                upperMissing = upperRes.missing || upperMissing;
            } catch (err) {
                upper = null;
            }
            const features = computeFeatures(site, series, upper);
            const missing = { ...(surface.missing || {}), ...(upperMissing || {}) };
            const start = series.labels[0] || formatLabel(series.labels_iso?.[0]);
            const end = series.labels[series.labels.length - 1] || formatLabel(series.labels_iso?.[series.labels.length - 1]);
            const window = { start, end, tz: series.timezone || site.tz || "UTC" };

            const avalancheRegion = getAvalancheRegion(site);
            let avalanche = null;
            try {
                avalanche = await fetchAvalancheBulletin(avalancheRegion, site);
            } catch (err) {
                avalanche = null;
            }

            return {
                site,
                series,
                upper,
                features,
                missing,
                window,
                warnings: null,
                avalanche,
                avalanche_region: avalancheRegion,
            };
        }

        function findInversion(zs, ts) {
            if (!Array.isArray(zs) || zs.length < 2) return null;
            const threshold = 0.3;
            const minDepth = 200;
            let baseIdx = null;
            let depth = 0;
            for (let i = 1; i < zs.length; i += 1) {
                const dz = zs[i] - zs[i - 1];
                const dT = ts[i] - ts[i - 1];
                const lapse = (dT / dz) * 100;
                if (lapse > threshold) {
                    if (baseIdx === null) baseIdx = i - 1;
                    depth += dz;
                    if (depth >= minDepth) {
                        return {
                            base: zs[baseIdx],
                            top: zs[i],
                            strength: ts[i] - ts[baseIdx],
                        };
                    }
                } else {
                    baseIdx = null;
                    depth = 0;
                }
            }
            return null;
        }

        function buildProfileForHour(upperAir, idx, terrain) {
            if (!upperAir || !upperAir.levels || !upperAir.levels.length) return null;
            const points = [];
            for (const lvl of upperAir.levels) {
                const t = upperAir.temperature_C?.[lvl]?.[idx];
                const z = upperAir.geopotential_m?.[lvl]?.[idx];
                if (t === null || z === null || t === undefined || z === undefined || Number.isNaN(t) || Number.isNaN(z)) continue;
                const windSpeed = upperAir.wind_speed_ms?.[lvl]?.[idx];
                const windDir = upperAir.wind_dir_deg?.[lvl]?.[idx];
                points.push({ z_asl: z, t_C: t, wind_speed: windSpeed, wind_dir: windDir });
            }
            if (points.length < 2) return null;
            points.sort((a, b) => a.z_asl - b.z_asl);
            const zs = points.map((p) => p.z_asl);
            const ts = points.map((p) => p.t_C);
            const t0 = interp(terrain, zs, ts);
            const t1500 = interp(terrain + 1500, zs, ts);
            const lapse_rate_low = t0 !== null && t1500 !== null ? ((t1500 - t0) / 1500) * 100 : null;

            const gridZ = [];
            const gridT = [];
            for (let z = 0; z <= 3000; z += 100) {
                const t = interp(terrain + z, zs, ts);
                if (t !== null && t !== undefined && !Number.isNaN(t)) {
                    gridZ.push(z);
                    gridT.push(t);
                }
            }
            const inversion = findInversion(gridZ, gridT);

            const windPoints = points
                .filter((p) => p.wind_speed !== null && p.wind_dir !== null && !Number.isNaN(p.wind_speed) && !Number.isNaN(p.wind_dir))
                .map((p) => {
                    const uv = windToUV(p.wind_speed, p.wind_dir);
                    return uv ? { z_asl: p.z_asl, u: uv.u, v: uv.v } : null;
                })
                .filter(Boolean)
                .sort((a, b) => a.z_asl - b.z_asl);

            return { points, wind_points: windPoints, lapse_rate_low, inversion, gridZ, gridT };
        }

        function temperatureAtAsl(upperAir, idx, targetAsl, terrain) {
            if (!upperAir || targetAsl === null || targetAsl === undefined) return null;
            const profile = buildProfileForHour(upperAir, idx, terrain ?? 0);
            if (!profile || !profile.points || !profile.points.length) return null;
            const zs = profile.points.map((p) => p.z_asl);
            const ts = profile.points.map((p) => p.t_C);
            return interp(targetAsl, zs, ts);
        }

        function windAtAsl(upperAir, idx, targetAsl, terrain) {
            if (!upperAir || targetAsl === null || targetAsl === undefined) return null;
            const profile = buildProfileForHour(upperAir, idx, terrain ?? 0);
            if (!profile || !profile.wind_points || !profile.wind_points.length) return null;
            return interpolateWindAt(targetAsl, profile.wind_points);
        }

        function windSpeedAtAsl(upperAir, idx, targetAsl, terrain) {
            const wind = windAtAsl(upperAir, idx, targetAsl, terrain);
            return wind ? wind.speed : null;
        }

        function interpolateWindAt(targetZ, windPoints) {
            if (!windPoints || windPoints.length < 2) return null;
            const zs = windPoints.map((p) => p.z_asl);
            const us = windPoints.map((p) => p.u);
            const vs = windPoints.map((p) => p.v);
            if (targetZ < zs[0] || targetZ > zs[zs.length - 1]) return null;
            const u = interp(targetZ, zs, us);
            const v = interp(targetZ, zs, vs);
            if (u === null || v === null) return null;
            return uvToWind(u, v);
        }

        function computeFeatures(site, series, upperAir) {
            const n = series.labels.length;
            const features = {
                thermal_maturity: [],
                climb_p10: [],
                climb_p50: [],
                climb_p90: [],
                blh_m: [],
                insolation_quality: [],
                lapse_rate_low: [],
                inversion_base_agl: [],
                inversion_top_agl: [],
                inversion_strength: [],
                stability_tag: [],
                wind_takeoff: [],
                wind_takeoff_dir: [],
                wind_takeoff_p10: [],
                wind_takeoff_p50: [],
                wind_takeoff_p90: [],
                wind_ridge: [],
                wind_ridge_dir: [],
                wind_work: [],
                wind_work_dir: [],
                wind_shear: [],
                wind_dir_change: [],
                gust: [],
                tailwind: [],
                crosswind: [],
                safety_score: [],
                wind_over_prob: [],
                gust_over_prob: [],
                convection_risk: [],
                flyability_prob: [],
                utility: [],
                wind_layers: {},
                debug_flags: [],
                snow_proxy_cm: [],
                snow_24h_cm: [],
                snow_48h_cm: [],
                freezing_level_agl: [],
                freezing_level_asl: [],
                wind_loading_risk: [],
                wet_snow_risk: [],
                visibility_risk: [],
                tour_score: [],
                avalanche_proxy: [],
                ride_score: [],
                ride_wetness: [],
                ride_wind_risk: [],
                ride_temp_risk: [],
                ride_light_risk: [],
                ride_precip_risk: [],
                ride_ice_risk: [],
                ride_feels_like: [],
                ride_precip_6h: [],
            };

            const windLayers = {
                10: { speed: series.wind10_speed_ms, direction: series.wind10_dir_deg },
                200: { speed: new Array(n).fill(null), direction: new Array(n).fill(null) },
                600: { speed: new Array(n).fill(null), direction: new Array(n).fill(null) },
                1500: { speed: new Array(n).fill(null), direction: new Array(n).fill(null) },
            };
            const precip6h = rollingSum(series.precip_mm || [], 6);

            for (let i = 0; i < n; i += 1) {
                const flags = [];
                const temp = series.t2m_C[i];
                const rh = series.rh2m_pct[i];
                const cloud = series.cloud_total_pct[i];
                const cloudLow = series.cloud_low_pct[i];
                const precip = series.precip_mm[i];
                const shortwave = series.shortwave_Wm2[i];
                const sunshine = series.sunshine_s[i];
                const wind10 = series.wind10_speed_ms[i];
                const wind10Dir = series.wind10_dir_deg[i];
                const gust10 = series.wind_gusts_ms[i];

                let insolation = null;
                let usedSunProxy = false;
                if (shortwave !== null && shortwave !== undefined && !Number.isNaN(shortwave)) {
                    insolation = clamp(shortwave / 600, 0, 1);
                } else if (sunshine !== null && sunshine !== undefined && !Number.isNaN(sunshine)) {
                    insolation = clamp(sunshine / 3600, 0, 1);
                } else {
                    const cloudFrac = cloud !== null && cloud !== undefined ? clamp(cloud / 100, 0, 1) : 0.7;
                    insolation = clamp((1 - cloudFrac) * solarFactor(series.labels_iso[i], site.lat), 0, 1);
                    usedSunProxy = true;
                }
                if (usedSunProxy) flags.push("sun_proxy");
                const profile = buildProfileForHour(upperAir, i, site.elevation_m);
                if (!profile) flags.push("missing_profile");

                const lapse = profile ? profile.lapse_rate_low : null;
                const inversion = profile ? profile.inversion : null;

                let stabilityScore = 0.5;
                let stabilityTag = "n/a";
                if (lapse !== null && lapse !== undefined) {
                    stabilityScore = clamp((-lapse - 0.2) / 0.8, 0, 1);
                    stabilityTag = lapse > -0.3 ? "stabil" : "labil";
                }
                if (inversion) stabilityTag = "stabil";

                const humidityPenalty = clamp(((rh || 0) / 100) * 0.6 + ((cloudLow || 0) / 100) * 0.4, 0, 1);
                const thermalMaturity = clamp(0.55 * insolation + 0.45 * stabilityScore - 0.4 * humidityPenalty, 0, 1);

                const climbP50 = thermalMaturity * 2.8;
                const climbSpread = 0.3 + (1 - thermalMaturity) * 0.6;
                const climbP10 = Math.max(0, climbP50 - climbSpread);
                const climbP90 = climbP50 + climbSpread;

                let blh = 200 + thermalMaturity * 1800;
                if (inversion && inversion.base !== null && inversion.base !== undefined) {
                    blh = Math.min(blh, inversion.base);
                }

                let windTakeoff = wind10;
                let windTakeoffDir = wind10Dir;
                let windRidge = null;
                let windRidgeDir = null;
                let windWork = null;
                let windWorkDir = null;
                let shear = null;
                let dirChange = null;

                const windPoints = profile ? profile.wind_points : null;
                if (windPoints && windPoints.length >= 2) {
                    const takeoff = interpolateWindAt(site.elevation_m + 100, windPoints);
                    const ridge = interpolateWindAt(site.elevation_m + 600, windPoints);
                    const work = interpolateWindAt(site.elevation_m + 1500, windPoints);
                    if (takeoff) {
                        windTakeoff = takeoff.speed;
                        windTakeoffDir = takeoff.dir;
                        windLayers[200].speed[i] = takeoff.speed;
                        windLayers[200].direction[i] = takeoff.dir;
                    }
                    if (ridge) {
                        windRidge = ridge.speed;
                        windRidgeDir = ridge.dir;
                        windLayers[600].speed[i] = ridge.speed;
                        windLayers[600].direction[i] = ridge.dir;
                    }
                    if (work) {
                        windWork = work.speed;
                        windWorkDir = work.dir;
                        windLayers[1500].speed[i] = work.speed;
                        windLayers[1500].direction[i] = work.dir;
                    }
                    if (takeoff && work) {
                        const uv0 = windToUV(takeoff.speed, takeoff.dir);
                        const uv1 = windToUV(work.speed, work.dir);
                        if (uv0 && uv1) {
                            const du = uv1.u - uv0.u;
                            const dv = uv1.v - uv0.v;
                            shear = Math.sqrt(du * du + dv * dv);
                            dirChange = angleDiff(work.dir, takeoff.dir);
                        }
                    }
                } else {
                    flags.push("missing_upper_wind");
                }

                const gust = gust10 !== null && gust10 !== undefined && !Number.isNaN(gust10)
                    ? gust10
                    : (windTakeoff !== null && windTakeoff !== undefined
                        ? windTakeoff + (shear ? 0.6 * shear : 0.7)
                        : null);

                const diff = angleDiff(windTakeoffDir, site.takeoff_aspect_deg);
                const diffRad = diff !== null ? (diff * Math.PI) / 180 : null;
                const headwind = diffRad !== null && windTakeoff !== null ? windTakeoff * Math.cos(diffRad) : null;
                const tailwind = headwind !== null ? Math.max(0, -headwind) : null;
                const crosswind = diffRad !== null && windTakeoff !== null ? Math.abs(windTakeoff * Math.sin(diffRad)) : null;

                const windOk = windTakeoff !== null && windTakeoff <= site.limits.max_wind && dirInSector(windTakeoffDir, site.safe_sector_min_deg, site.safe_sector_max_deg);
                const gustOk = gust !== null && gust <= site.limits.max_gust;
                const tailOk = tailwind !== null && tailwind <= site.limits.max_tailwind;
                const crossOk = crosswind !== null && crosswind <= site.limits.max_crosswind;

                let safetyScore = 1;
                if (!windOk) safetyScore -= 0.35;
                if (!gustOk) safetyScore -= 0.25;
                if (!tailOk) safetyScore -= 0.2;
                if (!crossOk) safetyScore -= 0.2;
                safetyScore = clamp(safetyScore, 0, 1);

                let windQuant = (series.wind10_p10 && series.wind10_p90)
                    ? { p10: series.wind10_p10[i], p50: series.wind10_p50[i] ?? windTakeoff, p90: series.wind10_p90[i] }
                    : approximateQuantiles(windTakeoff, 0.35 * (windTakeoff || 0) + 0.4);
                windQuant = sanitizeWindQuant(windQuant, windTakeoff);
                const gustQuant = approximateQuantiles(gust, 0.4 * (gust || 0) + 0.5);

                const windOverProb = probGtFromQuantiles(site.limits.max_wind, windQuant);
                const gustOverProb = probGtFromQuantiles(site.limits.max_gust, gustQuant);

                const freezingLevel = profile ? findZeroLevel(profile.gridZ, profile.gridT) : null;
                const freezingLevelAsl = freezingLevel !== null && freezingLevel !== undefined ? freezingLevel + site.elevation_m : null;
                const lapseFactor = lapse !== null ? clamp((-lapse - 0.45) / 0.75, 0, 1) : 0.2;
                const precipFactor = precip !== null && precip !== undefined ? clamp((precip - 0.1) / 2.0, 0, 1) : 0;
                const humidityFactor = rh !== null && rh !== undefined ? clamp((rh - 60) / 40, 0, 1) : 0;
                const sunFactor = insolation !== null && insolation !== undefined ? clamp(insolation, 0, 1) : 0;
                const tempFactor = temp !== null && temp !== undefined ? clamp((temp - 8) / 14, 0, 1) : 0;
                const freezingFactor = freezingLevelAsl !== null && freezingLevelAsl !== undefined
                    ? clamp((freezingLevelAsl - 1600) / 1600, 0, 1)
                    : tempFactor;

                const month = (() => {
                    const dt = new Date(series.labels_iso[i]);
                    return Number.isNaN(dt.getTime()) ? null : (dt.getMonth() + 1);
                })();
                const seasonFactor = month === null
                    ? 0.7
                    : ([11, 12, 1, 2].includes(month) ? 0.22 : ([3, 10].includes(month) ? 0.55 : 1));

                const convectiveBase = clamp(
                    0.5 * lapseFactor + 0.25 * precipFactor + 0.15 * humidityFactor + 0.1 * sunFactor,
                    0,
                    1
                );
                const convectiveGate = clamp(
                    0.45 * tempFactor + 0.35 * sunFactor + 0.2 * freezingFactor,
                    0,
                    1
                );
                const convectionRisk = clamp(convectiveBase * (0.15 + 0.85 * convectiveGate) * seasonFactor, 0, 1);

                let snowProxy = null;
                if (precip !== null && precip !== undefined && !Number.isNaN(precip)) {
                    const tRef = temp !== null && temp !== undefined && !Number.isNaN(temp) ? temp : 0;
                    let factor = 0;
                    if (tRef <= -1) {
                        factor = 1;
                    } else if (tRef <= 1) {
                        factor = 0.7;
                    } else if (tRef <= 2) {
                        factor = 0.3;
                    }
                    const precipVal = precip < 0.05 ? 0 : precip;
                    snowProxy = precipVal * factor;
                }

                const cloudFrac = cloud !== null && cloud !== undefined ? clamp(cloud / 100, 0, 1) : 0.6;
                const precipRiskVis = precip !== null && precip !== undefined ? clamp(precip / 2, 0, 1) : 0.2;
                const windRiskVis = windTakeoff !== null && windTakeoff !== undefined ? clamp((windTakeoff - 4) / 10, 0, 1) : 0.2;
                const visibilityRisk = clamp(0.55 * cloudFrac + 0.3 * precipRiskVis + 0.15 * windRiskVis, 0, 1);

                let wetRisk = null;
                if (temp !== null && temp !== undefined && !Number.isNaN(temp)) {
                    const tempRisk = clamp((temp - 0) / 4, 0, 1);
                    const precipWet = precip !== null && precip !== undefined && !Number.isNaN(precip)
                        ? (precip > 0.5 ? 1 : precip > 0.1 ? 0.6 : 0)
                        : 0;
                    const levelRisk = freezingLevel !== null && freezingLevel !== undefined ? clamp((freezingLevel - 300) / 900, 0, 1) : 0.2;
                    const wetBase = precipWet > 0
                        ? (0.5 * tempRisk + 0.3 * precipWet + 0.2 * levelRisk)
                        : (0.2 * tempRisk);
                    wetRisk = clamp(wetBase, 0, 1);
                }

                const shearPenalty = shear !== null ? clamp(shear / 8, 0, 1) : 0.2;
                let utility = 0.82 * thermalMaturity + 0.12 * safetyScore - 0.035 * convectionRisk - 0.01 * shearPenalty;
                let flyability = 1 / (1 + Math.exp(-2.0 * (utility - 0.18)));

                features.insolation_quality.push(insolation);
                features.thermal_maturity.push(thermalMaturity);
                features.climb_p10.push(climbP10);
                features.climb_p50.push(climbP50);
                features.climb_p90.push(climbP90);
                features.blh_m.push(blh);
                features.lapse_rate_low.push(lapse);
                features.inversion_base_agl.push(inversion ? inversion.base : null);
                features.inversion_top_agl.push(inversion ? inversion.top : null);
                features.inversion_strength.push(inversion ? inversion.strength : null);
                features.stability_tag.push(stabilityTag);

                features.wind_takeoff.push(windTakeoff);
                features.wind_takeoff_dir.push(windTakeoffDir);
                features.wind_takeoff_p10.push(windQuant.p10);
                features.wind_takeoff_p50.push(windQuant.p50);
                features.wind_takeoff_p90.push(windQuant.p90);
                features.wind_ridge.push(windRidge);
                features.wind_ridge_dir.push(windRidgeDir);
                features.wind_work.push(windWork);
                features.wind_work_dir.push(windWorkDir);
                features.wind_shear.push(shear);
                features.wind_dir_change.push(dirChange);
                features.gust.push(gust);
                features.tailwind.push(tailwind);
                features.crosswind.push(crosswind);
                features.safety_score.push(safetyScore);
                features.wind_over_prob.push(windOverProb);
                features.gust_over_prob.push(gustOverProb);
                features.convection_risk.push(convectionRisk);
                features.flyability_prob.push(flyability);
                features.utility.push(utility);
                features.snow_proxy_cm.push(snowProxy);
                features.freezing_level_agl.push(freezingLevel);
                features.freezing_level_asl.push(freezingLevelAsl);
                features.wet_snow_risk.push(wetRisk);
                features.visibility_risk.push(visibilityRisk);

                const precip6 = precip6h[i];
                const windRefRide = wind10 !== null && wind10 !== undefined ? wind10 : windTakeoff;
                let feelsLike = temp;
                if (temp !== null && temp !== undefined && windRefRide !== null && windRefRide !== undefined && temp < 12) {
                    feelsLike = temp - Math.min(6, windRefRide * 0.7);
                }
                if (temp !== null && temp !== undefined && rh !== null && rh !== undefined && temp > 24) {
                    feelsLike = temp + clamp((rh - 50) / 50, 0, 1) * 2;
                }
                let comfort = 0.4;
                const rideTemp = temp !== null && temp !== undefined ? (feelsLike ?? temp) : null;
                if (rideTemp !== null && rideTemp !== undefined) {
                    if (rideTemp <= 22) {
                        comfort = clamp((rideTemp - 7) / 15, 0, 1);
                    } else if (rideTemp <= 30) {
                        comfort = 1;
                    } else if (rideTemp <= 34) {
                        comfort = clamp((34 - rideTemp) / 4, 0, 1);
                    } else {
                        comfort = clamp((40 - rideTemp) / 6, 0, 1);
                    }
                }
                const tempRisk = clamp(1 - comfort, 0, 1);

                const precipRisk = precip !== null && precip !== undefined ? clamp(precip / 1.2, 0, 1) : 0;
                const wetness = clamp(
                    0.55 * clamp((precip6 ?? 0) / 3, 0, 1)
                    + 0.25 * clamp((rh ?? 60) / 100, 0, 1)
                    + 0.2 * clamp(((cloudLow ?? cloud ?? 60) / 100), 0, 1),
                    0,
                    1
                );
                const gustRefRide = gust10 !== null && gust10 !== undefined ? gust10 : gust;
                const windBase = windRefRide !== null && windRefRide !== undefined ? clamp((windRefRide - 4) / 9, 0, 1) : 0.3;
                const gustBase = gustRefRide !== null && gustRefRide !== undefined ? clamp((gustRefRide - 7) / 11, 0, 1) : windBase;
                const windRisk = clamp(0.6 * windBase + 0.4 * gustBase, 0, 1);
                const lightAvail = insolation !== null && insolation !== undefined ? clamp(insolation, 0, 1) : 0;
                const cloudDark = cloud !== null && cloud !== undefined ? clamp(cloud / 100, 0, 1) : 0.7;
                const darkRisk = clamp((1 - lightAvail) * (0.55 + 0.45 * cloudDark), 0, 1);

                let iceRisk = 0;
                if (temp !== null && temp !== undefined) {
                    const cold = clamp((1.5 - temp) / 3, 0, 1);
                    iceRisk = clamp(cold * (0.4 + 0.6 * wetness), 0, 1);
                }

                let rideScore = 100 * clamp(1 - (0.26 * precipRisk + 0.26 * windRisk + 0.32 * tempRisk + 0.12 * darkRisk), 0, 1);
                if (precipRisk > 0.7) rideScore = Math.min(rideScore, 40);
                if (convectionRisk > 0.6) rideScore = Math.min(rideScore, 50);
                if (rideTemp !== null && rideTemp < 8) rideScore = Math.min(rideScore, 65);
                else if (rideTemp !== null && rideTemp < 12) rideScore = Math.min(rideScore, 75);
                if (lightAvail <= 0.02) rideScore = Math.min(rideScore, 68);
                if (lightAvail <= 0.02 && cloudDark > 0.85) rideScore = Math.min(rideScore, 60);
                if (darkRisk > 0.85) rideScore = Math.min(rideScore, 64);
                if (darkRisk > 0.93 && cloudDark > 0.9) rideScore = Math.min(rideScore, 58);

                features.ride_score.push(rideScore);
                features.ride_wetness.push(wetness);
                features.ride_wind_risk.push(windRisk);
                features.ride_temp_risk.push(tempRisk);
                features.ride_light_risk.push(darkRisk);
                features.ride_precip_risk.push(precipRisk);
                features.ride_ice_risk.push(iceRisk);
                features.ride_feels_like.push(feelsLike);
                features.ride_precip_6h.push(precip6 ?? null);

                features.debug_flags.push(flags);
            }

            features.snow_24h_cm = rollingSum(features.snow_proxy_cm, 24);
            features.snow_48h_cm = rollingSum(features.snow_proxy_cm, 48);
            const windLoading = new Array(n).fill(null);
            const tourScore = new Array(n).fill(null);
            const avalancheProxy = new Array(n).fill(null);
            for (let i = 0; i < n; i += 1) {
                const windRef = features.wind_ridge[i] ?? features.wind_takeoff[i];
                const snow24 = features.snow_24h_cm[i];
                const windLoad = windRef !== null && windRef !== undefined && snow24 !== null && snow24 !== undefined
                    ? clamp((windRef - 6) / 8, 0, 1) * clamp(snow24 / 15, 0, 1)
                    : null;
                windLoading[i] = windLoad;

                const wet = features.wet_snow_risk[i];
                const vis = features.visibility_risk[i];
                const comfortWind = windRef !== null && windRef !== undefined ? clamp((windRef - 5) / 10, 0, 1) : 0.2;
                const score = 100 * clamp(1 - (0.45 * (vis ?? 0) + 0.3 * (wet ?? 0) + 0.25 * comfortWind), 0, 1);
                tourScore[i] = score;

                const snowFactor = snow24 !== null && snow24 !== undefined ? clamp(snow24 / 20, 0, 1) : null;
                let hazard = null;
                let weightSum = 0;
                let sum = 0;
                if (windLoad !== null && windLoad !== undefined) {
                    sum += 0.45 * windLoad;
                    weightSum += 0.45;
                }
                if (wet !== null && wet !== undefined) {
                    sum += 0.35 * wet;
                    weightSum += 0.35;
                }
                if (snowFactor !== null && snowFactor !== undefined) {
                    sum += 0.2 * snowFactor;
                    weightSum += 0.2;
                }
                if (weightSum > 0) {
                    hazard = clamp(sum / weightSum, 0, 1);
                }
                avalancheProxy[i] = hazard;
            }
            features.wind_loading_risk = windLoading;
            features.tour_score = tourScore;
            features.avalanche_proxy = avalancheProxy;

            for (const key of Object.keys(windLayers)) {
                const speeds = windLayers[key].speed;
                if (!Array.isArray(speeds) || speeds.every((v) => v === null || v === undefined)) {
                    delete windLayers[key];
                }
            }
            features.wind_layers = windLayers;

            const bestWindow = findBestWindow(series.labels, features.flyability_prob, features.safety_score, features.utility, features.debug_flags);
            features.best_window = bestWindow;
            features.ride_window = findBestRideWindow(
                series.labels,
                features.ride_score,
                features.ride_wetness,
                features.ride_wind_risk,
                features.ride_precip_risk,
                series.precip_mm,
                features.debug_flags
            );

            return features;
        }

        function findBestWindow(labels, flyability, safety, utility, flags) {
            if (!labels || !labels.length) return null;
            let best = null;
            let start = null;
            for (let i = 0; i < labels.length; i += 1) {
                const ok = (flyability[i] ?? 0) >= 0.7 && (safety[i] ?? 0) >= 0.8;
                if (ok && start === null) start = i;
                if ((!ok || i === labels.length - 1) && start !== null) {
                    const end = ok && i === labels.length - 1 ? i : i - 1;
                    let peakIdx = start;
                    let peakVal = utility[start] ?? -999;
                    for (let j = start; j <= end; j += 1) {
                        if ((utility[j] ?? -999) > peakVal) {
                            peakVal = utility[j] ?? -999;
                            peakIdx = j;
                        }
                    }
                    const length = end - start + 1;
                    if (!best || peakVal > best.peakVal || (peakVal === best.peakVal && length > best.length)) {
                        best = { startIdx: start, endIdx: end, peakIdx, peakVal, length };
                    }
                    start = null;
                }
            }
            if (!best) {
                let peakIdx = 0;
                let peakVal = utility[0] ?? -999;
                for (let i = 1; i < labels.length; i += 1) {
                    if ((utility[i] ?? -999) > peakVal) {
                        peakVal = utility[i] ?? -999;
                        peakIdx = i;
                    }
                }
                const uncertaintyMin = flags && flags[peakIdx] && flags[peakIdx].length ? 30 : 20;
                return { startIdx: peakIdx, endIdx: peakIdx, peakIdx, uncertaintyMin };
            }
            const uncertaintyMin = flags && flags[best.peakIdx] && flags[best.peakIdx].length ? 30 : 15;
            return { startIdx: best.startIdx, endIdx: best.endIdx, peakIdx: best.peakIdx, uncertaintyMin };
        }

        function findBestRideWindow(labels, score, wetness, windRisk, precipRisk, precipMm, flags) {
            if (!labels || !labels.length) return null;
            const DAY_START = 8;
            const DAY_END = 19;
            const MIN_RIDE_HOURS = 2;
            const isDayHour = (label) => {
                const dt = parseLocal(label);
                if (!dt) return false;
                const h = dt.getHours();
                return h >= DAY_START && h <= DAY_END;
            };
            const isDryHour = (idx) => {
                const wet = wetness?.[idx];
                const pr = precipRisk?.[idx];
                const p = precipMm?.[idx];
                if (wet !== null && wet !== undefined && wet > 0.45) return false;
                if (pr !== null && pr !== undefined && pr > 0.4) return false;
                if (p !== null && p !== undefined && p > 0.1) return false;
                return true;
            };
            const canRideTwoHours = (idx) => {
                for (let k = 0; k < MIN_RIDE_HOURS; k += 1) {
                    const j = idx + k;
                    if (j >= labels.length) return false;
                    if (!isDayHour(labels[j])) return false;
                    if (!isDryHour(j)) return false;
                    if (windRisk?.[j] !== null && windRisk?.[j] !== undefined && windRisk[j] > 0.7) return false;
                }
                return true;
            };
            let best = null;
            let start = null;
            for (let i = 0; i < labels.length; i += 1) {
                const ok = canRideTwoHours(i) && (score[i] ?? 0) >= 70 && (wetness[i] ?? 1) <= 0.55 && (windRisk[i] ?? 0) <= 0.65;
                if (ok && start === null) start = i;
                if ((!ok || i === labels.length - 1) && start !== null) {
                    const end = ok && i === labels.length - 1 ? i : i - 1;
                    let peakIdx = start;
                    let peakVal = score[start] ?? -999;
                    for (let j = start; j <= end; j += 1) {
                        if ((score[j] ?? -999) > peakVal) {
                            peakVal = score[j] ?? -999;
                            peakIdx = j;
                        }
                    }
                    const length = end - start + 1;
                    if (!best || peakVal > best.peakVal || (peakVal === best.peakVal && length > best.length)) {
                        best = { startIdx: start, endIdx: end, peakIdx, peakVal, length };
                    }
                    start = null;
                }
            }
            if (!best) {
                let peakIdx = null;
                let peakVal = -Infinity;
                for (let i = 0; i < labels.length; i += 1) {
                    if (!canRideTwoHours(i)) continue;
                    const val = score[i] ?? -999;
                    if (val > peakVal) {
                        peakVal = val;
                        peakIdx = i;
                    }
                }
                if (peakIdx === null) return null;
                const uncertaintyMin = flags && flags[peakIdx] && flags[peakIdx].length ? 40 : 25;
                return { startIdx: peakIdx, endIdx: peakIdx, peakIdx, uncertaintyMin };
            }
            const uncertaintyMin = flags && flags[best.peakIdx] && flags[best.peakIdx].length ? 40 : 20;
            return { startIdx: best.startIdx, endIdx: best.endIdx, peakIdx: best.peakIdx, uncertaintyMin };
        }

        function buildReasons(site, features, series, idx) {
            const reasons = [];
            const maxWindKmh = toKmh(site.limits.max_wind);
            const maxGustKmh = toKmh(site.limits.max_gust);
            const maxTailKmh = toKmh(site.limits.max_tailwind);
            const maxCrossKmh = toKmh(site.limits.max_crosswind);
            const wind = features.wind_takeoff[idx];
            if (wind !== null && wind > site.limits.max_wind) {
                reasons.push({ text: `Wind am Start > ${formatValue(maxWindKmh, "km/h", 0)}`, score: 3 });
            }
            const gust = features.gust[idx];
            if (gust !== null && gust > site.limits.max_gust) {
                reasons.push({ text: `B\u00f6en > ${formatValue(maxGustKmh, "km/h", 0)}`, score: 3 });
            }
            const tail = features.tailwind[idx];
            if (tail !== null && tail > site.limits.max_tailwind) {
                reasons.push({ text: `R\u00fcckenwind > ${formatValue(maxTailKmh, "km/h", 0)}`, score: 2 });
            }
            const cross = features.crosswind[idx];
            if (cross !== null && cross > site.limits.max_crosswind) {
                reasons.push({ text: `Querwind > ${formatValue(maxCrossKmh, "km/h", 0)}`, score: 2 });
            }
            const conv = features.convection_risk[idx];
            if (conv !== null && conv > 0.6) {
                reasons.push({ text: "Konvektion/OD Risiko hoch", score: 2 });
            }
            const warnLevel = features.warning_level ? features.warning_level[idx] : 0;
            if (warnLevel >= 2) {
                reasons.push({ text: `Warnstufe ${warnLevel}`, score: 3 });
            }
            const inv = features.inversion_base_agl[idx];
            if (inv !== null && inv < 800) {
                reasons.push({ text: `Inversion tief (${Math.round(inv)} m AGL)`, score: 1 });
            }
            const therm = features.thermal_maturity[idx];
            if (therm !== null && therm < 0.35) {
                reasons.push({ text: "Thermik schwach", score: 1 });
            }
            if (!reasons.length && therm !== null && therm > 0.7) {
                reasons.push({ text: "Thermik stark", score: 1 });
            }
            if (!reasons.length && wind !== null && wind < site.limits.max_wind * 0.6) {
                reasons.push({ text: "Wind am Start ruhig", score: 1 });
            }
            return reasons
                .sort((a, b) => (b.score || 0) - (a.score || 0))
                .slice(0, 3)
                .map((r) => r.text);
        }

        function updateHero(payload) {
            if (!payload) return;
            const { site, series, features, window } = payload;
            const labelsIso = series.labels_iso || series.labels;
            const idx = pickCurrentIndex(labelsIso);

            if (heroTitle) {
                const name = site.name || "Wetterkarte";
                const hint = site?.device_hint;
                if (hint && normalizeSiteName(name).startsWith("aktueller standort")) {
                    heroTitle.textContent = `${name} - ${hint}`;
                } else {
                    heroTitle.textContent = name;
                }
            }
            if (heroSubtitle) {
                const coords = `${site.lat.toFixed(4)}, ${site.lon.toFixed(4)} | Höhe ${Math.round(site.elevation_m)} m`;
                const windowText = window ? `${window.start} bis ${window.end} (${window.tz || "lokal"})` : "";
                heroSubtitle.textContent = windowText ? `${coords} | ${windowText}` : coords;
            }
            document.title = `ALPENWETTER LAB - ${site.name}`;

            const tRange = minMax(series.t2m_C);
            setText("heroTemp", formatValue(series.t2m_C[idx], "C"));
            setText("heroTempRange", `Spanne ${formatValue(tRange.min, "C")} - ${formatValue(tRange.max, "C")}`);

            const windSpeed = series.wind10_speed_ms?.[idx] ?? features.wind_takeoff?.[idx];
            const windDir = series.wind10_dir_deg?.[idx] ?? features.wind_takeoff_dir?.[idx];
            setText("heroWind", `${formatValue(toKmh(windSpeed), "km/h", 0)} | ${toCompass(windDir)}`);
            const windP10 = series.wind10_p10?.[idx];
            const windP90 = series.wind10_p90?.[idx];
            setText("heroWindRange", windSpanTextKmh(windSpeed, windP10, windP90));

            const fly = features.flyability_prob?.[idx];
            const flyScore = fly !== null && fly !== undefined ? Math.round(fly * 100) : null;
            setText("heroHammer", flyScore !== null ? `${flyScore}/100` : "-");
            const therm = features.thermal_maturity?.[idx];
            const thermScore = therm !== null && therm !== undefined ? `${Math.round(therm * 10)}/10` : "-";
            setText("heroHammerHint", flyScore !== null ? `${scoreLabel(flyScore)} | Thermik ${thermScore}` : "-");
            applyScoreClass("heroHammer", flyScore);

            const rideScore = features.ride_score?.[idx];
            const rideScoreInt = rideScore !== null && rideScore !== undefined ? Math.round(rideScore) : null;
            setText("heroRide", rideScoreInt !== null ? `${rideScoreInt}/100` : "-");
            setText("heroRideHint", rideScoreInt !== null ? scoreLabel(rideScoreInt) : "-");
            applyScoreClass("heroRide", rideScoreInt);
        }

        function renderOverview(payload) {
            if (!payload) return;
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels;
            const idx = pickCurrentIndex(labelsIso);
            const grid = document.getElementById("overviewGrid");
            if (!grid) return;

            const precipNow = series.precip_mm?.[idx] ?? 0;
            const precipNext6 = (series.precip_mm || []).slice(idx, idx + 6).reduce((acc, v) => acc + (v || 0), 0);
            const wetNow = features.ride_wetness?.[idx];
            const sunNow = series.sunshine_s?.[idx] !== null && series.sunshine_s?.[idx] !== undefined ? (series.sunshine_s[idx] / 3600) : null;
            const sunNext24 = (series.sunshine_s || []).slice(idx, idx + 24).reduce((acc, v) => acc + (v || 0), 0) / 3600;
            const cloudNow = series.cloud_total_pct?.[idx];
            const visRisk = features.visibility_risk?.[idx];
            const convRisk = features.convection_risk?.[idx];
            const windOverProb = features.wind_over_prob?.[idx];
            const gustOverProb = features.gust_over_prob?.[idx];
            const zeroAsl = features.freezing_level_asl?.[idx];
            const wetSnowRisk = features.wet_snow_risk?.[idx];

            const riskPercent = (value) => (
                value === null || value === undefined || Number.isNaN(value)
                    ? "-"
                    : `${Math.round(value * 100)}%`
            );

            const items = [
                {
                    title: "Niederschlag & N\u00e4sse",
                    value: `${formatValue(precipNow, "mm")} jetzt`,
                    sub: `N\u00e4chste 6h ${formatValue(precipNext6, "mm")} | N\u00e4sse ${riskPercent(wetNow)}`,
                },
                {
                    title: "Sonne & Wolken",
                    value: `Sonne ${formatValue(sunNow, "h", 1)}`,
                    sub: `Wolken ${formatPercent(cloudNow, 0)} | 24h Sonne ${formatValue(sunNext24, "h", 1)}`,
                },
                {
                    title: "Risiken jetzt",
                    value: `Gewitter ${riskPercent(convRisk)} | Sicht ${riskPercent(visRisk)}`,
                    sub: `Windlimit ${riskPercent(windOverProb)} | B\u00f6enlimit ${riskPercent(gustOverProb)}`,
                },
                {
                    title: "Nullgrad & Nassschnee",
                    value: zeroAsl !== null && zeroAsl !== undefined ? `${Math.round(zeroAsl)} m` : "-",
                    sub: `Nassschnee-Risiko ${riskPercent(wetSnowRisk)}`,
                },
            ];

            grid.innerHTML = "";
            items.forEach((item) => {
                const card = document.createElement("div");
                card.className = "card";
                const h3 = document.createElement("h3");
                h3.textContent = item.title;
                const val = document.createElement("div");
                val.className = "value";
                val.textContent = item.value ?? "-";
                const sub = document.createElement("div");
                sub.className = "subvalue";
                sub.textContent = item.sub ?? "-";
                card.appendChild(h3);
                card.appendChild(val);
                card.appendChild(sub);
                grid.appendChild(card);
                if (item.scoreValue !== undefined) {
                    applyScoreClass(val, item.scoreValue);
                }
            });

            const dayIndices = [];
            (labelsIso || []).forEach((iso, i) => {
                const dt = parseLocal(iso || (series.labels ? series.labels[i] : null));
                if (!dt || Number.isNaN(dt.getTime())) return;
                const hour = dt.getHours();
                if (hour >= 8 && hour <= 19) dayIndices.push(i);
            });
            const indices = dayIndices.length ? dayIndices : (labelsIso || []).map((_, i) => i);

            let bestFlightIdx = null;
            let bestFlightVal = -Infinity;
            indices.forEach((i) => {
                const val = features.flyability_prob ? features.flyability_prob[i] : null;
                if (val === null || val === undefined || Number.isNaN(val)) return;
                if (val > bestFlightVal) {
                    bestFlightVal = val;
                    bestFlightIdx = i;
                }
            });
            if (bestFlightIdx !== null) {
                const label = series.labels?.[bestFlightIdx] || formatLabel(labelsIso?.[bestFlightIdx]);
                setText("bestFlight", label || "-");
                const score = Math.round(bestFlightVal * 100);
                setText("bestFlightHint", `Flugscore ${score}/100 (${scoreLabel(score)})`);
            } else {
                setText("bestFlight", "-");
                setText("bestFlightHint", "-");
            }

            let bestBeautyIdx = null;
            let bestBeautyVal = -Infinity;
            indices.forEach((i) => {
                const sun = series.sunshine_s?.[i];
                const cloud = series.cloud_total_pct?.[i];
                const precip = series.precip_mm?.[i];
                const sunScore = sun !== null && sun !== undefined ? clamp(sun / 3600, 0, 1) : 0.2;
                const cloudScore = cloud !== null && cloud !== undefined ? 1 - clamp(cloud / 100, 0, 1) : 0.5;
                const precipScore = precip !== null && precip !== undefined ? 1 - clamp(precip / 1.5, 0, 1) : 0.7;
                const score = 0.5 * sunScore + 0.35 * cloudScore + 0.15 * precipScore;
                if (score > bestBeautyVal) {
                    bestBeautyVal = score;
                    bestBeautyIdx = i;
                }
            });
            if (bestBeautyIdx !== null) {
                const label = series.labels?.[bestBeautyIdx] || formatLabel(labelsIso?.[bestBeautyIdx]);
                setText("bestBeauty", label || "-");
                const cloud = series.cloud_total_pct?.[bestBeautyIdx];
                const sunH = series.sunshine_s?.[bestBeautyIdx] ? series.sunshine_s[bestBeautyIdx] / 3600 : null;
                setText(
                    "bestBeautyHint",
                    `Sonne ${sunH !== null ? formatValue(sunH, "h", 1) : "-"} | Wolken ${formatPercent(cloud, 0)}`
                );
            } else {
                setText("bestBeauty", "-");
                setText("bestBeautyHint", "-");
            }

            let bestRideIdx = null;
            let bestRideVal = -Infinity;
            indices.forEach((i) => {
                const val = features.ride_score ? features.ride_score[i] : null;
                if (val === null || val === undefined || Number.isNaN(val)) return;
                if (val > bestRideVal) {
                    bestRideVal = val;
                    bestRideIdx = i;
                }
            });
            if (bestRideIdx !== null) {
                const label = series.labels?.[bestRideIdx] || formatLabel(labelsIso?.[bestRideIdx]);
                setText("bestRide", label || "-");
                setText("bestRideHint", `Score ${Math.round(bestRideVal)}/100`);
            } else {
                setText("bestRide", "-");
                setText("bestRideHint", "-");
            }
        }

        function updateParagliding(payload) {
            if (!payload) return;
            const { site, series, features, missing } = payload;
            const labelsIso = series.labels_iso || series.labels;
            let idx = pickCurrentIndex(labelsIso);
            if (currentParaDay && currentParaDay !== "all") {
                const bestIdx = pickBestIndexForDay(labelsIso, currentParaDay, features.flyability_prob || features.thermal_maturity);
                if (bestIdx !== null && bestIdx !== undefined) idx = bestIdx;
            }

            const tRange = minMax(series.t2m_C);
            setText("tempValue", formatValue(series.t2m_C[idx], "C"));
            setText("tempRange", `Spanne: ${formatValue(tRange.min, "C")} - ${formatValue(tRange.max, "C")}`);

            const height = "10";
            const windLayer = features.wind_layers && features.wind_layers[height] ? features.wind_layers[height] : null;
            const windSpeed = windLayer ? windLayer.speed[idx] : features.wind_takeoff[idx];
            const windDir = windLayer ? windLayer.direction[idx] : features.wind_takeoff_dir[idx];
            setText("windValue", `${formatValue(toKmh(windSpeed), "km/h", 0)} | ${toCompass(windDir)}`);
            setText("windHeight", `Höhe: ${height} m`);
            const windP10 = windLayer ? null : features.wind_takeoff_p10?.[idx];
            const windP90 = windLayer ? null : features.wind_takeoff_p90?.[idx];
            setText("windRange", windSpanTextKmh(windSpeed, windP10, windP90));

            const baseTemp = series.t2m_C[idx];
            const fixedWindKmh = 40;
            const chillPara = windChillC(baseTemp, fixedWindKmh);
            setText("paraWindChillValue", chillPara !== null && chillPara !== undefined ? `${formatValue(chillPara, "C", 1)}` : "-");
            setText("paraWindChillHint", `Windchill @ ${fixedWindKmh} km/h | T ${formatValue(baseTemp, "C")}`);

            setText("cloudValue", formatPercent(series.cloud_total_pct[idx], 0));

            const precipNow = series.precip_mm[idx] ?? 0;
            const precipSum = (series.precip_mm || []).reduce((acc, v) => acc + (v || 0), 0);
            setText("precipValue", formatValue(precipNow, "mm"));
            setText("precipSum", `48h Summe: ${formatValue(precipSum, "mm")}`);

            setText("rhValue", formatPercent(series.rh2m_pct[idx], 0));

            const sunNow = series.sunshine_s[idx] !== null && series.sunshine_s[idx] !== undefined ? series.sunshine_s[idx] / 3600 : null;
            const sunSum = (series.sunshine_s || []).reduce((acc, v) => acc + (v || 0), 0) / 3600;
            setText("sunValue", sunNow !== null ? formatValue(sunNow, "h", 2) : "-");
            setText("sunSum", `48h Summe: ${formatValue(sunSum, "h", 1)}`);

            const therm = features.thermal_maturity[idx];
            const climbP50 = features.climb_p50 ? features.climb_p50[idx] : null;
            const climbP10 = features.climb_p10 ? features.climb_p10[idx] : null;
            const climbP90 = features.climb_p90 ? features.climb_p90[idx] : null;
            setText(
                "thermikIndex",
                climbP50 !== null && climbP50 !== undefined
                    ? `${formatValue(climbP50, "m/s", 1)}`
                    : (therm !== null && therm !== undefined ? `${Math.round(therm * 10)}/10` : "-")
            );
            const climbRange = climbP10 !== null && climbP90 !== null && climbP10 !== undefined && climbP90 !== undefined
                ? `Steigen ${formatValue(climbP10, "m/s", 1)}-${formatValue(climbP90, "m/s", 1)}`
                : "Steigen -";
            const indexText = therm !== null && therm !== undefined ? `Index ${Math.round(therm * 10)}/10` : "Index -";
            setText(
                "thermikHint",
                `${climbRange} | ${indexText} | Sonne ${formatValue(sunNow, "h", 1)} | Wolken ${formatPercent(series.cloud_total_pct[idx], 0)}`
            );

            const hammer = features.flyability_prob[idx];
            const hammerScore = hammer !== null && hammer !== undefined ? Math.round(hammer * 100) : null;
            setText("hammerScore", hammerScore !== null ? `${hammerScore}/100` : "-");
            applyScoreClass("hammerScore", hammerScore);
            const tempAvg = avg(series.t2m_C);
            setText(
                "hammerHint",
                hammerScore !== null ? `${scoreLabel(hammerScore)} | Regen ${formatValue(precipNow, "mm")} | Temp ${formatValue(tempAvg, "C")}` : "-"
            );
            const hammerReasons = [];
            const gustNow = series.wind_gusts_ms?.[idx] ?? features.gust?.[idx];
            const convRiskNow = features.convection_risk?.[idx];
            const visRiskNow = features.visibility_risk?.[idx];
            if (windSpeed !== null && windSpeed !== undefined && windSpeed > site.limits.max_wind) hammerReasons.push("Wind über Startlimit");
            if (gustNow !== null && gustNow !== undefined && gustNow > site.limits.max_gust) hammerReasons.push("Böen hoch");
            if (convRiskNow !== null && convRiskNow !== undefined && convRiskNow > 0.6) hammerReasons.push("Konvektion erhöht");
            if (visRiskNow !== null && visRiskNow !== undefined && visRiskNow > 0.55) hammerReasons.push("Sicht eingeschränkt");
            if (therm !== null && therm !== undefined && therm < 0.35) hammerReasons.push("Thermik schwach");
            if (sunNow !== null && sunNow !== undefined && sunNow <= 0.2) hammerReasons.push("Wenig Sonne");
            setText("hammerReasons", hammerReasons.length ? hammerReasons.join(" | ") : "Treiber ausgeglichen");

            if (missing && missing.profile) {
                setText("profileStability", "Profil n/a");
                setText("profileLapse", "Pressure-Levels fehlen");
                setText("profileInversion", "-");
            } else {
                const lapse = features.lapse_rate_low[idx];
                const tag = features.stability_tag[idx];
                const tagText = tag ? tag.charAt(0).toUpperCase() + tag.slice(1) : "-";
                const invBase = features.inversion_base_agl[idx];
                const rhNow = series.rh2m_pct[idx];
                const lowCloudNow = series.cloud_low_pct ? series.cloud_low_pct[idx] : null;
                const isMoist = (rhNow !== null && rhNow !== undefined && rhNow >= 80) || (lowCloudNow !== null && lowCloudNow !== undefined && lowCloudNow >= 60);
                const moistureLabel = isMoist ? "feucht" : "trocken";
                const steepThreshold = isMoist ? 0.6 : 0.8;
                const gradientClass = lapse !== null && lapse !== undefined
                    ? (lapse <= -steepThreshold ? "steil" : (lapse <= -0.4 ? "moderat" : "flach"))
                    : "n/a";

                let stabilityNote = tagText;
                if (tag === "labil") {
                    stabilityNote = `Labil (${gradientClass}, ${moistureLabel})`;
                } else if (tag === "stabil") {
                    if (invBase !== null && invBase !== undefined) {
                        stabilityNote = `Stabil (Inversion ab ${Math.round(invBase)} m AGL)`;
                    } else {
                        stabilityNote = `Stabil (${gradientClass}, ${moistureLabel})`;
                    }
                }
                setText("profileStability", stabilityNote);
                setText(
                    "profileLapse",
                    lapse !== null && lapse !== undefined
                        ? `Lapse ${lapse.toFixed(2)} °C/100 m (0-1500 m AGL) | steil ab ${steepThreshold.toFixed(2)} (${moistureLabel})`
                        : "Lapse n/a"
                );
                if (invBase !== null && invBase !== undefined) {
                    const strength = features.inversion_strength[idx];
                    setText("profileInversion", `Inversion: ja | Basis ${Math.round(invBase)} m | dT ${formatValue(strength, "C")}`);
                } else {
                    setText("profileInversion", "Inversion: nein");
                }
            }

            if (missing && missing.wind) {
                setText("windProfile", "nur 10 m verfügbar");
                setText("windShear", "-");
            } else {
                const formatWindKmh = (speedMs) => {
                    if (speedMs === null || speedMs === undefined || Number.isNaN(speedMs)) return "-";
                    return String(Math.round(toKmh(speedMs)));
                };
                const siteElev = site && site.elevation_m !== null && site.elevation_m !== undefined ? site.elevation_m : null;
                const labelForAlt = (agl) => (
                    siteElev !== null
                        ? `${Math.round(siteElev + agl)} m ASL`
                        : `${agl}m AGL`
                );
                const startW = formatWindKmh(features.wind_takeoff[idx]);
                const ridgeW = formatWindKmh(features.wind_ridge[idx]);
                const workW = formatWindKmh(features.wind_work[idx]);
                setHTML(
                    "windProfile",
                    `${labelForAlt(100)}: ${startW} km/h<br>${labelForAlt(600)}: ${ridgeW} km/h<br>${labelForAlt(1500)}: ${workW} km/h`
                );
                const startMs = features.wind_takeoff[idx];
                const workMs = features.wind_work[idx];
                const dirChange = features.wind_dir_change[idx];
                const deltaKmh = startMs !== null && startMs !== undefined && !Number.isNaN(startMs)
                    && workMs !== null && workMs !== undefined && !Number.isNaN(workMs)
                    ? Math.abs(toKmh(workMs - startMs))
                    : null;
                setText(
                    "windShear",
                    deltaKmh !== null
                        ? `\u0394V Start\u2192Arbeit ${formatValue(deltaKmh, "km/h", 0)} | Drehung ${formatValue(dirChange, "\u00b0", 0)}`
                        : (dirChange !== null && dirChange !== undefined && !Number.isNaN(dirChange)
                            ? `Drehung ${formatValue(dirChange, "\u00b0", 0)}`
                            : "-")
                );
            }

            const best = features.best_window;
            const reasonsEl = document.getElementById("startWindowReasons");
            if (!best) {
                setText("startWindowValue", "-");
                setText("startWindowPeak", "-");
                setText("startWindowArrive", "-");
                setText("startWindowUncertainty", "-");
                if (reasonsEl) reasonsEl.innerHTML = "";
            } else {
                const startLabel = series.labels[best.startIdx];
                const endLabel = series.labels[best.endIdx];
                const peakLabel = series.labels[best.peakIdx];
                const singleSlot = startLabel === endLabel;
                setText("startWindowValue", singleSlot ? `${startLabel}` : `${startLabel} - ${endLabel}`);
                setText("startWindowPeak", peakLabel !== startLabel ? `Peak: ${peakLabel}` : "Peak: im Zeitfenster");

                const peakIso = series.labels_iso ? series.labels_iso[best.peakIdx] : peakLabel;
                const peakDt = parseLocal(peakIso || peakLabel);
                const totalMin = (site.timing?.approach_min || 0) + (site.timing?.setup_min || 0) + (site.timing?.buffer_min || 0);
                const arriveDt = peakDt ? new Date(peakDt.getTime() - totalMin * 60000) : null;
                setText("startWindowArrive", arriveDt ? `Ankunft: ${formatDate(arriveDt)}` : "-");
                setText("startWindowUncertainty", `Unsicherheit \u00b1${best.uncertaintyMin} min`);

                const reasons = buildReasons(site, features, series, best.peakIdx);
                if (reasonsEl) {
                    reasonsEl.innerHTML = "";
                    if (!reasons.length) {
                        const li = document.createElement("li");
                        li.textContent = "Keine kritischen Treiber";
                        reasonsEl.appendChild(li);
                    } else {
                        reasons.forEach((text) => {
                            const li = document.createElement("li");
                            li.textContent = text;
                            reasonsEl.appendChild(li);
                        });
                    }
                }
            }
        }

        function updateTourDaySelect(labelsIso) {
            if (!tourDaySelect) return;
            const options = getDayOptions(labelsIso);
            tourDaySelect.innerHTML = "";
            const allOpt = document.createElement("option");
            allOpt.value = "all";
            allOpt.textContent = "Alle Tage";
            tourDaySelect.appendChild(allOpt);
            options.forEach((opt) => {
                const el = document.createElement("option");
                el.value = opt.key;
                el.textContent = opt.label;
                tourDaySelect.appendChild(el);
            });
            if (!options.find((opt) => opt.key === currentTourDay)) {
                currentTourDay = "all";
            }
            tourDaySelect.value = currentTourDay;
        }

        function fillDaySelect(selectEl, options, currentValue) {
            if (!selectEl) return;
            selectEl.innerHTML = "";
            const allOpt = document.createElement("option");
            allOpt.value = "all";
            allOpt.textContent = "Alle Tage";
            selectEl.appendChild(allOpt);
            options.forEach((opt) => {
                const el = document.createElement("option");
                el.value = opt.key;
                el.textContent = opt.label;
                selectEl.appendChild(el);
            });
            selectEl.value = currentValue;
        }

        function updateParaDaySelect(labelsIso) {
            const options = getDayOptions(labelsIso);
            if (!options.find((opt) => opt.key === currentParaDay)) {
                currentParaDay = "all";
            }
            fillDaySelect(paraDaySelect, options, currentParaDay);
        }

        function updateRideDaySelect(labelsIso) {
            if (!rideDaySelect) return;
            const options = getDayOptions(labelsIso);
            if (!options.find((opt) => opt.key === currentRideDay)) {
                currentRideDay = "all";
            }
            fillDaySelect(rideDaySelect, options, currentRideDay);
        }

        function updateXcDaySelect(labelsIso) {
            if (!xcDaySelect) return;
            const options = getDayOptions(labelsIso);
            if (!options.find((opt) => opt.key === currentXcDay)) {
                currentXcDay = "all";
            }
            fillDaySelect(xcDaySelect, options, currentXcDay);
        }

        function updateSkitour(payload) {
            if (!payload) return;
            const { series, features, site } = payload;
            const labelsIso = series.labels_iso || series.labels;
            updateTourDaySelect(labelsIso);
            let idx = pickCurrentIndex(labelsIso);
            if (currentTourDay && currentTourDay !== "all") {
                const bestIdx = pickBestIndexForDay(labelsIso, currentTourDay, features.tour_score);
                if (bestIdx !== null && bestIdx !== undefined) idx = bestIdx;
            }

            const bulletin = payload.avalanche;
            const levelInfo = getDangerLevelForSite(bulletin, site);
            const bandLevels = getDangerLevelsByBand(bulletin, site);
            const bulletinLevel = levelInfo.level;
            const maxBulletinLevel = levelInfo.maxLevel;
            const levelBelow = bandLevels?.below ?? null;
            const levelAbove = bandLevels?.above ?? null;
            const bulletinRiskBelow = levelBelow ? clamp((levelBelow - 1) / 4, 0, 1) : null;
            const bulletinRiskAbove = levelAbove ? clamp((levelAbove - 1) / 4, 0, 1) : null;

            const score = features.tour_score[idx];
            const hazardProxy = features.avalanche_proxy[idx];
            const hazardCombinedBelow = bulletinRiskBelow !== null
                ? Math.max(bulletinRiskBelow, hazardProxy ?? 0)
                : hazardProxy;
            const hazardCombinedAbove = bulletinRiskAbove !== null
                ? Math.max(bulletinRiskAbove, hazardProxy ?? 0)
                : hazardProxy;
            const scoreAdjBelow = score !== null && score !== undefined && levelBelow
                ? clamp(score - levelBelow * 15, 0, 100)
                : null;
            const scoreAdjAbove = score !== null && score !== undefined && levelAbove
                ? clamp(score - levelAbove * 15, 0, 100)
                : null;
            let scoreMain = scoreAdjAbove ?? scoreAdjBelow ?? score;
            if (scoreAdjBelow !== null || scoreAdjAbove !== null) {
                const scores = [scoreAdjBelow, scoreAdjAbove].filter((v) => v !== null && v !== undefined);
                if (scores.length) scoreMain = Math.min(...scores);
            }

            setText("tourScoreValue", scoreMain !== null && scoreMain !== undefined ? `${Math.round(scoreMain)}/100` : "-");
            setText("tourScoreHint", scoreMain !== null && scoreMain !== undefined ? scoreLabel(scoreMain) : "-");
            applyScoreClass("tourScoreValue", scoreMain);
            if (levelBelow || levelAbove) {
                const belowText = scoreAdjBelow !== null && scoreAdjBelow !== undefined ? `${Math.round(scoreAdjBelow)}/100` : "-";
                const aboveText = scoreAdjAbove !== null && scoreAdjAbove !== undefined ? `${Math.round(scoreAdjAbove)}/100` : "-";
                setText("tourScoreBand", `Unter Waldgrenze ${belowText} · Ober Waldgrenze ${aboveText}`);
            } else {
                setText("tourScoreBand", "-");
            }
            if (levelBelow || levelAbove) {
                const belowHaz = hazardCombinedBelow !== null && hazardCombinedBelow !== undefined ? `${Math.round(hazardCombinedBelow * 100)}%` : "n/a";
                const aboveHaz = hazardCombinedAbove !== null && hazardCombinedAbove !== undefined ? `${Math.round(hazardCombinedAbove * 100)}%` : "n/a";
                const proxyNote = hazardProxy !== null && hazardProxy !== undefined
                    ? ` | Meteo-Proxy ${Math.round(hazardProxy * 100)}%`
                    : "";
                const belowLevelText = levelBelow ? `L${levelBelow}` : "L-";
                const aboveLevelText = levelAbove ? `L${levelAbove}` : "L-";
                setText("tourHazardValue", `Gefahr unter ${belowLevelText} ~ ${belowHaz} · ober ${aboveLevelText} ~ ${aboveHaz}${proxyNote}`);
            } else if (bulletinLevel) {
                const hazardText = hazardCombinedAbove !== null && hazardCombinedAbove !== undefined ? `${Math.round(hazardCombinedAbove * 100)}%` : "n/a";
                const proxyNote = hazardProxy !== null && hazardProxy !== undefined
                    ? ` | Meteo-Proxy ${Math.round(hazardProxy * 100)}%`
                    : "";
                setText("tourHazardValue", `Gefahr L${bulletinLevel} ~ ${hazardText}${proxyNote}`);
            } else {
                setText(
                    "tourHazardValue",
                    hazardCombinedAbove !== null && hazardCombinedAbove !== undefined
                        ? `Gefahr ${Math.round(hazardCombinedAbove * 100)}% (Proxy)`
                        : "Gefahr -"
                );
            }

            const reasons = [];
            const worstLevel = Math.max(levelBelow ?? 0, levelAbove ?? 0, bulletinLevel ?? 0);
            if (worstLevel >= 3) reasons.push(`Lawinenstufe ${worstLevel}`);
            if (features.wind_loading_risk[idx] !== null && features.wind_loading_risk[idx] > 0.55) reasons.push("Windverfrachtung hoch");
            if (features.wet_snow_risk[idx] !== null && features.wet_snow_risk[idx] > 0.55) reasons.push("Nassschnee Risiko");
            if (features.visibility_risk[idx] !== null && features.visibility_risk[idx] > 0.55) reasons.push("Sicht eingeschr\u00e4nkt");
            setText("tourScoreReasons", reasons.length ? reasons.join(" | ") : "Lage stabil");

            const snow24 = features.snow_24h_cm[idx];
            const snowRate = features.snow_proxy_cm[idx];
            setText("snow24Value", snow24 !== null && snow24 !== undefined ? `${formatValue(snow24, "cm", 1)} / 24h` : "-");
            setText("snowRateValue", snowRate !== null && snowRate !== undefined ? `Stunde ~${formatValue(snowRate, "cm", 1)} (Proxy)` : "Stunde -");

            const windLoad = features.wind_loading_risk[idx];
            const windRef = features.wind_ridge[idx] ?? features.wind_takeoff[idx];
            setText("windLoadValue", windLoad !== null && windLoad !== undefined ? `${Math.round(windLoad * 100)}%` : "-");
            setText("windLoadHint", `Wind ${formatValue(toKmh(windRef), "km/h", 0)} | Proxy`);
            const wet = features.wet_snow_risk[idx];
            const temp = series.t2m_C[idx];
            const precipNow = series.precip_mm[idx];
            const windChillSpeed = features.wind_takeoff[idx] ?? windRef;
            const windChillKmh = toKmh(windChillSpeed);
            const chillTour = windChillC(temp, windChillKmh);
            setText("tourWindChillValue", chillTour !== null && chillTour !== undefined ? `${formatValue(chillTour, "C", 1)}` : "-");
            const windHint = windChillKmh !== null && windChillKmh !== undefined
                ? `${formatValue(windChillKmh, "km/h", 0)}`
                : "-";
            setText("tourWindChillHint", `Wind ${windHint} · T ${formatValue(temp, "C")}`);
            setText("wetSnowValue", wet !== null && wet !== undefined ? `${Math.round(wet * 100)}%` : "-");
            setText("wetSnowHint", `T ${formatValue(temp, "C")} | Regen ${formatValue(precipNow, "mm")}`);

            const vis = features.visibility_risk[idx];
            setText("visibilityValue", vis !== null && vis !== undefined ? `${Math.round(vis * 100)}%` : "-");
            setText("visibilityHint", `Wolken ${formatPercent(series.cloud_total_pct[idx], 0)} | Wind ${formatValue(toKmh(features.wind_takeoff[idx]), "km/h", 0)}`);

            const zeroAsl = features.freezing_level_asl[idx];
            const zeroAgl = features.freezing_level_agl[idx];
            setText("freezingLevelValue", zeroAsl !== null && zeroAsl !== undefined ? `Nullgrad ${formatValue(zeroAsl, "m", 0)} ASL` : "-");
            const zeroHint = zeroAgl !== null && zeroAgl !== undefined
                ? `AGL ${formatValue(zeroAgl, "m", 0)} | T ${formatValue(temp, "C")}`
                : `T ${formatValue(temp, "C")}`;
            setText("freezingLevelHint", zeroHint);

            const altitudes = getSelectedTourAltitudes();
            const tempLines = altitudes.map((alt) => {
                const t = temperatureAtAsl(payload.upper, idx, alt, site.elevation_m);
                return `${Math.round(alt)}m: ${formatValue(t, "C", 1)}`;
            });
            const chunks = [];
            for (let i = 0; i < tempLines.length; i += 2) {
                chunks.push(tempLines.slice(i, i + 2).join(" · "));
            }
            setText("tourAltTempValue", altitudes.length ? `Auswahl ${altitudes.join("/")} m` : "-");
            setHTML("tourAltTempList", tempLines.length ? chunks.join("<br>") : "-");
            const baseHint = site && site.elevation_m !== null && site.elevation_m !== undefined
                ? `Ort ${Math.round(site.elevation_m)}m · AGL = Höhe - Ort`
                : "AGL = Höhe - Ort";
            setText("tourAltTempHint", baseHint);

            if (avalancheRegionSelect) {
                avalancheRegionSelect.value = payload.avalanche_region || getAvalancheRegion(payload.site);
            }
            if (bulletinLevel) {
                const belowText = bandLevels?.below ? `unter Waldgrenze L${bandLevels.below}/5` : "unter Waldgrenze -";
                const aboveText = bandLevels?.above ? `ober Waldgrenze L${bandLevels.above}/5` : "ober Waldgrenze -";
                setText("avalancheLevelValue", `Stufe: ${belowText} · ${aboveText}`);
                const validText = bulletin?.validStart || bulletin?.validEnd
                    ? `G\u00fcltig: ${formatLabel(bulletin.validStart)} - ${formatLabel(bulletin.validEnd)}`
                    : `Update: ${formatLabel(bulletin?.reportTime)}`;
                const maxNote = maxBulletinLevel && maxBulletinLevel !== bulletinLevel ? ` · Max L${maxBulletinLevel}` : "";
                const fallbackNote = bulletin?.regionUsed && bulletin.regionMatched && bulletin.regionMatched !== payload.avalanche_region
                    ? ` · Fallback ${bulletin.regionUsed}`
                    : "";
                setText("avalancheValidValue", `${validText}${maxNote}${fallbackNote}`);
                const problems = bulletin?.problems && bulletin.problems.length ? bulletin.problems.join(", ") : "keine Angaben";
                setText("avalancheProblemsValue", `Probleme: ${problems}`);
            } else {
                setText("avalancheLevelValue", "kein Bericht");
                setText("avalancheValidValue", "-");
                setText("avalancheProblemsValue", "-");
            }
        }

        function renderThermikMatrix(payload) {
            if (!thermikMatrix || !payload) return;
            const { series, features, upper, site, missing } = payload;
            const labelsIso = series.labels_iso || series.labels || [];
            const labels = series.labels || labelsIso;
            updateParaDaySelect(labelsIso);
            const dayKey = currentParaDay && currentParaDay !== "all" ? currentParaDay : null;
            const indices = dayKey ? getDayIndices(labelsIso, dayKey) : null;
            const useIndices = indices && indices.length ? indices : labelsIso.map((_, i) => i);
            const labelsUse = useIndices.map((i) => labels[i]);
            const labelsIsoUse = useIndices.map((i) => labelsIso[i]);
            const n = labelsUse.length;
            if (!n) return;
            const ctx = thermikMatrix.getContext("2d");
            if (!ctx) return;

            // On portrait mobile, we need a wider canvas so time-columns stay readable.
            // The wrapper is horizontally scrollable, so this does not cause page-level overflow.
            // On landscape mobile, keep the matrix within the visible container to avoid oversizing.
            const narrow = window.matchMedia && window.matchMedia("(max-width: 960px)").matches;
            const portrait = window.matchMedia && window.matchMedia("(orientation: portrait)").matches;
            const wrap = thermikMatrix.closest(".thermik-wrap");
            if (narrow && portrait) {
                const baseW = wrap ? wrap.clientWidth : thermikMatrix.parentElement?.clientWidth;
                const targetCellW = n >= 44 ? 14 : n >= 30 ? 16 : 18;
                const desiredW = Math.round(220 + n * targetCellW);
                const nextW = Math.max(baseW || 0, desiredW);
                const nextStyle = `${nextW}px`;
                if (thermikMatrix.style.width !== nextStyle) thermikMatrix.style.width = nextStyle;
            } else if (thermikMatrix.style.width && thermikMatrix.style.width !== "100%") {
                thermikMatrix.style.width = "100%";
            }

            const width = thermikMatrix.clientWidth;
            const height = thermikMatrix.clientHeight;
            if (width < 80 || height < 120) return;
            const dpr = window.devicePixelRatio || 1;
            thermikMatrix.width = width * dpr;
            thermikMatrix.height = height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
            ctx.clearRect(0, 0, width, height);

            const padLeft = Math.max(72, Math.min(108, Math.round(width * 0.085)));
            const padRight = Math.max(8, Math.min(16, Math.round(width * 0.015)));
            const padBottom = 58;
            const cloudRowH = 15;
            const windRowH = 16;
            const cloudTop = 8;
            const cloudInfoY = cloudTop + cloudRowH * 3 + 8;
            const windTop = cloudInfoY + 8;
            const headerH = windTop + windRowH * 2 + 10;
            const legendW = Math.max(86, Math.min(112, Math.round(width * 0.1)));
            const legendBlockH = 70;
            const gridTop = headerH;
            const gridW = width - padLeft - padRight - legendW;
            const gridH = height - gridTop - padBottom;
            const cellW = gridW / n;
            const cellPad = Math.min(2, Math.max(0.5, cellW * 0.08));

            const lowCloudArr = series.cloud_low_pct || series.cloud_total_pct || [];
            const midCloudArr = series.cloud_mid_pct || series.cloud_total_pct || [];
            const highCloudArr = series.cloud_high_pct || series.cloud_total_pct || [];
            const deckBase = [];
            const deckTop = [];
            const cloudBaseByTime = [];
            const lowClass = [];
            const relevantHeights = [];
            const MAX_DISPLAY_AGL = 6000;
            for (let i = 0; i < n; i += 1) {
                const origIdx = useIndices[i];
                let zi = features.blh_m[origIdx];
                const inv = features.inversion_base_agl[origIdx];
                if (zi === null || zi === undefined || Number.isNaN(zi)) zi = 1200;
                if (inv !== null && inv !== undefined && !Number.isNaN(inv)) zi = Math.min(zi, inv);
                if (zi < 200) zi = 200;

                const t2m = series.t2m_C[origIdx];
                const rh2m = series.rh2m_pct[origIdx];
                const low = lowCloudArr[origIdx] ?? 0;
                const lcl = lclHeightAgl(t2m, rh2m);
                const lowClassVal = cloudToStep(low);
                lowClass[i] = lowClassVal;
                let base = null;
                let top = null;
                const lowPresent = low >= 20 && lowClassVal >= 2;
                if (lowPresent) {
                    const lclBase = lcl !== null && lcl !== undefined ? Math.max(100, lcl) : 300;
                    const baseCap = lowClassVal >= 4 ? 400 : (lowClassVal >= 3 ? 800 : 1200);
                    base = Math.min(lclBase, baseCap);
                    base = Math.max(100, base);
                    if (zi !== null && zi !== undefined && !Number.isNaN(zi)) {
                        base = Math.min(base, Math.max(200, zi - 300));
                    }
                    const extraMoist = rh2m !== null && rh2m !== undefined && rh2m >= 90 ? 200 : 0;
                    const depth = (lowClassVal >= 4 ? 1200 : (lowClassVal >= 3 ? 800 : 500)) + extraMoist;
                    top = base + depth;
                    if (inv !== null && inv !== undefined && !Number.isNaN(inv)) {
                        top = Math.min(top, inv);
                    }
                    if (zi !== null && zi !== undefined && !Number.isNaN(zi)) {
                        top = Math.min(top, zi);
                    }
                    if (top < base + 200) top = base + 200;
                    if (base > top - 200) base = Math.max(100, top - 200);
                }
                if (top !== null && top !== undefined) {
                    top = Math.min(top, MAX_DISPLAY_AGL);
                    if (base !== null && base !== undefined && base >= top) {
                        base = null;
                        top = null;
                    }
                }
                cloudBaseByTime[i] = base;
                deckBase[i] = base;
                deckTop[i] = top;

                if (base !== null && base !== undefined) relevantHeights.push(base);
                if (top !== null && top !== undefined) relevantHeights.push(top);
                if (zi !== null && zi !== undefined) relevantHeights.push(zi);
            }

            const maxRelevant = relevantHeights.length ? Math.max(...relevantHeights) : 2400;
            const maxAgl = Math.min(MAX_DISPLAY_AGL, Math.max(1600, Math.ceil(maxRelevant / 200) * 200));
            const minAgl = 200;
            const aglRange = maxAgl - minAgl || 1;
            const heightLevels = [];
            for (let z = minAgl; z <= maxAgl; z += 200) heightLevels.push(z);
            const cellH = gridH / heightLevels.length;

            const bg = ctx.createLinearGradient(0, 0, 0, height);
            bg.addColorStop(0, "rgba(248, 250, 252, 0.98)");
            bg.addColorStop(1, "rgba(226, 232, 240, 0.92)");
            ctx.fillStyle = bg;
            ctx.fillRect(0, 0, width, height);

            const sunFactors = labelsIsoUse.map((iso) => solarFactor(iso, site.lat));
            for (let i = 0; i < n; i += 1) {
                const factor = sunFactors[i] ?? 0;
                const x = padLeft + i * cellW;
                if (factor > 0.1) {
                    const alpha = 0.08 + 0.14 * factor;
                    ctx.fillStyle = `rgba(253, 230, 138, ${alpha})`;
                } else {
                    ctx.fillStyle = "rgba(148, 163, 184, 0.06)";
                }
                ctx.fillRect(x, gridTop, cellW, gridH);
            }

            const midClass = [];
            const highClass = [];
            for (let i = 0; i < n; i += 1) {
                const origIdx = useIndices[i];
                const midPct = midCloudArr[origIdx];
                const highPct = highCloudArr[origIdx];
                midClass[i] = midPct === null || midPct === undefined ? 0 : cloudToStep(midPct);
                highClass[i] = highPct === null || highPct === undefined ? 0 : cloudToStep(highPct);
            }

            const cloudRows = [
                { label: "H", data: highClass },
                { label: "M", data: midClass },
                { label: "T", data: lowClass },
            ];

            const cloudPalette = [
                "rgba(148, 163, 184, 0.12)",
                "rgba(148, 163, 184, 0.2)",
                "rgba(100, 116, 139, 0.28)",
                "rgba(71, 85, 105, 0.36)",
                "rgba(51, 65, 85, 0.45)",
                "rgba(30, 41, 59, 0.52)",
            ];
            const cloudValueStep = n > 56 ? 6 : (n > 42 ? 4 : (n > 28 ? 3 : 1));
            ctx.font = "11px var(--font-body), sans-serif";
            ctx.fillStyle = "rgba(15, 23, 42, 0.85)";
            cloudRows.forEach((row, rIdx) => {
                const y = cloudTop + rIdx * cloudRowH;
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
                ctx.fillText(row.label, 8, y + 10);
                for (let i = 0; i < n; i += 1) {
                    const val = row.data[i];
                    if (val === null || val === undefined) continue;
                    const x = padLeft + i * cellW + 0.5;
                    const w = Math.max(1, cellW - 1);
                    const idx = clamp(Math.round(val), 0, cloudPalette.length - 1);
                    ctx.fillStyle = cloudPalette[idx];
                    ctx.fillRect(x, y, w, cloudRowH - 2);
                    if (i % cloudValueStep === 0 || n <= 26) {
                        ctx.fillStyle = idx >= 4 ? "rgba(248, 250, 252, 0.95)" : "rgba(15, 23, 42, 0.82)";
                        ctx.fillText(String(val), x + Math.max(1, w * 0.5 - 3), y + 10);
                    }
                }
            });
            ctx.fillStyle = "rgba(51, 65, 85, 0.85)";
            ctx.font = "10px var(--font-body), sans-serif";
            ctx.fillText("H/M/T = Hoch/Mittel/Tiefbewölkung (0-5)", padLeft, cloudInfoY);

            const Z_ICON_MAX = 3000;
            const LOW_LAYER_MAX = 2000;
            const pLowCloud = Array.from({ length: n }, () => new Array(heightLevels.length).fill(0));
            const iconOn = Array.from({ length: n }, () => new Array(heightLevels.length).fill(false));
            for (let i = 0; i < n; i += 1) {
                const origIdx = useIndices[i];
                const lowCover = clamp((lowCloudArr[origIdx] ?? 0) / 100, 0, 1);
                for (let h = 0; h < heightLevels.length; h += 1) {
                    const z = heightLevels[h];
                    pLowCloud[i][h] = z <= LOW_LAYER_MAX && z <= Z_ICON_MAX ? lowCover : 0;
                }
            }

            for (let h = 0; h < heightLevels.length; h += 1) {
                let on = false;
                for (let i = 0; i < n; i += 1) {
                    const cls = lowClass[i] ?? 0;
                    let thOn = 0.6;
                    let thOff = 0.4;
                    if (cls <= 1) {
                        thOn = 0.8;
                        thOff = 0.6;
                    } else if (cls >= 4) {
                        thOn = 0.5;
                        thOff = 0.35;
                    }
                    const p = pLowCloud[i][h];
                    on = on ? p >= thOff : p >= thOn;
                    iconOn[i][h] = on;
                }
            }
            for (let h = 0; h < heightLevels.length; h += 1) {
                for (let i = 1; i < n - 1; i += 1) {
                    if (!iconOn[i][h] && iconOn[i - 1][h] && iconOn[i + 1][h]) {
                        iconOn[i][h] = true;
                    }
                }
            }
            for (let i = 0; i < n; i += 1) {
                for (let h = 0; h < heightLevels.length; h += 1) {
                    if (!iconOn[i][h]) continue;
                    if (h > 0 && !iconOn[i][h - 1] && pLowCloud[i][h - 1] >= 0.45) iconOn[i][h - 1] = true;
                    if (h < heightLevels.length - 1 && !iconOn[i][h + 1] && pLowCloud[i][h + 1] >= 0.45) iconOn[i][h + 1] = true;
                }
            }
            for (let i = 0; i < n; i += 1) {
                const allow = (lowClass[i] ?? 0) >= 2;
                for (let h = 0; h < heightLevels.length; h += 1) {
                    const z = heightLevels[h];
                    if (!allow || z > LOW_LAYER_MAX || z > Z_ICON_MAX) {
                        iconOn[i][h] = false;
                    }
                }
            }

            const windHeights = [
                { label: "1km", agl: 1000 },
                { label: "2km", agl: 2000 },
            ];
            windHeights.forEach((row, rIdx) => {
                const y = windTop + rIdx * windRowH;
                ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
                ctx.fillText(row.label, 6, y + 10);
                for (let i = 0; i < n; i += 1) {
                    const x = padLeft + i * cellW + cellW * 0.5;
                    const targetAsl = site.elevation_m + row.agl;
                    const origIdx = useIndices[i];
                    const wind = windAtAsl(upper, origIdx, targetAsl, site.elevation_m);
                    const speed = wind ? wind.speed : features.wind_takeoff[origIdx];
                    const dir = wind ? wind.dir : features.wind_takeoff_dir[origIdx];
                    if (speed === null || speed === undefined || dir === null || dir === undefined) continue;
                    const angle = (dir + 90) * (Math.PI / 180);
                    const len = 6 + Math.min(10, speed * 0.6);
                    drawArrow(ctx, x, y + 6, angle, len, "rgba(94, 234, 212, 0.8)");
                }
            });

            const legendX = padLeft + gridW + 8;
            const legendScaleTop = gridTop + legendBlockH + 6;
            const legendScaleH = Math.max(40, gridH - legendBlockH - 6);

            const lineLegendX = legendX;
            const lineLegendY = gridTop + 6;
            ctx.font = "11px var(--font-body), sans-serif";
            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.strokeStyle = "rgba(239, 68, 68, 0.9)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lineLegendX, lineLegendY);
            ctx.lineTo(lineLegendX + 20, lineLegendY);
            ctx.stroke();
            ctx.fillText("Basis", lineLegendX + 26, lineLegendY + 4);

            ctx.strokeStyle = "rgba(59, 130, 246, 0.9)";
            ctx.setLineDash([4, 3]);
            ctx.beginPath();
            ctx.moveTo(lineLegendX + 64, lineLegendY);
            ctx.lineTo(lineLegendX + 84, lineLegendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillText("Decke", lineLegendX + 90, lineLegendY + 4);

            const cloudLegendY = lineLegendY + 12;
            ctx.fillStyle = "rgba(71, 85, 105, 0.35)";
            ctx.fillRect(lineLegendX, cloudLegendY - 6, 16, 10);
            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.fillText("Low-Cloud Deck", lineLegendX + 22, cloudLegendY + 4);

            const blhLegendY = cloudLegendY + 12;
            ctx.strokeStyle = "rgba(34, 197, 94, 0.9)";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(lineLegendX, blhLegendY);
            ctx.lineTo(lineLegendX + 20, blhLegendY);
            ctx.stroke();
            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.fillText("BLH", lineLegendX + 26, blhLegendY + 4);

            const zeroLegendY = blhLegendY + 12;
            ctx.strokeStyle = "rgba(14, 165, 233, 0.9)";
            ctx.lineWidth = 1.8;
            ctx.setLineDash([3, 2]);
            ctx.beginPath();
            ctx.moveTo(lineLegendX, zeroLegendY);
            ctx.lineTo(lineLegendX + 20, zeroLegendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.fillText("0°C", lineLegendX + 26, zeroLegendY + 4);

            const invLegendY = zeroLegendY + 12;
            ctx.strokeStyle = "rgba(168, 85, 247, 0.9)";
            ctx.lineWidth = 1.6;
            ctx.setLineDash([4, 2]);
            ctx.beginPath();
            ctx.moveTo(lineLegendX, invLegendY);
            ctx.lineTo(lineLegendX + 20, invLegendY);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.fillStyle = "rgba(15, 23, 42, 0.8)";
            ctx.fillText("Inversion", lineLegendX + 26, invLegendY + 4);

            for (let h = 0; h < heightLevels.length; h += 1) {
                const z = heightLevels[h];
                const y = gridTop + (heightLevels.length - 1 - h) * cellH + cellH * 0.5;
                ctx.strokeStyle = "rgba(15, 23, 42, 0.08)";
                ctx.beginPath();
                ctx.moveTo(padLeft, y);
                ctx.lineTo(padLeft + gridW, y);
                ctx.stroke();
                if (z % 400 === 0) {
                    ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
                    const zAsl = site.elevation_m + z;
                    ctx.fillText(`${Math.round(zAsl)}`, 28, y + 4);
                }
            }

            const blhSeries = [];
            const invSeries = [];
            const zeroSeries = [];
            const wGrid = Array.from({ length: n }, () => new Array(heightLevels.length).fill(null));
            for (let i = 0; i < n; i += 1) {
                const origIdx = useIndices[i];
                const maturity = features.thermal_maturity[origIdx];
                const baseConf = maturity !== null && maturity !== undefined ? clamp((maturity - 0.2) / 0.6, 0, 1) : 0.2;
                const confidence = missing && missing.profile ? Math.min(baseConf, 0.3) : baseConf;
                const alpha = 0.35 + 0.65 * confidence;
                let zi = features.blh_m[origIdx];
                const inv = features.inversion_base_agl[origIdx];
                if (zi === null || zi === undefined || Number.isNaN(zi)) zi = 1200;
                if (inv !== null && inv !== undefined && !Number.isNaN(inv)) zi = Math.min(zi, inv);
                if (zi < 200) zi = 200;
                const wStar = maturity !== null && maturity !== undefined ? 0.3 + maturity * 2.5 : 0.4;

                blhSeries[i] = zi;
                invSeries[i] = inv !== null && inv !== undefined ? inv : null;
                const zeroAsl = features.freezing_level_asl[origIdx];
                const zeroAgl = zeroAsl !== null && zeroAsl !== undefined ? zeroAsl - (site?.elevation_m || 0) : null;
                zeroSeries[i] = zeroAgl !== null && zeroAgl !== undefined ? zeroAgl : null;

                for (let h = 0; h < heightLevels.length; h += 1) {
                    const z = heightLevels[h];
                    let w = 0;
                    if (z < zi) {
                        const r = z / zi;
                        w = wStar * 4 * r * (1 - r);
                    }
                    if (w < 0) w = 0;
                    wGrid[i][h] = w;
                    const x = padLeft + i * cellW;
                    const y = gridTop + (heightLevels.length - 1 - h) * cellH;
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = colorForThermik(w);
                    const x0 = x + cellPad;
                    const y0 = y + cellPad;
                    const w0 = Math.max(0, cellW - 2 * cellPad);
                    const h0 = Math.max(0, cellH - 2 * cellPad);
                    if (ctx.roundRect) {
                        ctx.beginPath();
                        ctx.roundRect(x0, y0, w0, h0, 3);
                        ctx.fill();
                    } else {
                        ctx.fillRect(x0, y0, w0, h0);
                    }
                    ctx.globalAlpha = 1;
                    const valueStep = n > 56 ? 6 : (n > 42 ? 4 : (n > 28 ? 3 : 1));
                    if (w >= 0.4 && (i % valueStep === 0 || n <= 26)) {
                        ctx.fillStyle = w >= 1.2 ? "rgba(255, 255, 255, 0.95)" : "rgba(15, 23, 42, 0.9)";
                        ctx.font = "11px var(--font-body), sans-serif";
                        ctx.fillText(w.toFixed(1), x + 4, y + cellH - 4);
                    }
                }
            }

            const nowIdx = pickCurrentIndex(labelsIsoUse);
            if (nowIdx !== null && nowIdx !== undefined) {
                const xNow = padLeft + nowIdx * cellW + cellW * 0.5;
                ctx.strokeStyle = "rgba(250, 204, 21, 0.9)";
                ctx.lineWidth = 1.4;
                ctx.beginPath();
                ctx.moveTo(xNow, gridTop);
                ctx.lineTo(xNow, gridTop + gridH);
                ctx.stroke();
                ctx.fillStyle = "rgba(250, 204, 21, 0.95)";
                ctx.font = "10px var(--font-body), sans-serif";
                ctx.fillText("Jetzt", xNow + 4, gridTop + 12);
            }

            for (let i = 0; i < n; i += 1) {
                const base = deckBase[i];
                const top = deckTop[i];
                if (base === null || base === undefined || top === null || top === undefined) continue;
                if (top > maxAgl) continue;
                const origIdx = useIndices[i];
                const cover = clamp((lowCloudArr[origIdx] ?? 0) / 100, 0, 1);
                if (cover < 0.1) continue;
                const yTop = gridTop + (maxAgl - top) / aglRange * gridH;
                const yBase = gridTop + (maxAgl - base) / aglRange * gridH;
                const x = padLeft + i * cellW;
                const y0 = Math.min(yTop, yBase);
                const h = Math.abs(yBase - yTop);
                const grad = ctx.createLinearGradient(0, y0, 0, y0 + h);
                const alphaTop = 0.06 + 0.22 * cover;
                const alphaBase = 0.12 + 0.45 * cover;
                grad.addColorStop(0, `rgba(71, 85, 105, ${alphaTop})`);
                grad.addColorStop(1, `rgba(71, 85, 105, ${alphaBase})`);
                ctx.fillStyle = grad;
                ctx.fillRect(x + 1, y0, Math.max(1, cellW - 2), h);
            }

            const drawLineFromSeries = (seriesArr, color, dash) => {
                const pts = [];
                for (let i = 0; i < n; i += 1) {
                    const z = seriesArr[i];
                    if (z === null || z === undefined || Number.isNaN(z)) continue;
                    if (z < minAgl || z > maxAgl) continue;
                    const x = padLeft + i * cellW + cellW * 0.5;
                    const y = gridTop + (maxAgl - z) / aglRange * gridH;
                    pts.push({ x, y });
                }
                if (!pts.length) return;
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.6;
                if (dash) ctx.setLineDash(dash);
                ctx.beginPath();
                pts.forEach((pt, idx) => {
                    if (idx === 0) ctx.moveTo(pt.x, pt.y);
                    else ctx.lineTo(pt.x, pt.y);
                });
                ctx.stroke();
                ctx.setLineDash([]);
            };

            drawLineFromSeries(blhSeries, "rgba(34, 197, 94, 0.9)", null);
            drawLineFromSeries(invSeries, "rgba(168, 85, 247, 0.9)", [4, 2]);
            drawLineFromSeries(zeroSeries, "rgba(14, 165, 233, 0.9)", [3, 2]);

            const drawCloudLine = (seriesZ, color, dash, drawDots = false) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.6;
                if (dash) ctx.setLineDash(dash);
                let started = false;
                ctx.beginPath();
                for (let i = 0; i < n; i += 1) {
                    const cls = lowClass[i] ?? 0;
                    if (cls < 2) {
                        if (started) {
                            ctx.stroke();
                            ctx.beginPath();
                            started = false;
                        }
                        continue;
                    }
                    const z = seriesZ[i];
                    if (z === null || z === undefined || Number.isNaN(z)) {
                        if (started) {
                            ctx.stroke();
                            ctx.beginPath();
                            started = false;
                        }
                        continue;
                    }
                    if (z < minAgl || z > maxAgl) continue;
                    const x = padLeft + i * cellW + cellW * 0.5;
                    const y = gridTop + (maxAgl - z) / aglRange * gridH;
                    if (!started) {
                        ctx.moveTo(x, y);
                        started = true;
                    } else {
                        ctx.lineTo(x, y);
                    }
                    if (drawDots) {
                        ctx.save();
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x, y, 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                if (started) ctx.stroke();
                ctx.setLineDash([]);
            };

            drawCloudLine(cloudBaseByTime, "rgba(239, 68, 68, 0.85)", null, true);
            drawCloudLine(deckTop, "rgba(59, 130, 246, 0.9)", [4, 3], false);

            const legendY = legendScaleTop;
            const legendH = legendScaleH;
            ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
            ctx.font = "10px var(--font-body), sans-serif";
            ctx.fillText("m/s", legendX, legendY - 6);
            const legendStepH = legendH / THERMIK_STEPS.length;
            for (let i = 0; i < THERMIK_STEPS.length; i += 1) {
                const y = legendY + legendH - (i + 1) * legendStepH;
                ctx.fillStyle = THERMIK_COLORS[i];
                ctx.fillRect(legendX, y, 14, legendStepH);
                ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
                const label = i === THERMIK_STEPS.length - 1 ? `${THERMIK_STEPS[i]}+` : `${THERMIK_STEPS[i]}`;
                ctx.fillText(label, legendX + 18, y + legendStepH - 3);
            }

            const minLabelPx = 52;
            const pixelStep = Math.max(1, Math.ceil(minLabelPx / Math.max(cellW, 1)));
            const labelStep = Math.max(pixelStep, n > 56 ? 6 : (n > 42 ? 4 : (n > 24 ? 3 : 1)));
            const xTickY = height - 24;
            const xAxisTitleY = height - 6;
            ctx.fillStyle = "rgba(15, 23, 42, 0.75)";
            ctx.font = "10px var(--font-body), sans-serif";
            ctx.textAlign = "center";
            for (let i = 0; i < n; i += labelStep) {
                const label = labelsUse[i] || "";
                const dt = parseLocal(labelsIsoUse[i]) || parseLocal(label);
                const hour = dt ? `${String(dt.getHours()).padStart(2, "0")}:00` : label;
                const x = padLeft + i * cellW + cellW * 0.5;
                ctx.fillText(hour, x, xTickY);
            }
            ctx.textAlign = "start";

            ctx.save();
            ctx.translate(8, gridTop + gridH * 0.5);
            ctx.rotate(-Math.PI / 2);
            ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
            ctx.font = "11px var(--font-body), sans-serif";
            ctx.fillText("Höhe (m ASL)", 0, 0);
            ctx.restore();
            ctx.fillStyle = "rgba(15, 23, 42, 0.7)";
            ctx.font = "11px var(--font-body), sans-serif";
            ctx.textAlign = "center";
            ctx.fillText("Zeit (lokal)", padLeft + gridW * 0.5, xAxisTitleY);
            ctx.textAlign = "start";

            thermikHoverState = {
                labels: labelsUse,
                labelsIso: labelsIsoUse,
                heightLevels,
                wGrid,
                site,
                padLeft,
                gridTop,
                gridW,
                gridH,
                cellW,
                cellH,
                maxAgl,
                minAgl,
                deckBase,
                deckTop,
                cloudBaseByTime,
                lowClass,
                midClass,
                highClass,
                pLowCloud,
                iconOn,
                blhSeries,
                invSeries,
                zeroSeries,
            };

            payload.cloud_debug = {
                low_class: lowClass,
                mid_class: midClass,
                high_class: highClass,
                p_low_cloud: pLowCloud,
                icon_on: iconOn,
                height_levels_agl: heightLevels,
                labels_iso: labelsIsoUse,
                z_icon_max: Z_ICON_MAX,
                blh_agl: blhSeries,
                inversion_agl: invSeries,
                zero_agl: zeroSeries,
                low_cloud_base_agl: cloudBaseByTime,
                low_cloud_top_agl: deckTop,
            };
        }

        function updateSkitourCharts(payload) {
            if (!chartAvailable || !payload) return;
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels || [];
            const labels = series.labels || labelsIso;
            const dayKey = currentTourDay && currentTourDay !== "all" ? currentTourDay : null;
            const indices = dayKey ? getDayIndices(labelsIso, dayKey) : null;
            const useLabels = chartLabelsForDayFilter(labelsIso, labels, indices, dayKey);
            const bulletin = payload.avalanche;
            const bandLevels = getDangerLevelsByBand(bulletin, payload.site);
            const levelBelow = bandLevels?.below ?? null;
            const levelAbove = bandLevels?.above ?? null;
            const riskBelow = levelBelow ? clamp((levelBelow - 1) / 4, 0, 1) : null;
            const riskAbove = levelAbove ? clamp((levelAbove - 1) / 4, 0, 1) : null;

            if (tourBandChart) {
                tourBandChart.data.labels = useLabels;
                const base = features.tour_score || [];
                const belowSeries = levelBelow
                    ? base.map((v) => (v === null || v === undefined ? null : clamp(v - levelBelow * 15, 0, 100)))
                    : base.map(() => null);
                const aboveSeries = levelAbove
                    ? base.map((v) => (v === null || v === undefined ? null : clamp(v - levelAbove * 15, 0, 100)))
                    : base.map(() => null);
                tourBandChart.data.datasets[0].data = filterByIndices(belowSeries, indices);
                tourBandChart.data.datasets[1].data = filterByIndices(aboveSeries, indices);
                tourBandChart.update();
            }
            if (tourHazardChart) {
                tourHazardChart.data.labels = useLabels;
                const proxyBase = features.avalanche_proxy || [];
                const hazardBelow = proxyBase.map((v) => {
                    if (v === null || v === undefined) return riskBelow !== null ? riskBelow * 100 : null;
                    if (riskBelow === null || riskBelow === undefined) return v * 100;
                    return Math.max(v, riskBelow) * 100;
                });
                const hazardAbove = proxyBase.map((v) => {
                    if (v === null || v === undefined) return riskAbove !== null ? riskAbove * 100 : null;
                    if (riskAbove === null || riskAbove === undefined) return v * 100;
                    return Math.max(v, riskAbove) * 100;
                });
                tourHazardChart.data.datasets[0].data = filterByIndices(hazardBelow, indices);
                tourHazardChart.data.datasets[1].data = filterByIndices(hazardAbove, indices);
                tourHazardChart.update();
            }
            if (tourAltTempChart) {
                tourAltTempChart.data.labels = useLabels;
                const altitudes = getSelectedTourAltitudes();
                tourAltTempChart.data.datasets = altitudes.map((alt, idx) =>
                    chartDataset(`${Math.round(alt)}m`, TOUR_ALT_COLORS[idx % TOUR_ALT_COLORS.length])
                );
                altitudes.forEach((alt, idx) => {
                    const temps = labelsIso.map((_, i) => temperatureAtAsl(payload.upper, i, alt, payload.site?.elevation_m));
                    tourAltTempChart.data.datasets[idx].data = filterByIndices(temps, indices);
                });
                tourAltTempChart.update();
            }
            if (tourAltChillChart) {
                tourAltChillChart.data.labels = useLabels;
                const altitudes = getSelectedTourAltitudes();
                tourAltChillChart.data.datasets = altitudes.map((alt, idx) =>
                    chartDataset(`${Math.round(alt)}m`, TOUR_ALT_COLORS[idx % TOUR_ALT_COLORS.length])
                );
                altitudes.forEach((alt, idx) => {
                    const chills = labelsIso.map((_, i) => {
                        const t = temperatureAtAsl(payload.upper, i, alt, payload.site?.elevation_m);
                        let windMs = windSpeedAtAsl(payload.upper, i, alt, payload.site?.elevation_m);
                        if (windMs === null || windMs === undefined) windMs = features.wind_takeoff[i];
                        return windChillC(t, toKmh(windMs));
                    });
                    tourAltChillChart.data.datasets[idx].data = filterByIndices(chills, indices);
                });
                tourAltChillChart.update();
            }
            if (snowChart) {
                snowChart.data.labels = useLabels;
                const snow24Use = filterByIndices(features.snow_24h_cm || [], indices);
                snowChart.data.datasets[0].data = snow24Use;
                const snowLabelsIso = filterByIndices(labelsIso || [], indices);
                const snowCum = integrateSnow24Series(snow24Use, snowLabelsIso, 24);
                snowChart.data.datasets[1].data = snowCum;
                snowChart.update();
            }
            if (windLoadChart) {
                windLoadChart.data.labels = useLabels;
                windLoadChart.data.datasets[0].data = filterByIndices((features.wind_loading_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), indices);
                windLoadChart.update();
            }
            if (wetSnowChart) {
                wetSnowChart.data.labels = useLabels;
                wetSnowChart.data.datasets[0].data = filterByIndices((features.wet_snow_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), indices);
                wetSnowChart.update();
            }
            if (visibilityChart) {
                visibilityChart.data.labels = useLabels;
                visibilityChart.data.datasets[0].data = filterByIndices((features.visibility_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), indices);
                const sunPct = (series.sunshine_s || []).map((v) =>
                    v === null || v === undefined || Number.isNaN(v) ? null : clamp((v / 3600) * 100, 0, 100)
                );
                visibilityChart.data.datasets[1].data = filterByIndices(sunPct, indices);
                visibilityChart.update();
            }
            if (freezingChart) {
                freezingChart.data.labels = useLabels;
                freezingChart.data.datasets[0].data = filterByIndices(features.freezing_level_asl || [], indices);
                freezingChart.update();
            }
        }

        function updateCycling(payload) {
            if (!payload) return;
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels;
            let idx = pickCurrentIndex(labelsIso);
            if (currentRideDay && currentRideDay !== "all") {
                const bestIdx = pickBestIndexForDay(labelsIso, currentRideDay, features.ride_score);
                if (bestIdx !== null && bestIdx !== undefined) idx = bestIdx;
            }

            const score = features.ride_score[idx];
            setText("rideScoreValue", score !== null && score !== undefined ? `${Math.round(score)}/100` : "-");
            setText("rideScoreHint", score !== null && score !== undefined ? scoreLabel(score) : "-");
            applyScoreClass("rideScoreValue", score);

            const reasons = [];
            if (features.ride_precip_risk[idx] !== null && features.ride_precip_risk[idx] > 0.55) reasons.push("Regenrisiko");
            if (features.ride_wind_risk[idx] !== null && features.ride_wind_risk[idx] > 0.55) reasons.push("Starker Wind/B\u00f6en");
            if (features.ride_temp_risk[idx] !== null && features.ride_temp_risk[idx] > 0.55) reasons.push("Temperatur ungem\u00fctlich");
            if (features.ride_light_risk[idx] !== null && features.ride_light_risk[idx] > 0.75) reasons.push("Dunkel / geschlossene Bew\u00f6lkung");
            const convRisk = features.convection_risk[idx];
            const tempNow = series.t2m_C[idx];
            const freezingAsl = features.freezing_level_asl[idx];
            const sunNow = series.sunshine_s[idx] !== null && series.sunshine_s[idx] !== undefined ? series.sunshine_s[idx] / 3600 : null;
            const lapseNow = features.lapse_rate_low ? features.lapse_rate_low[idx] : null;
            const convSeason = (tempNow !== null && tempNow !== undefined && tempNow >= 12)
                || (freezingAsl !== null && freezingAsl !== undefined && freezingAsl >= 2200);
            const convSignal = (sunNow !== null && sunNow > 0.3)
                || (lapseNow !== null && lapseNow <= -0.6);
            if (convRisk !== null && convRisk > 0.65 && convSeason && convSignal) reasons.push("Gewitterrisiko");
            setText("rideScoreReasons", reasons.length ? reasons.join(" | ") : "Bedingungen stabil");

            const rideWindow = features.ride_window;
            if (!rideWindow) {
                setText("rideWindowValue", "Kein sicheres Tagesfenster");
                setText("rideWindowPeak", "Bedingungen zu nass / Nacht");
                setText("rideWindowUncertainty", "-");
            } else {
                const startLabel = series.labels[rideWindow.startIdx];
                const endLabel = series.labels[rideWindow.endIdx];
                const peakLabel = series.labels[rideWindow.peakIdx];
                setText("rideWindowValue", `${startLabel} - ${endLabel}`);
                setText("rideWindowPeak", `Peak: ${peakLabel}`);
                setText("rideWindowUncertainty", `Unsicherheit \u00b1${rideWindow.uncertaintyMin} min`);
            }

            const temp = series.t2m_C[idx];
            const feels = features.ride_feels_like[idx] ?? temp;
            const rh = series.rh2m_pct[idx];
            const comfort = features.ride_temp_risk[idx] !== null && features.ride_temp_risk[idx] !== undefined
                ? Math.round((1 - features.ride_temp_risk[idx]) * 100)
                : null;
            setText("rideTempValue", `${formatValue(temp, "C")} \u00b7 Gef\u00fchlt ${formatValue(feels, "C")}`);
            setText("rideFeelsLike", `Feuchte ${formatPercent(rh, 0)}`);
            setText("rideTempHint", comfort !== null ? `Komfort ${comfort}%` : "Komfort -");

            const wind = series.wind10_speed_ms[idx] ?? features.wind_takeoff[idx];
            const windDir = series.wind10_dir_deg[idx] ?? features.wind_takeoff_dir[idx];
            const gust = series.wind_gusts_ms[idx] ?? features.gust[idx];
            const windRisk = features.ride_wind_risk[idx];
            const windKmh = toKmh(wind);
            const gustKmh = toKmh(gust);
            setText("rideWindValue", `${formatValue(windKmh, "km/h", 0)} | ${toCompass(windDir)}`);
            setText("rideWindGust", `B\u00f6en ${formatValue(gustKmh, "km/h", 0)}`);
            setText("rideWindHint", windRisk !== null && windRisk !== undefined ? `Windrisiko ${Math.round(windRisk * 100)}%` : "Windrisiko -");

            const precipNow = series.precip_mm[idx];
            const precip6 = features.ride_precip_6h[idx];
            const wetness = features.ride_wetness[idx];
            setText("ridePrecipValue", `Regen ${formatValue(precipNow, "mm")}`);
            setText("ridePrecipSum", `6h Summe ${formatValue(precip6, "mm")}`);
            setText("rideWetValue", wetness !== null && wetness !== undefined ? `Nass ${Math.round(wetness * 100)}%` : "Nass -");

            const cloud = series.cloud_total_pct[idx];
            setText("rideSunValue", sunNow !== null ? `Sonne ${formatValue(sunNow, "h", 1)}` : "Sonne -");
            setText("rideCloudValue", `Wolken ${formatPercent(cloud, 0)}`);
            const lightRiskNow = features.ride_light_risk[idx];
            const lightRiskText = lightRiskNow !== null && lightRiskNow !== undefined ? ` | Dunkelrisiko ${Math.round(lightRiskNow * 100)}%` : "";
            setText("rideLightHint", sunNow !== null && sunNow > 0.2 ? "Licht vorhanden" : `Diffus / dunkel${lightRiskText}`);

            const visRisk = features.visibility_risk[idx];
            setText("rideConvRisk", convRisk !== null && convRisk !== undefined ? `Gewitter ${Math.round(convRisk * 100)}%` : "Gewitter -");
            setText("rideVisibilityRisk", visRisk !== null && visRisk !== undefined ? `Sicht ${Math.round(visRisk * 100)}%` : "Sicht -");
        }

        function updateStatus(payload) {
            if (!statusBox || !payload) return;
            const sourceHint = payload.series?.source ? `Modell: ${payload.series.source}` : "";
            statusBox.textContent = sourceHint || "";
            if (alertBox) {
                alertBox.textContent = "";
                alertBox.style.display = "none";
            }
        }

        function populateAvalancheRegionSelect() {
            if (!avalancheRegionSelect) return;
            avalancheRegionSelect.innerHTML = "";
            AVALANCHE_REGIONS.forEach((region) => {
                const opt = document.createElement("option");
                opt.value = region.code;
                opt.textContent = region.label;
                avalancheRegionSelect.appendChild(opt);
            });
        }

        async function updateAvalancheForCurrentSite(regionOverride) {
            if (!currentPayload) return;
            const site = currentPayload.site;
            const region = regionOverride || getAvalancheRegion(site);
            if (avalancheRegionSelect) avalancheRegionSelect.value = region;
            let avalanche = null;
            try {
                avalanche = await fetchAvalancheBulletin(region, site);
            } catch (err) {
                avalanche = null;
            }
            currentPayload.avalanche = avalanche;
            currentPayload.avalanche_region = region;
            updateSkitour(currentPayload);
            updateStatus(currentPayload);
        }

        const buildCrossCountryFallback = (payload) => {
            if (!payload || !payload.series || !payload.features) return null;
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels;
            let idx = pickCurrentIndex(labelsIso);
            if (currentXcDay && currentXcDay !== "all") {
                const scoreSeries = features.tour_score || features.ride_score || features.snow_24h_cm;
                const bestIdx = pickBestIndexForDay(labelsIso, currentXcDay, scoreSeries);
                if (bestIdx !== null && bestIdx !== undefined) idx = bestIdx;
            }
            const tempNow = series.t2m_C?.[idx];
            const snowTemp = tempNow !== null && tempNow !== undefined && !Number.isNaN(tempNow) ? tempNow - 1.5 : null;
            const wetNow = features.ride_wetness?.[idx] ?? features.wet_snow_risk?.[idx];
            const wetness = wetNow !== null && wetNow !== undefined && !Number.isNaN(wetNow) ? clamp(wetNow, 0, 1) : 0.35;
            const precipNow = series.precip_mm?.[idx];
            const snow24 = features.snow_24h_cm?.[idx];
            const tSeries = Array.isArray(series.t2m_C) ? series.t2m_C.slice(0, 48) : [];
            const tValid48 = tSeries.filter((v) => v !== null && v !== undefined && !Number.isNaN(v));
            const tMin48 = tValid48.length ? Math.min(...tValid48) : null;

            const snowState = snowTemp === null
                ? "UNKNOWN"
                : (snowTemp <= -4 ? "COLD_DRY" : (snowTemp <= 0 ? "TRANSFORMED" : (snowTemp <= 2 ? "MOIST" : "WET")));
            const abrasionRisk = (snowTemp !== null && snowTemp <= -6) || (snow24 !== null && snow24 >= 4)
                ? "HIGH"
                : (wetness >= 0.55 ? "LOW" : "MED");

            let planABlock = "HFW2";
            let planAPowder = "UHX_POWDER_MIDDLE";
            let planAStructure = "fein gebrochen";
            let planATrigger = "Auto aus aktuellen Bedingungen";

            if ((snowTemp !== null && snowTemp <= -5) || (tMin48 !== null && tMin48 <= -7)) {
                planABlock = "HFW3";
                planAPowder = "UHX_POWDER_MIDDLE";
                planAStructure = "fein linear";
                planATrigger = `Kalt/hart: SnowTemp_est ${formatValue(snowTemp, "C")} | Tmin48 ${formatValue(tMin48, "C")}`;
            } else if (wetness >= 0.55 || (tempNow !== null && tempNow > 1.5) || (precipNow !== null && precipNow > 0.3)) {
                planABlock = "HFW2";
                planAPowder = "UHX_POWDER_WARM";
                planAStructure = wetness >= 0.7 ? "grob linear" : "mittel-grob linear";
                planATrigger = `Feucht/warm: SnowTemp_est ${formatValue(snowTemp, "C")} | Wet ${formatValue(wetness, "", 2)}`;
            } else if (snowTemp !== null && snowTemp <= -1.5 && wetness < 0.35) {
                planABlock = "HFW2";
                planAPowder = "UHX_POWDER_MIDDLE";
                planAStructure = "fein gebrochen";
                planATrigger = `Trocken/kalt: SnowTemp_est ${formatValue(snowTemp, "C")} | Wet ${formatValue(wetness, "", 2)}`;
            } else {
                planABlock = "HFW2";
                planAPowder = wetness > 0.4 ? "UHX_POWDER_WARM" : "UHX_POWDER_MIDDLE";
                planAStructure = "mittel linear";
                planATrigger = `Mischbedingungen: SnowTemp_est ${formatValue(snowTemp, "C")} | Wet ${formatValue(wetness, "", 2)}`;
            }

            const plans = [
                {
                    name: "Plan A",
                    base: "HWK Racing LF (Universal)",
                    block: planABlock,
                    powder: planAPowder,
                    structure: planAStructure,
                    trigger: planATrigger,
                },
                {
                    name: "Plan B",
                    base: "HWK Racing LF (Universal)",
                    block: "HFW2",
                    powder: "UHX_POWDER_WARM",
                    structure: wetness >= 0.6 ? "grob linear" : "mittel-grob linear",
                    trigger: "Reserve bei feuchter/waermerer Spur",
                },
                {
                    name: "Plan C",
                    base: "HWK Racing LF (Universal)",
                    block: "HFW3",
                    powder: "UHX_POWDER_MIDDLE",
                    structure: (tMin48 !== null && tMin48 <= -7) ? "fein linear" : "fein-mittel linear",
                    trigger: "Reserve bei Auskuehlung/Harsch",
                },
            ];

            const best = features.best_window;
            const raceWindow = best
                ? {
                    start_local: series.labels?.[best.startIdx] || "-",
                    end_local: series.labels?.[best.endIdx] || "-",
                    tz: "lokal",
                }
                : {};

            return {
                plans,
                snow: {
                    state: snowState,
                    confidence: tempNow !== null && tempNow !== undefined && wetNow !== null && wetNow !== undefined ? "HIGH" : "MED",
                    abrasion_risk: abrasionRisk,
                },
                conditions: {
                    t_p50: tempNow ?? null,
                    t_snow_est: snowTemp,
                    wetness_index: wetness,
                },
                race_window: raceWindow,
                do_dont: [
                    `AUTO: Live-Plan aus aktuellen Wetterdaten (${payload.site?.name || "Standort"}).`,
                    wetness >= 0.5 ? "DO: grobere Struktur bei nasser Spur." : "DO: feinere Struktur fuer kalte/trockene Spur.",
                    (tMin48 !== null && tMin48 <= -7) ? "DO: kalte Reserve (Plan C) fuer harte Spur bereithalten." : "DO: Plan B fuer waermere/feuchtere Entwicklung bereithalten.",
                ],
            };
        };

        const normalizeSiteKey = (value) => {
            if (value === null || value === undefined) return "";
            return String(value)
                .normalize("NFD")
                .replace(/[\u0300-\u036f]/g, "")
                .toLowerCase()
                .replace(/[|,;/_-]+/g, " ")
                .replace(/\s+/g, " ")
                .trim();
        };

        const findCrossCountryBlock = (siteName) => {
            if (!siteName || !xcBySite || typeof xcBySite !== "object") return null;
            if (xcBySite[siteName]) return xcBySite[siteName];

            const raw = String(siteName).trim();
            const tokenCandidates = raw.split(/[|\u00b7,]/).map((part) => part.trim()).filter(Boolean);
            for (const token of [raw, ...tokenCandidates]) {
                if (xcBySite[token]) return xcBySite[token];
            }

            const normSite = normalizeSiteKey(raw);
            if (!normSite) return null;
            for (const [key, block] of Object.entries(xcBySite)) {
                const normKey = normalizeSiteKey(key);
                if (!normKey) continue;
                if (normSite === normKey) return block;
                if (normSite.startsWith(`${normKey} `) || normSite.includes(` ${normKey} `)) return block;
                if (normKey.startsWith(`${normSite} `) || normKey.includes(` ${normSite} `)) return block;
            }
            return null;
        };

        function renderCrossCountryLegacy(siteName) {
            const dynamic = buildCrossCountryFallback(currentPayload);
            const fromXc = findCrossCountryBlock(siteName);
            const block = dynamic || fromXc;
            if (!block) {
                setText("waxPlanA", "-");
                setText("waxPlanB", "-");
                setText("waxPlanC", "-");
                setText("snowState", "-");
                setText("snowConfidence", "-");
                setText("abrasionRisk", "-");
                setText("raceWindow", "-");
                setText("conditionsSummary", "-");
                const list = document.getElementById("doDontList");
                if (list) list.innerHTML = "";
                return;
            }
            const plans = block.plans || [];
            const formatPlan = (plan) => {
                if (!plan) return "-";
                const base = plan.base || "";
                const blockWax = plan.block || "";
                const powder = plan.powder || "";
                const structure = plan.structure || "";
                const trigger = plan.trigger ? ` (${plan.trigger})` : "";
                return `${base} | ${blockWax} + ${powder} | Struktur: ${structure}${trigger}`.trim();
            };
            setText("waxPlanA", formatPlan(plans.find((p) => p.name === "Plan A") || plans[0]));
            setText("waxPlanB", formatPlan(plans.find((p) => p.name === "Plan B") || plans[1]));
            setText("waxPlanC", formatPlan(plans.find((p) => p.name === "Plan C") || plans[2]));

            const snow = block.snow || {};
            setText("snowState", snow.state ? snow.state : "-");
            setText("snowConfidence", snow.confidence ? `Conf ${snow.confidence}` : "-");
            setText("abrasionRisk", snow.abrasion_risk ? `Abrasion ${snow.abrasion_risk}` : "-");

            const race = block.race_window || block.raceWindow || {};
            const raceText = race.start_local ? `${race.start_local} - ${race.end_local} ${race.tz || ""}` : "-";
            setText("raceWindow", raceText);

            const cond = block.conditions || {};
            const condText = cond.t_p50 !== null && cond.t_p50 !== undefined
                ? `T p50 ${formatValue(cond.t_p50, "C")} · Snow ${formatValue(cond.t_snow_est, "C")} · Wet ${formatValue(cond.wetness_index, "", 2)}`
                : "-";
            setText("conditionsSummary", condText);

            const list = document.getElementById("doDontList");
            if (list) {
                list.innerHTML = "";
                const entries = block.do_dont || [];
                entries.forEach((text) => {
                    const li = document.createElement("li");
                    li.textContent = text;
                    list.appendChild(li);
                });
            }
        }

        function renderCrossCountry(siteName) {
            renderCrossCountryLegacy(siteName);
            const payload = currentPayload;
            if (!payload || !payload.series || !payload.features) {
                setText("xcSnow24Value", "-");
                setText("xcSnow48Value", "-");
                setText("xcTempValue", "-");
                setText("xcTempRange", "-");
                setText("xcFreezingValue", "-");
                setText("xcFreezingHint", "-");
                setText("xcWetValue", "-");
                setText("xcWetHint", "-");
                return;
            }
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels || [];
            let idx = pickCurrentIndex(labelsIso);
            if (currentXcDay && currentXcDay !== "all") {
                const scoreSeries = features.tour_score || features.ride_score || features.snow_24h_cm;
                const bestIdx = pickBestIndexForDay(labelsIso, currentXcDay, scoreSeries);
                if (bestIdx !== null && bestIdx !== undefined) idx = bestIdx;
            }

            const snow24 = features.snow_24h_cm?.[idx];
            const snow48 = features.snow_48h_cm?.[idx];
            setText("xcSnow24Value", snow24 !== null && snow24 !== undefined ? `${formatValue(snow24, "cm", 1)} / 24h` : "-");
            setText("xcSnow48Value", snow48 !== null && snow48 !== undefined ? `48h ${formatValue(snow48, "cm", 1)} (Proxy)` : "48h -");

            const temp = series.t2m_C?.[idx];
            const tRange = minMax(series.t2m_C || []);
            setText("xcTempValue", formatValue(temp, "C"));
            setText("xcTempRange", `Spanne: ${formatValue(tRange.min, "C")} - ${formatValue(tRange.max, "C")}`);

            const zeroAsl = features.freezing_level_asl?.[idx];
            const zeroAgl = features.freezing_level_agl?.[idx];
            setText("xcFreezingValue", zeroAsl !== null && zeroAsl !== undefined ? `Nullgrad ${formatValue(zeroAsl, "m", 0)} ASL` : "-");
            const zeroHint = zeroAgl !== null && zeroAgl !== undefined
                ? `AGL ${formatValue(zeroAgl, "m", 0)} | T ${formatValue(temp, "C")}`
                : `T ${formatValue(temp, "C")}`;
            setText("xcFreezingHint", zeroHint);

            const wet = features.wet_snow_risk?.[idx];
            const precipNow = series.precip_mm?.[idx];
            setText("xcWetValue", wet !== null && wet !== undefined ? `${Math.round(wet * 100)}%` : "-");
            setText("xcWetHint", `T ${formatValue(temp, "C")} | Regen ${formatValue(precipNow, "mm")}`);
        }

        const chartAvailable = typeof Chart !== "undefined";
        if (!chartAvailable && alertBox) {
            alertBox.textContent = "Charts konnten nicht geladen werden. Bitte Datei in einem Browser \u00f6ffnen (nicht in der VS Code Vorschau).";
            alertBox.style.display = "block";
        }

        const chartDataset = (label, color, fill = false) => ({
            label,
            data: [],
            borderColor: color,
            backgroundColor: fill ? `${color}33` : "transparent",
            borderWidth: 2,
            tension: 0.35,
            pointRadius: 0,
            fill,
        });

        const chartOptions = (unit, suggestedMin, suggestedMax) => ({
            responsive: true,
            maintainAspectRatio: false,
            interaction: { mode: "index", intersect: false },
            scales: {
                x: {
                    ticks: {
                        color: "#9fb2c7",
                        autoSkip: true,
                        maxTicksLimit: 8,
                        maxRotation: 0,
                        minRotation: 0,
                        callback(value, index) {
                            const raw = typeof this.getLabelForValue === "function" ? this.getLabelForValue(value) : value;
                            const dt = parseLocal(raw);
                            if (!dt) return raw;
                            const hh = `${String(dt.getHours()).padStart(2, "0")}:00`;
                            if (index === 0 || dt.getHours() === 0) {
                                const dd = String(dt.getDate()).padStart(2, "0");
                                const mm = String(dt.getMonth() + 1).padStart(2, "0");
                                return `${dd}.${mm} ${hh}`;
                            }
                            return hh;
                        },
                    },
                    grid: { color: "rgba(148, 163, 184, 0.12)" },
                },
                y: {
                    ticks: { color: "#9fb2c7" },
                    grid: { color: "rgba(148, 163, 184, 0.12)" },
                    suggestedMin,
                    suggestedMax,
                    title: {
                        display: !!unit,
                        text: unit || "",
                        color: "#9fb2c7",
                        font: { size: 11 },
                    },
                },
            },
            plugins: {
                legend: { display: true, labels: { color: "#cbd5f5" } },
                tooltip: { mode: "index", intersect: false },
            },
        });

        const makeLineChart = (id, datasets, unit, min, max) => {
            if (!chartAvailable) return null;
            const el = document.getElementById(id);
            if (!el) return null;
            return new Chart(el, {
                type: "line",
                data: { labels: [], datasets },
                options: chartOptions(unit, min, max),
            });
        };

        const makeDualAxisChart = (id, datasetsLeft, datasetsRight, unitLeft, unitRight, minLeft, maxLeft, minRight, maxRight) => {
            if (!chartAvailable) return null;
            const el = document.getElementById(id);
            if (!el) return null;
            const datasets = [
                ...datasetsLeft.map((d) => ({ ...d, yAxisID: "y" })),
                ...datasetsRight.map((d) => ({ ...d, yAxisID: "y1" })),
            ];
            const options = chartOptions(unitLeft, minLeft, maxLeft);
            options.scales.y1 = {
                type: "linear",
                position: "right",
                suggestedMin: minRight ?? undefined,
                suggestedMax: maxRight ?? undefined,
                grid: { drawOnChartArea: false },
                ticks: { color: "#9fb2c7" },
                title: {
                    display: !!unitRight,
                    text: unitRight || "",
                    color: "#9fb2c7",
                    font: { size: 11 },
                },
            };
            return new Chart(el, {
                type: "line",
                data: { labels: [], datasets },
                options,
            });
        };

        const tempChart = makeLineChart("tempChart", [chartDataset("Temperatur", "#f59e0b")], "C");
        const windChart = makeLineChart("windChart", [chartDataset("Wind", "#5de0e6")], "km/h");
        const cloudChart = makeLineChart(
            "cloudChart",
            [chartDataset("Wolken", "#94a3b8", true), chartDataset("Sonne", "#facc15")],
            "%",
            0,
            100
        );
        const precipChart = makeLineChart("precipChart", [chartDataset("Niederschlag", "#38bdf8", true)], "mm", 0, null);
        const maturityChart = makeLineChart(
            "maturityChart",
            [chartDataset("Thermik", "#f97316"), chartDataset("Flyability", "#22d3ee")],
            "Score",
            0,
            1
        );
        const inversionChart = makeLineChart(
            "inversionChart",
            [chartDataset("Inversion Basis", "#a78bfa"), chartDataset("BLH", "#facc15")],
            "m",
            0,
            null
        );
        const lapseChart = makeLineChart(
            "lapseChart",
            [chartDataset("Gradient", "#facc15")],
            "C/100m",
            null,
            null
        );
        const paraAltTempChart = makeLineChart(
            "paraAltTempChart",
            [chartDataset("Temp auf Höhe", "#38bdf8")],
            "C",
            null,
            null
        );
        const paraAltChillChart = makeLineChart(
            "paraAltChillChart",
            [chartDataset("Windchill", "#f59e0b")],
            "C",
            null,
            null
        );
        const airDensityChart = makeDualAxisChart(
            "airDensityChart",
            [chartDataset("Luftdichte", "#22d3ee")],
            [chartDataset("Dichtehöhe", "#f97316")],
            "kg/m³",
            "m",
            null,
            null,
            null,
            null
        );
        const tourBandChart = makeLineChart(
            "tourBandChart",
            [chartDataset("Unter Waldgrenze", "#22d3ee"), chartDataset("Ober Waldgrenze", "#f97316")],
            "Score",
            0,
            100
        );
        const tourHazardChart = makeLineChart(
            "tourHazardChart",
            [chartDataset("Gefahr unter", "#ef4444"), chartDataset("Gefahr ober", "#f59e0b")],
            "%",
            0,
            100
        );
        const snowChart = makeDualAxisChart(
            "snowChart",
            [chartDataset("Neuschnee 24h", "#facc15", true)],
            [{ ...chartDataset("Schneesumme", "#22d3ee"), borderDash: [6, 4] }],
            "cm / 24h",
            "cm kumuliert",
            0,
            null,
            0,
            null
        );
        const windLoadChart = makeLineChart("windLoadChart", [chartDataset("Windverfrachtung", "#fb7185")], "%", 0, 100);
        const wetSnowChart = makeLineChart("wetSnowChart", [chartDataset("Nassschnee", "#38bdf8")], "%", 0, 100);
        const visibilityChart = makeLineChart(
            "visibilityChart",
            [chartDataset("Sicht", "#94a3b8"), chartDataset("Sonne", "#facc15", true)],
            "%",
            0,
            100
        );
        const freezingChart = makeLineChart("freezingChart", [chartDataset("Nullgrad", "#f97316")], "m", 0, null);
        const xcSnowChart = makeDualAxisChart(
            "xcSnowChart",
            [chartDataset("Neuschnee 24h", "#facc15", true)],
            [{ ...chartDataset("Schneesumme", "#22d3ee"), borderDash: [6, 4] }],
            "cm / 24h",
            "cm kumuliert",
            0,
            null,
            0,
            null
        );
        const xcWetSnowChart = makeLineChart("xcWetSnowChart", [chartDataset("Nassschnee", "#38bdf8")], "%", 0, 100);
        const xcVisibilityChart = makeLineChart(
            "xcVisibilityChart",
            [chartDataset("Sicht", "#94a3b8"), chartDataset("Sonne", "#facc15", true)],
            "%",
            0,
            100
        );
        const xcFreezingChart = makeLineChart("xcFreezingChart", [chartDataset("Nullgrad", "#f97316")], "m", 0, null);
        const xcTempChart = makeLineChart("xcTempChart", [chartDataset("Temperatur", "#f59e0b")], "C", null, null);
        const tourAltTempChart = makeLineChart(
            "tourAltTempChart",
            [chartDataset("Temp auf Höhe", "#38bdf8")],
            "C",
            null,
            null
        );
        const tourAltChillChart = makeLineChart(
            "tourAltChillChart",
            [chartDataset("Windchill", "#f59e0b")],
            "C",
            null,
            null
        );
        const rideChart = makeLineChart(
            "rideChart",
            [chartDataset("Ride-Score", "#22d3ee"), chartDataset("Nässe", "#fb7185")],
            "Score",
            0,
            100
        );
        const rideWindChart = makeLineChart(
            "rideWindChart",
            [chartDataset("Wind", "#5de0e6"), chartDataset("Böen", "#f59e0b")],
            "km/h",
            0,
            null
        );
        const ridePrecipChart = makeLineChart(
            "ridePrecipChart",
            [chartDataset("Regen", "#38bdf8", true), chartDataset("6h Summe", "#94a3b8")],
            "mm",
            0,
            null
        );
        const rideTempChart = makeLineChart(
            "rideTempChart",
            [chartDataset("Temperatur", "#f59e0b"), chartDataset("Gefühlt", "#22d3ee")],
            "C",
            null,
            null
        );
        const rideSunChart = makeLineChart(
            "rideSunChart",
            [chartDataset("Sonne", "#facc15", true), chartDataset("Wolken", "#94a3b8")],
            "%",
            0,
            100
        );
        const rideRiskChart = makeLineChart(
            "rideRiskChart",
            [chartDataset("Wind", "#5de0e6"), chartDataset("Nässe", "#fb7185")],
            "%",
            0,
            100
        );

        function updateCharts(payload) {
            if (!chartAvailable || !payload) return;
            const { series, features } = payload;
            const labelsIso = series.labels_iso || series.labels || [];
            const labels = series.labels || labelsIso;
            updateParaDaySelect(labelsIso);
            updateXcDaySelect(labelsIso);
            updateRideDaySelect(labelsIso);

            const paraDayKey = currentParaDay && currentParaDay !== "all" ? currentParaDay : null;
            const paraIndices = paraDayKey ? getDayIndices(labelsIso, paraDayKey) : null;
            const paraLabels = chartLabelsForDayFilter(labelsIso, labels, paraIndices, paraDayKey);

            const rideDayKey = currentRideDay && currentRideDay !== "all" ? currentRideDay : null;
            const rideIndices = rideDayKey ? getDayIndices(labelsIso, rideDayKey) : null;
            const rideLabels = chartLabelsForDayFilter(labelsIso, labels, rideIndices, rideDayKey);

            const xcDayKey = currentXcDay && currentXcDay !== "all" ? currentXcDay : null;
            const xcIndices = xcDayKey ? getDayIndices(labelsIso, xcDayKey) : null;
            const xcLabels = chartLabelsForDayFilter(labelsIso, labels, xcIndices, xcDayKey);

            if (tempChart) {
                tempChart.data.labels = paraLabels;
                tempChart.data.datasets[0].data = filterByIndices(series.t2m_C || [], paraIndices);
                tempChart.update();
            }
            const height = "10";
            const windLayer = features.wind_layers && features.wind_layers[height] ? features.wind_layers[height] : null;
            const windSeries = windLayer ? windLayer.speed : features.wind_takeoff;
            if (windChart) {
                windChart.data.labels = paraLabels;
                windChart.data.datasets[0].data = filterByIndices((windSeries || []).map(toKmh), paraIndices);
                windChart.data.datasets[0].label = "Wind " + height + " m";
                windChart.update();
            }
            if (cloudChart) {
                cloudChart.data.labels = paraLabels;
                cloudChart.data.datasets[0].data = filterByIndices(series.cloud_total_pct || [], paraIndices);
                const sunPct = (series.sunshine_s || []).map((v) =>
                    v === null || v === undefined || Number.isNaN(v) ? null : clamp((v / 3600) * 100, 0, 100)
                );
                cloudChart.data.datasets[1].data = filterByIndices(sunPct, paraIndices);
                cloudChart.update();
            }
            if (precipChart) {
                precipChart.data.labels = paraLabels;
                precipChart.data.datasets[0].data = filterByIndices(series.precip_mm || [], paraIndices);
                precipChart.update();
            }
            if (maturityChart) {
                maturityChart.data.labels = paraLabels;
                maturityChart.data.datasets[0].data = filterByIndices(features.thermal_maturity || [], paraIndices);
                maturityChart.data.datasets[1].data = filterByIndices(features.flyability_prob || [], paraIndices);
                maturityChart.update();
            }
            if (inversionChart) {
                inversionChart.data.labels = paraLabels;
                inversionChart.data.datasets[0].data = filterByIndices(features.inversion_base_agl || [], paraIndices);
                inversionChart.data.datasets[1].data = filterByIndices(features.blh_m || [], paraIndices);
                inversionChart.update();
            }
            if (lapseChart) {
                lapseChart.data.labels = paraLabels;
                lapseChart.data.datasets[0].data = filterByIndices(features.lapse_rate_low || [], paraIndices);
                lapseChart.update();
            }
            if (paraAltTempChart) {
                paraAltTempChart.data.labels = paraLabels;
                const altitudes = getSelectedTourAltitudes();
                paraAltTempChart.data.datasets = altitudes.map((alt, idx) =>
                    chartDataset(String(Math.round(alt)) + "m", TOUR_ALT_COLORS[idx % TOUR_ALT_COLORS.length])
                );
                altitudes.forEach((alt, idx) => {
                    const temps = labelsIso.map((_, i) => temperatureAtAsl(payload.upper, i, alt, payload.site?.elevation_m));
                    paraAltTempChart.data.datasets[idx].data = filterByIndices(temps, paraIndices);
                });
                paraAltTempChart.update();
            }
            if (paraAltChillChart) {
                paraAltChillChart.data.labels = paraLabels;
                const altitudes = getSelectedTourAltitudes();
                paraAltChillChart.data.datasets = altitudes.map((alt, idx) =>
                    chartDataset(String(Math.round(alt)) + "m", TOUR_ALT_COLORS[idx % TOUR_ALT_COLORS.length])
                );
                altitudes.forEach((alt, idx) => {
                    const chills = labelsIso.map((_, i) => {
                        const t = temperatureAtAsl(payload.upper, i, alt, payload.site?.elevation_m);
                        return windChillC(t, 40);
                    });
                    paraAltChillChart.data.datasets[idx].data = filterByIndices(chills, paraIndices);
                });
                paraAltChillChart.update();
            }
            if (airDensityChart) {
                airDensityChart.data.labels = paraLabels;
                const rho = labelsIso.map((_, i) => airDensity(series.t2m_C[i], series.rh2m_pct[i], payload.site?.elevation_m));
                const da = labelsIso.map((_, i) => densityAltitude(series.t2m_C[i], series.rh2m_pct[i], payload.site?.elevation_m));
                airDensityChart.data.datasets[0].data = filterByIndices(rho, paraIndices);
                airDensityChart.data.datasets[0].label = "Luftdichte (kg/m\u00b3)";
                airDensityChart.data.datasets[1].data = filterByIndices(da, paraIndices);
                airDensityChart.data.datasets[1].label = "Dichteh\u00f6he (m)";
                airDensityChart.update();
            }
            if (rideChart) {
                rideChart.data.labels = rideLabels;
                rideChart.data.datasets[0].data = filterByIndices(features.ride_score || [], rideIndices);
                rideChart.data.datasets[1].data = filterByIndices((features.ride_wetness || []).map((v) => (v === null || v === undefined ? null : v * 100)), rideIndices);
                rideChart.update();
            }
            if (rideWindChart) {
                rideWindChart.data.labels = rideLabels;
                rideWindChart.data.datasets[0].data = filterByIndices((series.wind10_speed_ms || []).map(toKmh), rideIndices);
                const gustSeries = series.wind_gusts_ms && series.wind_gusts_ms.length ? series.wind_gusts_ms : (features.gust || []);
                rideWindChart.data.datasets[1].data = filterByIndices(gustSeries.map(toKmh), rideIndices);
                rideWindChart.update();
            }
            if (ridePrecipChart) {
                ridePrecipChart.data.labels = rideLabels;
                ridePrecipChart.data.datasets[0].data = filterByIndices(series.precip_mm || [], rideIndices);
                ridePrecipChart.data.datasets[1].data = filterByIndices(features.ride_precip_6h || [], rideIndices);
                ridePrecipChart.update();
            }
            if (rideTempChart) {
                rideTempChart.data.labels = rideLabels;
                rideTempChart.data.datasets[0].data = filterByIndices(series.t2m_C || [], rideIndices);
                rideTempChart.data.datasets[1].data = filterByIndices(features.ride_feels_like || [], rideIndices);
                rideTempChart.update();
            }
            if (rideSunChart) {
                const sunPct = (series.sunshine_s || []).map((v) =>
                    v === null || v === undefined || Number.isNaN(v) ? null : clamp((v / 3600) * 100, 0, 100)
                );
                rideSunChart.data.labels = rideLabels;
                rideSunChart.data.datasets[0].data = filterByIndices(sunPct, rideIndices);
                rideSunChart.data.datasets[1].data = filterByIndices(series.cloud_total_pct || [], rideIndices);
                rideSunChart.update();
            }
            if (rideRiskChart) {
                rideRiskChart.data.labels = rideLabels;
                rideRiskChart.data.datasets[0].data = filterByIndices((features.ride_wind_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), rideIndices);
                rideRiskChart.data.datasets[1].data = filterByIndices((features.ride_wetness || []).map((v) => (v === null || v === undefined ? null : v * 100)), rideIndices);
                rideRiskChart.update();
            }
            if (xcSnowChart) {
                xcSnowChart.data.labels = xcLabels;
                const snow24Xc = filterByIndices(features.snow_24h_cm || [], xcIndices);
                const snowLabelsIsoXc = filterByIndices(labelsIso || [], xcIndices);
                xcSnowChart.data.datasets[0].data = snow24Xc;
                xcSnowChart.data.datasets[1].data = integrateSnow24Series(snow24Xc, snowLabelsIsoXc, 24);
                xcSnowChart.update();
            }
            if (xcWetSnowChart) {
                xcWetSnowChart.data.labels = xcLabels;
                xcWetSnowChart.data.datasets[0].data = filterByIndices((features.wet_snow_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), xcIndices);
                xcWetSnowChart.update();
            }
            if (xcVisibilityChart) {
                xcVisibilityChart.data.labels = xcLabels;
                xcVisibilityChart.data.datasets[0].data = filterByIndices((features.visibility_risk || []).map((v) => (v === null || v === undefined ? null : v * 100)), xcIndices);
                const sunPct = (series.sunshine_s || []).map((v) =>
                    v === null || v === undefined || Number.isNaN(v) ? null : clamp((v / 3600) * 100, 0, 100)
                );
                xcVisibilityChart.data.datasets[1].data = filterByIndices(sunPct, xcIndices);
                xcVisibilityChart.update();
            }
            if (xcFreezingChart) {
                xcFreezingChart.data.labels = xcLabels;
                xcFreezingChart.data.datasets[0].data = filterByIndices(features.freezing_level_asl || [], xcIndices);
                xcFreezingChart.update();
            }
            if (xcTempChart) {
                xcTempChart.data.labels = xcLabels;
                xcTempChart.data.datasets[0].data = filterByIndices(series.t2m_C || [], xcIndices);
                xcTempChart.update();
            }
            renderThermikMatrix(payload);
        }

        function showThermikTooltip(event) {
            if (!thermikTooltip || !thermikHoverState) return;
            const rect = thermikMatrix.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            const {
                labels,
                labelsIso,
                heightLevels,
                wGrid,
                site,
                padLeft,
                gridTop,
                gridW,
                gridH,
                cellW,
                cellH,
                deckTop,
                cloudBaseByTime,
                blhSeries,
                invSeries,
                zeroSeries,
            } = thermikHoverState;

            if (x < padLeft || x > padLeft + gridW || y < gridTop || y > gridTop + gridH) {
                thermikTooltip.style.display = "none";
                return;
            }
            const col = Math.min(labels.length - 1, Math.max(0, Math.floor((x - padLeft) / cellW)));
            const row = Math.min(heightLevels.length - 1, Math.max(0, Math.floor((y - gridTop) / cellH)));
            const hIndex = heightLevels.length - 1 - row;
            const zAgl = heightLevels[hIndex];
            const zAsl = Math.round(zAgl + (site?.elevation_m || 0));
            const w = wGrid[col] && wGrid[col][hIndex] !== undefined ? wGrid[col][hIndex] : null;
            const timeLabel = labels[col] || labelsIso?.[col] || "-";
            const baseAgl = cloudBaseByTime[col];
            const baseAsl = baseAgl !== null && baseAgl !== undefined ? Math.round(baseAgl + (site?.elevation_m || 0)) : null;
            const deckTopAgl = deckTop[col];
            const deckTopAsl = deckTopAgl !== null && deckTopAgl !== undefined ? Math.round(deckTopAgl + (site?.elevation_m || 0)) : null;
            const blhAgl = blhSeries ? blhSeries[col] : null;
            const invAgl = invSeries ? invSeries[col] : null;
            const zeroAgl = zeroSeries ? zeroSeries[col] : null;
            const blhAsl = blhAgl !== null && blhAgl !== undefined ? Math.round(blhAgl + (site?.elevation_m || 0)) : null;
            const invAsl = invAgl !== null && invAgl !== undefined ? Math.round(invAgl + (site?.elevation_m || 0)) : null;
            const zeroAsl = zeroAgl !== null && zeroAgl !== undefined ? Math.round(zeroAgl + (site?.elevation_m || 0)) : null;

            thermikTooltip.innerHTML = `
        <strong>${timeLabel}</strong>
        <div>Höhe: ${zAsl} m ASL</div>
        <div>Steigen: ${w !== null ? w.toFixed(2) : "-"} m/s</div>
        <div>Wolkenbasis: ${baseAsl !== null ? `${baseAsl} m` : "-"}</div>
        <div>Wolkendecke: ${deckTopAsl !== null ? `${deckTopAsl} m` : "-"}</div>
        <div>BLH: ${blhAsl !== null ? `${blhAsl} m` : "-"}</div>
        <div>Inversion: ${invAsl !== null ? `${invAsl} m` : "-"}</div>
        <div>0°C: ${zeroAsl !== null ? `${zeroAsl} m` : "-"}</div>
    `;
            thermikTooltip.style.display = "block";

            const pad = 10;
            const tipW = thermikTooltip.offsetWidth;
            const tipH = thermikTooltip.offsetHeight;
            const anchorX = padLeft + col * cellW + cellW * 0.5;
            const anchorY = gridTop + row * cellH + cellH * 0.5;
            let left = rect.left + anchorX + pad;
            let top = rect.top + anchorY - tipH - pad;
            if (left + tipW > window.innerWidth) left = rect.left + anchorX - tipW - pad;
            if (top < 8) top = rect.top + anchorY + pad;
            if (top + tipH > window.innerHeight) top = rect.top + anchorY - tipH - pad;
            thermikTooltip.style.left = `${Math.max(8, left)}px`;
            thermikTooltip.style.top = `${Math.max(8, top)}px`;
        }

        function hideThermikTooltip() {
            if (thermikTooltip) thermikTooltip.style.display = "none";
        }

        function updateSiteView(payload) {
            updateHero(payload);
            renderOverview(payload);
            updateCharts(payload);
            updateParagliding(payload);
            renderCrossCountry(payload.site.name);
            updateSkitour(payload);
            updateCycling(payload);
            updateSkitourCharts(payload);
        }

        let siteRequestId = 0;
        async function updateSite(siteName, options = {}) {
            const site = sitesByName[siteName] || siteMeta[0];
            if (!site) return false;
            currentSiteName = site.name;
            // dropdown removed
            populateAvalancheRegionSelect();
            if (statusBox) statusBox.textContent = "Lade Daten...";
            if (alertBox) {
                alertBox.textContent = "";
                alertBox.style.display = "none";
            }
            const reqId = ++siteRequestId;
            activeSiteRequests += 1;
            try {
                const payload = await ensureSite(site);
                if (reqId !== siteRequestId) return false;
                currentPayload = payload;
                updateSiteView(payload);
                updateStatus(payload);
                if (mapInstance && markerInstance) {
                    markerInstance.setLatLng([site.lat, site.lon]);
                    mapInstance.setView([site.lat, site.lon], Math.max(mapInstance.getZoom() || 9, 8));
                    setTimeout(() => mapInstance.invalidateSize(true), 200);
                    scheduleMapOverlayUpdate(120);
                }

                // Keep a stored dataset stamp so we can later refresh only when new data is available.
                if (options && options.datasetStamp) {
                    setStoredDatasetStamp(site, options.datasetStamp);
                } else {
                    // Fire-and-forget (avoid blocking UI). If it fails we simply won't have a stamp.
                    fetchRemoteDatasetStamp(site)
                        .then((stamp) => {
                            if (stamp) setStoredDatasetStamp(site, stamp);
                        })
                        .catch(() => {
                            // ignore
                        });
                }

                return true;
            } catch (err) {
                if (reqId !== siteRequestId) return false;
                if (statusBox && currentPayload?.series?.source) {
                    statusBox.textContent = `Modell: ${currentPayload.series.source}`;
                }
                if (alertBox) {
                    alertBox.textContent = "";
                    alertBox.style.display = "none";
                }
                return false;
            } finally {
                activeSiteRequests = Math.max(0, activeSiteRequests - 1);
            }
        }

        let datasetPollInFlight = false;
        async function refreshIfNewDataset() {
            if (datasetPollInFlight) return;
            datasetPollInFlight = true;
            try {
                if (document.hidden) return;
                if (activeSiteRequests > 0) return;
                const site = sitesByName[currentSiteName] || siteMeta[0];
                if (!site) return;

                const remoteStamp = await fetchRemoteDatasetStamp(site);
                if (!remoteStamp) return;

                const stored = getStoredDatasetStamp(site);
                if (!stored && currentPayload?.site?.name === site.name) {
                    // We already have data; just prime the stamp to avoid an unnecessary reload.
                    setStoredDatasetStamp(site, remoteStamp);
                    return;
                }
                if (stored && stored === remoteStamp) return;

                // New dataset available -> reload the site.
                await updateSite(site.name, { datasetStamp: remoteStamp });
            } finally {
                datasetPollInFlight = false;
            }
        }

        function startAutoRefresh() {
            if (autoRefreshTimer) clearInterval(autoRefreshTimer);
            autoRefreshTimer = setInterval(() => {
                refreshIfNewDataset();
            }, DATASET_POLL_INTERVAL_MS);
        }

        function scheduleThermikMatrixRender(delayMs = 0) {
            if (!currentPayload) return;
            if (thermikRenderTimer) {
                clearTimeout(thermikRenderTimer);
                thermikRenderTimer = null;
            }
            if (thermikRenderRaf !== null) {
                cancelAnimationFrame(thermikRenderRaf);
                thermikRenderRaf = null;
            }
            const run = () => {
                thermikRenderRaf = requestAnimationFrame(() => {
                    thermikRenderRaf = requestAnimationFrame(() => {
                        thermikRenderRaf = null;
                        renderThermikMatrix(currentPayload);
                    });
                });
            };
            if (delayMs > 0) {
                thermikRenderTimer = setTimeout(run, delayMs);
            } else {
                run();
            }
        }

        function resizeVisibleCharts() {
            if (!chartAvailable || typeof Chart === "undefined") return;
            if (typeof Chart.getChart !== "function") return;
            const activePage = document.querySelector(".page.active") || document.body;
            const canvases = Array.from(activePage.querySelectorAll("canvas"));
            canvases.forEach((canvas) => {
                const rect = canvas.getBoundingClientRect();
                if (!rect || rect.width < 32 || rect.height < 32) return;
                const chart = Chart.getChart(canvas);
                if (!chart || typeof chart.resize !== "function") return;
                try {
                    chart.resize();
                    if (typeof chart.update === "function") chart.update("none");
                } catch {
                    // ignore
                }
            });
        }

        let viewportReflowTimer = null;
        let viewportReflowRaf = null;
        function scheduleViewportReflow(delayMs = 0) {
            if (viewportReflowTimer) {
                clearTimeout(viewportReflowTimer);
                viewportReflowTimer = null;
            }
            if (viewportReflowRaf !== null) {
                cancelAnimationFrame(viewportReflowRaf);
                viewportReflowRaf = null;
            }

            const run = () => {
                viewportReflowRaf = requestAnimationFrame(() => {
                    viewportReflowRaf = null;
                    resizeVisibleCharts();
                    scheduleThermikMatrixRender();

                    // iOS Safari/PWA: layout settles slightly after rotation. Run a second pass.
                    setTimeout(() => {
                        resizeVisibleCharts();
                        scheduleThermikMatrixRender();
                        if (mapInstance) mapInstance.invalidateSize(true);
                    }, 260);

                    // Some iOS devices settle late (URL bar / safe areas). Run one more pass.
                    setTimeout(() => {
                        resizeVisibleCharts();
                        scheduleThermikMatrixRender();
                        if (mapInstance) mapInstance.invalidateSize(true);
                    }, 900);
                });
            };

            if (delayMs > 0) viewportReflowTimer = setTimeout(run, delayMs);
            else run();
        }

        function showPage(target) {
            if (pageOverview) pageOverview.classList.toggle("active", target === "overview");
            if (pageParagliding) pageParagliding.classList.toggle("active", target === "paragliding");
            if (pageMap) pageMap.classList.toggle("active", target === "map");
            if (pageCrossCountry) pageCrossCountry.classList.toggle("active", target === "xc");
            if (pageSkitour) pageSkitour.classList.toggle("active", target === "skitour");
            if (pageCycling) pageCycling.classList.toggle("active", target === "cycling");

            if (tabOverview) tabOverview.classList.toggle("active", target === "overview");
            if (tabParagliding) tabParagliding.classList.toggle("active", target === "paragliding");
            if (tabMap) tabMap.classList.toggle("active", target === "map");
            if (tabCrossCountry) tabCrossCountry.classList.toggle("active", target === "xc");
            if (tabSkitour) tabSkitour.classList.toggle("active", target === "skitour");
            if (tabCycling) tabCycling.classList.toggle("active", target === "cycling");

            // Keep the active pill visible on mobile when the tab row is scrollable.
            if (window.matchMedia && window.matchMedia("(max-width: 960px)").matches) {
                const active = document.querySelector(".tabs .tab-btn.active");
                if (active && active.scrollIntoView) {
                    try {
                        active.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "center" });
                    } catch {
                        active.scrollIntoView();
                    }
                }
            }

            if ((target === "paragliding" || target === "map") && mapInstance) {
                setTimeout(() => {
                    mapInstance.invalidateSize(true);
                    if (target === "map") scheduleMapOverlayUpdate(40, { keepIndex: true });
                }, 200);
            }
            if (target === "map") {
                scheduleMapOverlayUpdate(40, { keepIndex: true });
            } else {
                stopMapPlay();
            }
            if (target === "paragliding") {
                scheduleThermikMatrixRender();
                scheduleThermikMatrixRender(260);
            }

            scheduleViewportReflow(80);
        }
        window.showPage = showPage;

        const clampBbox = (bbox, limits) => {
            const south = clamp(bbox.south, limits.south, limits.north);
            const north = clamp(bbox.north, limits.south, limits.north);
            const west = clamp(bbox.west, limits.west, limits.east);
            const east = clamp(bbox.east, limits.west, limits.east);
            return { south, west, north, east };
        };

        const expandBbox = (bbox, ratio, limits) => {
            const latPad = Math.max(0.02, (bbox.north - bbox.south) * ratio);
            const lonPad = Math.max(0.02, (bbox.east - bbox.west) * ratio);
            return clampBbox(
                {
                    south: bbox.south - latPad,
                    west: bbox.west - lonPad,
                    north: bbox.north + latPad,
                    east: bbox.east + lonPad,
                },
                limits,
            );
        };

        const limitBboxSpan = (bbox, maxLatSpan, maxLonSpan, limits) => {
            if (!bbox) return bbox;
            let { south, west, north, east } = bbox;
            const centerLat = (south + north) * 0.5;
            const centerLon = (west + east) * 0.5;
            const latSpan = north - south;
            const lonSpan = east - west;
            if (Number.isFinite(maxLatSpan) && maxLatSpan > 0 && latSpan > maxLatSpan) {
                south = centerLat - maxLatSpan * 0.5;
                north = centerLat + maxLatSpan * 0.5;
            }
            if (Number.isFinite(maxLonSpan) && maxLonSpan > 0 && lonSpan > maxLonSpan) {
                west = centerLon - maxLonSpan * 0.5;
                east = centerLon + maxLonSpan * 0.5;
            }
            return clampBbox({ south, west, north, east }, limits);
        };

        const bboxContains = (outer, inner) => {
            if (!outer || !inner) return false;
            return (
                inner.south >= outer.south &&
                inner.north <= outer.north &&
                inner.west >= outer.west &&
                inner.east <= outer.east
            );
        };

        const toBboxString = (bbox) => `${bbox.south},${bbox.west},${bbox.north},${bbox.east}`;

        const getMapViewBbox = () => {
            if (!mapInstance) return null;
            const bounds = mapInstance.getBounds();
            return {
                south: bounds.getSouth(),
                west: bounds.getWest(),
                north: bounds.getNorth(),
                east: bounds.getEast(),
            };
        };

        const pickNearestTimestampIndex = (timestamps, targetIso) => {
            if (!Array.isArray(timestamps) || !timestamps.length) return 0;
            const target = targetIso ? new Date(targetIso).getTime() : Date.now();
            if (!Number.isFinite(target)) return pickCurrentIndex(timestamps);
            let bestIdx = 0;
            let bestDiff = Infinity;
            for (let i = 0; i < timestamps.length; i += 1) {
                const ts = timestamps[i];
                const t = new Date(ts).getTime();
                if (!Number.isFinite(t)) continue;
                const diff = Math.abs(t - target);
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestIdx = i;
                }
            }
            return bestDiff === Infinity ? 0 : bestIdx;
        };

        const mapRenderTargetForConfig = (config, zoom) => {
            const targetKey = config?.targetKey || "mid";
            const base = MAP_RENDER_TARGET_POINTS[targetKey] || MAP_RENDER_TARGET_POINTS.mid;
            if (zoom >= 11) return Math.round(base * 1.35);
            if (zoom >= 9) return base;
            if (zoom >= 7) return Math.round(base * 0.8);
            return Math.round(base * 0.6);
        };

        const estimateGridStep = (values) => {
            if (!Array.isArray(values) || values.length < 2) return null;
            const sorted = Array.from(new Set(values)).sort((a, b) => a - b);
            if (sorted.length < 2) return null;
            const diffs = [];
            for (let i = 1; i < sorted.length; i += 1) {
                const diff = sorted[i] - sorted[i - 1];
                if (diff > 0) diffs.push(diff);
            }
            if (!diffs.length) return null;
            diffs.sort((a, b) => a - b);
            return diffs[Math.floor(diffs.length / 2)];
        };

        const normalizeGeoCoords = (coords, preferredCrs) => {
            if (!Array.isArray(coords) || coords.length < 2) return null;
            const x = Number(coords[0]);
            const y = Number(coords[1]);
            if (!Number.isFinite(x) || !Number.isFinite(y)) return null;
            const looksLonLat = Math.abs(x) <= 180 && Math.abs(y) <= 90;
            if (looksLonLat) return { lon: x, lat: y };

            const candidates = [];
            if (preferredCrs) candidates.push(preferredCrs);
            candidates.push("EPSG:31287", "EPSG:3857");
            if (typeof proj4 === "function") {
                for (const src of candidates) {
                    if (!src || src === "EPSG:4326") continue;
                    try {
                        const ll = proj4(src, "EPSG:4326", [x, y]);
                        const lon = Number(ll?.[0]);
                        const lat = Number(ll?.[1]);
                        if (Number.isFinite(lat) && Number.isFinite(lon) && Math.abs(lon) <= 180 && Math.abs(lat) <= 90) {
                            return { lon, lat };
                        }
                    } catch {
                        // try next CRS
                    }
                }
            }
            return null;
        };

        const setMapLegend = (config) => {
            if (!mapLegend || !config) return;
            const minLabel = `${Math.round(config.min)} ${config.unit}`;
            const maxLabel = `${Math.round(config.max)} ${config.unit}`;
            const midLabel = `${Math.round((config.min + config.max) / 2)} ${config.unit}`;
            mapLegend.innerHTML = `
                <div class="map-legend-title">${config.label}</div>
                <div class="map-legend-bar" style="background: linear-gradient(90deg, ${config.colors.join(", ")});"></div>
                <div class="map-legend-labels"><span>${minLabel}</span><span>${midLabel}</span><span>${maxLabel}</span></div>
            `;
        };

        const setMapMeta = (config, timestamp, suffix = "") => {
            if (!mapMeta || !config) return;
            const timeLabel = timestamp ? formatLabel(timestamp) : "";
            const suffixLabel = suffix ? ` \u00b7 ${suffix}` : "";
            mapMeta.textContent = timeLabel ? `${config.label} \u00b7 ${timeLabel}${suffixLabel}` : `${config.label}${suffixLabel}`;
        };

        const syncMapTimeUi = () => {
            const count = mapOverlayTimestamps.length;
            const maxIdx = Math.max(0, count - 1);
            mapOverlayIndex = clamp(mapOverlayIndex, 0, maxIdx);
            if (mapTimeRange) {
                mapTimeRange.min = "0";
                mapTimeRange.max = String(maxIdx);
                mapTimeRange.value = String(mapOverlayIndex);
                mapTimeRange.disabled = count <= 1;
            }
            if (mapTimeLabel) {
                const ts = mapOverlayTimestamps[mapOverlayIndex];
                mapTimeLabel.textContent = ts ? formatLabel(ts) : "--";
            }
            if (mapPlayBtn) {
                mapPlayBtn.disabled = count <= 1;
                if (!mapPlayActive) mapPlayBtn.textContent = "Play";
            }
        };

        const stopMapPlay = () => {
            if (mapPlayTimer) {
                clearInterval(mapPlayTimer);
                mapPlayTimer = null;
            }
            mapPlayActive = false;
            if (mapPlayBtn) mapPlayBtn.textContent = "Play";
        };

        const startMapPlay = () => {
            if (mapPlayActive || mapOverlayTimestamps.length <= 1) return;
            mapPlayActive = true;
            if (mapPlayBtn) mapPlayBtn.textContent = "Pause";
            mapPlayTimer = setInterval(() => {
                if (!mapOverlayTimestamps.length) {
                    stopMapPlay();
                    return;
                }
                mapOverlayIndex = (mapOverlayIndex + 1) % mapOverlayTimestamps.length;
                const cache = mapOverlayCache[mapOverlayKey];
                if (!cache) {
                    scheduleMapOverlayUpdate(0, { keepIndex: true });
                    return;
                }
                drawMapOverlayFrame(cache, MAP_OVERLAYS[mapOverlayKey], mapOverlayIndex);
            }, MAP_PLAY_INTERVAL_MS);
        };

        const fetchGeosphereGridForecast = async (resourceId, params, bbox, timeoutMs = FETCH_TIMEOUT_MS, startIso = null, endIso = null) => {
            const query = {
                parameters: params,
                bbox: toBboxString(bbox),
                output_format: "geojson",
            };
            if (startIso) query.start = startIso;
            if (endIso) query.end = endIso;
            const url = buildUrl(`${GEO_BASE}/grid/forecast/${resourceId}`, query);
            return fetchJson(url, timeoutMs);
        };

        const normalizeParamSets = (config) => {
            const candidates = Array.isArray(config?.paramCandidates) && config.paramCandidates.length
                ? config.paramCandidates
                : [config?.params || []];
            return candidates
                .map((entry) => (Array.isArray(entry) ? entry : [entry]))
                .map((entry) => entry.filter(Boolean))
                .filter((entry) => entry.length);
        };

        const hasOverlayPayload = (data) => {
            const features = Array.isArray(data?.features) ? data.features : [];
            const timestamps = Array.isArray(data?.timestamps) ? data.timestamps : [];
            return features.length > 0 && timestamps.length > 0;
        };

        const overlayTimeWindowCandidates = (config) => {
            const nowMs = Date.now();
            const pastH = Number.isFinite(config?.pastHours) ? config.pastHours : 0.5;
            const futureH = Number.isFinite(config?.futureHours) ? config.futureHours : 10;
            const windows = [];
            const addWindow = (past, future) => {
                const startIso = new Date(nowMs - Math.max(0, past) * 3600 * 1000).toISOString();
                const endIso = new Date(nowMs + Math.max(0.5, future) * 3600 * 1000).toISOString();
                windows.push({ startIso, endIso });
            };
            addWindow(pastH, futureH);
            addWindow(Math.min(0.5, pastH), Math.max(1.5, futureH * 0.55));
            addWindow(0, Math.max(1, futureH * 0.35));
            const seen = new Set();
            return windows.filter((w) => {
                const key = `${w.startIso}|${w.endIso}`;
                if (seen.has(key)) return false;
                seen.add(key);
                return true;
            });
        };

        const fetchOverlayDataWithFallback = async (config, viewBbox, limits) => {
            const timeoutMs = Math.max(FETCH_TIMEOUT_MS, config.fetchTimeoutMs || FETCH_TIMEOUT_MS);
            const primaryBounds = limitBboxSpan(
                expandBbox(viewBbox, config.padRatio ?? 0.2, limits),
                config.maxSpanLat,
                config.maxSpanLon,
                limits,
            );
            const fallbackBounds = limitBboxSpan(
                viewBbox,
                Number.isFinite(config.maxSpanLat) ? config.maxSpanLat * 0.8 : null,
                Number.isFinite(config.maxSpanLon) ? config.maxSpanLon * 0.8 : null,
                limits,
            );
            const boundCandidates = [primaryBounds];
            if (!bboxContains(primaryBounds, fallbackBounds)) boundCandidates.push(fallbackBounds);
            const paramSets = normalizeParamSets(config);
            const timeWindows = overlayTimeWindowCandidates(config);
            let lastErr = null;

            for (const bounds of boundCandidates) {
                for (const paramSet of paramSets) {
                    for (const tw of timeWindows) {
                        try {
                            const data = await fetchGeosphereGridForecast(
                                config.resource,
                                paramSet,
                                bounds,
                                timeoutMs,
                                tw.startIso,
                                tw.endIso,
                            );
                            if (hasOverlayPayload(data)) return { data, fetchBounds: bounds, paramsUsed: paramSet };
                            lastErr = new Error("overlay payload empty");
                        } catch (err) {
                            lastErr = err;
                        }
                    }
                }
            }
            throw lastErr || new Error("overlay fetch failed");
        };

        const buildOverlayCache = (data, fetchBounds, config) => {
            const timestamps = Array.isArray(data?.timestamps) ? data.timestamps : [];
            const features = Array.isArray(data?.features) ? data.features : [];
            const points = [];
            for (const feature of features) {
                const ll = normalizeGeoCoords(feature?.geometry?.coordinates, config?.crs);
                if (!ll) continue;
                const params = feature?.properties?.parameters || {};
                points.push({ lat: ll.lat, lon: ll.lon, params });
            }
            if (!points.length) return null;

            const sampleStep = Math.max(1, Math.floor(points.length / 7000));
            const sampleLats = [];
            const sampleLons = [];
            for (let i = 0; i < points.length; i += sampleStep) {
                sampleLats.push(points[i].lat);
                sampleLons.push(points[i].lon);
            }
            const latStep = estimateGridStep(sampleLats) || Math.max(0.01, (fetchBounds.north - fetchBounds.south) / Math.max(24, Math.sqrt(points.length)));
            const lonStep = estimateGridStep(sampleLons) || Math.max(0.01, (fetchBounds.east - fetchBounds.west) / Math.max(24, Math.sqrt(points.length)));

            return {
                fetchedAt: Date.now(),
                fetchBounds,
                timestamps,
                points,
                latStep,
                lonStep,
                frameCache: new Map(),
            };
        };

        const overlayViewSignature = () => {
            if (!mapInstance) return "no-map";
            const center = mapInstance.getCenter();
            const zoom = mapInstance.getZoom();
            const size = mapInstance.getSize();
            return `${zoom}|${center.lat.toFixed(4)}|${center.lng.toFixed(4)}|${size.x}x${size.y}`;
        };

        const drawMapWindArrow = (ctx, x, y, u, v, length) => {
            const mag = Math.sqrt(u * u + v * v);
            if (!Number.isFinite(mag) || mag < 0.35) return;
            const dx = (u / mag) * length;
            const dy = (-v / mag) * length;
            const x2 = x + dx;
            const y2 = y + dy;
            const ang = Math.atan2(dy, dx);
            const head = Math.max(2.5, length * 0.28);

            const drawSegment = (color, width) => {
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + Math.cos(ang + Math.PI * 0.78) * head, y2 + Math.sin(ang + Math.PI * 0.78) * head);
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 + Math.cos(ang - Math.PI * 0.78) * head, y2 + Math.sin(ang - Math.PI * 0.78) * head);
                ctx.stroke();
            };

            drawSegment("rgba(8, 15, 28, 0.72)", 2.4);
            drawSegment("rgba(236, 246, 255, 0.92)", 1.2);
        };

        const renderOverlayCanvas = (cache, config, timeIndex) => {
            if (!mapInstance || !cache || !config) return null;
            const size = mapInstance.getSize();
            const canvas = document.createElement("canvas");
            canvas.width = Math.max(1, Math.round(size.x));
            canvas.height = Math.max(1, Math.round(size.y));
            const ctx = canvas.getContext("2d");
            if (!ctx) return null;

            const center = mapInstance.getCenter();
            const origin = mapInstance.latLngToContainerPoint([center.lat, center.lng]);
            const dxPoint = mapInstance.latLngToContainerPoint([center.lat, center.lng + cache.lonStep]);
            const dyPoint = mapInstance.latLngToContainerPoint([center.lat + cache.latStep, center.lng]);
            const cellW = Math.max(1, Math.abs(dxPoint.x - origin.x));
            const cellH = Math.max(1, Math.abs(dyPoint.y - origin.y));
            const mapBounds = mapInstance.getBounds();
            const south = mapBounds.getSouth();
            const west = mapBounds.getWest();
            const north = mapBounds.getNorth();
            const east = mapBounds.getEast();
            const padLat = cache.latStep * 1.5;
            const padLon = cache.lonStep * 1.5;
            const targetPoints = mapRenderTargetForConfig(config, mapInstance.getZoom());
            const stride = Math.max(1, Math.ceil(cache.points.length / Math.max(2500, targetPoints)));
            const offset = stride > 1 ? (timeIndex % stride) : 0;

            ctx.globalAlpha = config.opacity;
            for (let i = offset; i < cache.points.length; i += stride) {
                const pt = cache.points[i];
                if (!pt) continue;
                if (pt.lat < south - padLat || pt.lat > north + padLat || pt.lon < west - padLon || pt.lon > east + padLon) continue;
                const value = config.value(pt.params, timeIndex);
                if (value === null || value === undefined || Number.isNaN(value)) continue;
                const xy = mapInstance.latLngToContainerPoint([pt.lat, pt.lon]);
                if (xy.x < -cellW || xy.x > size.x + cellW || xy.y < -cellH || xy.y > size.y + cellH) continue;
                ctx.fillStyle = colorRamp(value, config.min, config.max, config.colors);
                ctx.fillRect(xy.x - cellW / 2, xy.y - cellH / 2, cellW, cellH);
            }

            if (typeof config.vector === "function") {
                const arrowTarget = Math.max(450, Math.round(targetPoints * 0.08));
                const arrowStride = Math.max(stride, Math.ceil(cache.points.length / arrowTarget));
                const arrowOffset = arrowStride > 1 ? ((timeIndex * 3) % arrowStride) : 0;
                const bucketSize = 28;
                const occupied = new Set();
                for (let i = arrowOffset; i < cache.points.length; i += arrowStride) {
                    const pt = cache.points[i];
                    if (!pt) continue;
                    if (pt.lat < south - padLat || pt.lat > north + padLat || pt.lon < west - padLon || pt.lon > east + padLon) continue;
                    const vec = config.vector(pt.params, timeIndex);
                    if (!vec) continue;
                    const speed = Math.sqrt((vec.u || 0) * (vec.u || 0) + (vec.v || 0) * (vec.v || 0));
                    if (!Number.isFinite(speed) || speed < 0.8) continue;
                    const xy = mapInstance.latLngToContainerPoint([pt.lat, pt.lon]);
                    if (xy.x < -cellW || xy.x > size.x + cellW || xy.y < -cellH || xy.y > size.y + cellH) continue;
                    const bx = Math.round(xy.x / bucketSize);
                    const by = Math.round(xy.y / bucketSize);
                    const bucketKey = `${bx}:${by}`;
                    if (occupied.has(bucketKey)) continue;
                    occupied.add(bucketKey);
                    const length = clamp(6 + speed * 0.9, 6, 14);
                    drawMapWindArrow(ctx, xy.x, xy.y, vec.u, vec.v, length);
                }
            }
            return canvas;
        };

        const drawMapOverlayFrame = (cache, config, index) => {
            if (!mapInstance || !cache || !config) return false;
            if (!Array.isArray(cache.timestamps) || !cache.timestamps.length) return false;
            mapOverlayIndex = clamp(index, 0, cache.timestamps.length - 1);
            mapOverlayTimestamps = cache.timestamps;
            syncMapTimeUi();

            const frameKey = `${overlayViewSignature()}|${mapOverlayIndex}`;
            let imageUrl = cache.frameCache.get(frameKey);
            if (!imageUrl) {
                const canvas = renderOverlayCanvas(cache, config, mapOverlayIndex);
                if (!canvas) return false;
                try {
                    imageUrl = canvas.toDataURL("image/webp", 0.84);
                } catch {
                    imageUrl = canvas.toDataURL();
                }
                cache.frameCache.set(frameKey, imageUrl);
                while (cache.frameCache.size > MAP_FRAME_CACHE_LIMIT) {
                    const firstKey = cache.frameCache.keys().next().value;
                    cache.frameCache.delete(firstKey);
                }
            }

            const view = mapInstance.getBounds();
            const imageBounds = [[view.getSouth(), view.getWest()], [view.getNorth(), view.getEast()]];
            if (mapOverlayLayer) mapInstance.removeLayer(mapOverlayLayer);
            mapOverlayLayer = L.imageOverlay(imageUrl, imageBounds, { opacity: 1, interactive: false });
            mapOverlayLayer.addTo(mapInstance);
            setMapMeta(config, cache.timestamps[mapOverlayIndex]);
            return true;
        };

        const updateMapOverlay = async (opts = {}) => {
            if (!mapInstance) return;
            if (!pageMap || !pageMap.classList.contains("active")) return;
            const config = MAP_OVERLAYS[mapOverlayKey] || MAP_OVERLAYS.wind;
            setMapLegend(config);
            const limits = config.bounds || GEO_BBOX_NWP;
            const viewBboxRaw = getMapViewBbox();
            if (!viewBboxRaw) return;
            const viewBbox = clampBbox(viewBboxRaw, limits);
            const viewBboxLimited = limitBboxSpan(viewBbox, config.maxSpanLat, config.maxSpanLon, limits);
            const previousTs = mapOverlayTimestamps[mapOverlayIndex] || null;
            const cached = mapOverlayCache[mapOverlayKey];
            const isFresh = cached && (Date.now() - cached.fetchedAt) < (config.ttlMs || 10 * 60 * 1000);
            const canReuse = isFresh && bboxContains(cached.fetchBounds, viewBboxLimited);
            const forceFetch = !!opts.forceFetch;
            let layerCache = cached;

            if (!canReuse || forceFetch) {
                const reqId = ++mapOverlayRequestId;
                try {
                    setMapMeta(config, null, "lade...");
                    const fetched = await fetchOverlayDataWithFallback(config, viewBboxLimited, limits);
                    if (reqId !== mapOverlayRequestId) return;
                    const built = buildOverlayCache(fetched.data, fetched.fetchBounds, config);
                    if (!built || !built.points.length || !built.timestamps.length) {
                        stopMapPlay();
                        mapOverlayTimestamps = [];
                        syncMapTimeUi();
                        if (mapOverlayLayer) {
                            mapInstance.removeLayer(mapOverlayLayer);
                            mapOverlayLayer = null;
                        }
                        setMapMeta(config, null, "keine Daten");
                        return;
                    }
                    mapOverlayCache[mapOverlayKey] = built;
                    layerCache = built;
                } catch (err) {
                    stopMapPlay();
                    if (mapOverlayLayer) {
                        mapInstance.removeLayer(mapOverlayLayer);
                        mapOverlayLayer = null;
                    }
                    const reason = typeof err?.message === "string" && err.message ? err.message : "unbekannt";
                    if (/timed out|abort|aborted/i.test(reason)) setMapMeta(config, null, "Timeout");
                    else setMapMeta(config, null, "Fehler");
                    return;
                }
            }

            if (!layerCache) return;
            mapOverlayTimestamps = layerCache.timestamps || [];
            if (!mapOverlayTimestamps.length) {
                stopMapPlay();
                syncMapTimeUi();
                return;
            }
            if (opts.keepIndex) {
                mapOverlayIndex = clamp(mapOverlayIndex, 0, mapOverlayTimestamps.length - 1);
            } else {
                mapOverlayIndex = pickNearestTimestampIndex(mapOverlayTimestamps, previousTs) || pickCurrentIndex(mapOverlayTimestamps);
            }
            drawMapOverlayFrame(layerCache, config, mapOverlayIndex);
        };

        const scheduleMapOverlayUpdate = (delayMs = 180, opts = {}) => {
            if (mapOverlayTimer) clearTimeout(mapOverlayTimer);
            mapOverlayTimer = setTimeout(() => {
                updateMapOverlay(opts);
            }, Math.max(0, delayMs));
        };

        function initMap() {
            if (typeof L === "undefined") {
                if (alertBox) {
                    alertBox.textContent = "Karte konnte nicht geladen werden. Bitte Datei in einem Browser \u00f6ffnen (nicht in der VS Code Vorschau).";
                    alertBox.style.display = "block";
                }
                return;
            }
            const site = sitesByName[currentSiteName] || siteMeta[0];
            const lat = site ? site.lat : 47.0;
            const lon = site ? site.lon : 13.0;
            mapInstance = L.map("map", { preferCanvas: true }).setView([lat, lon], 8);
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
                maxZoom: 18,
                attribution: "&copy; OpenStreetMap contributors",
            }).addTo(mapInstance);
            markerInstance = L.marker([lat, lon]).addTo(mapInstance);
            mapInstance.on("moveend", () => scheduleMapOverlayUpdate(150, { keepIndex: true }));
            mapInstance.on("zoomend", () => scheduleMapOverlayUpdate(110, { keepIndex: true }));
            setMapLegend(MAP_OVERLAYS[mapOverlayKey] || MAP_OVERLAYS.wind);
            syncMapTimeUi();
            scheduleMapOverlayUpdate(120);
            setTimeout(() => {
                mapInstance.invalidateSize(true);
                scheduleMapOverlayUpdate(80, { keepIndex: true });
            }, 200);
        }
        window.initMap = initMap;

        if (mapLayerButtons.length) {
            mapLayerButtons.forEach((btn) => {
                btn.addEventListener("click", () => {
                    const key = btn.dataset.layer;
                    if (!key || !MAP_OVERLAYS[key]) return;
                    if (key === mapOverlayKey) return;
                    mapOverlayKey = key;
                    mapLayerButtons.forEach((b) => b.classList.toggle("active", b === btn));
                    stopMapPlay();
                    setMapLegend(MAP_OVERLAYS[mapOverlayKey]);
                    scheduleMapOverlayUpdate(0, { keepIndex: false });
                });
            });
        }

        if (mapTimeRange) {
            mapTimeRange.addEventListener("input", () => {
                const idx = Number(mapTimeRange.value);
                if (!Number.isFinite(idx)) return;
                mapOverlayIndex = idx;
                const cache = mapOverlayCache[mapOverlayKey];
                const config = MAP_OVERLAYS[mapOverlayKey] || MAP_OVERLAYS.wind;
                if (cache) drawMapOverlayFrame(cache, config, mapOverlayIndex);
            });
        }

        if (mapPlayBtn) {
            mapPlayBtn.addEventListener("click", () => {
                if (mapPlayActive) stopMapPlay();
                else startMapPlay();
            });
        }

        if (customLocationBtn) {
            customLocationBtn.addEventListener("click", () => {
                resolveCustomLocation();
            });
        }
        if (customLocationInput) {
            customLocationInput.addEventListener("input", () => {
                locationInputPrefilled = false;
                if (alertBox) {
                    alertBox.textContent = "";
                    alertBox.style.display = "none";
                }
                const query = customLocationInput.value.trim();
                if (locationSuggestDebounce) clearTimeout(locationSuggestDebounce);
                locationSuggestReqId += 1;
                if (!query) {
                    hideLocationSuggest();
                    if (statusBox && currentPayload) updateStatus(currentPayload);
                    return;
                }
                hideLocationSuggest();
                locationSuggestDebounce = setTimeout(() => {
                    fetchLocationSuggest(query);
                }, 220);
            });

            const clearPrefilledLocation = () => {
                if (!locationInputPrefilled) return false;
                if (!customLocationInput.value.trim()) {
                    locationInputPrefilled = false;
                    return false;
                }
                customLocationInput.value = "";
                locationInputPrefilled = false;
                hideLocationSuggest();
                if (statusBox && currentPayload) updateStatus(currentPayload);
                return true;
            };
            // On iOS, users may tap into an already-focused input; use click as well as focus.
            customLocationInput.addEventListener("click", () => {
                clearPrefilledLocation();
            });
            customLocationInput.addEventListener("focus", () => {
                if (alertBox) {
                    alertBox.textContent = "";
                    alertBox.style.display = "none";
                }
                if (clearPrefilledLocation()) return;
                const query = customLocationInput.value.trim();
                if (query) fetchLocationSuggest(query);
            });
            customLocationInput.addEventListener("keydown", (event) => {
                // If the field was auto-filled (e.g. device location), typing should replace it.
                if (
                    locationInputPrefilled &&
                    typeof event.key === "string" &&
                    event.key.length === 1 &&
                    !event.ctrlKey &&
                    !event.metaKey &&
                    !event.altKey
                ) {
                    customLocationInput.value = "";
                    locationInputPrefilled = false;
                    hideLocationSuggest();
                }
                if (event.key === "ArrowDown") {
                    event.preventDefault();
                    if (!locationSuggestItems.length) {
                        const query = customLocationInput.value.trim();
                        if (query) fetchLocationSuggest(query);
                        return;
                    }
                    const next = locationSuggestFocus < 0 ? 0 : locationSuggestFocus + 1;
                    setLocationSuggestFocus(next);
                    return;
                }
                if (event.key === "ArrowUp") {
                    if (!locationSuggestItems.length) return;
                    event.preventDefault();
                    const prev = locationSuggestFocus < 0 ? locationSuggestItems.length - 1 : locationSuggestFocus - 1;
                    setLocationSuggestFocus(prev);
                    return;
                }
                if (event.key === "Escape") {
                    hideLocationSuggest();
                    return;
                }
                if (event.key === "Enter") {
                    event.preventDefault();
                    resolveCustomLocation();
                }
            });
        }
        if (pinLocationBtn) {
            pinLocationBtn.addEventListener("click", () => {
                pinCurrentLocation();
            });
        }
        document.addEventListener("click", (event) => {
            if (!locationSuggest || locationSuggest.hidden) return;
            const target = event.target;
            if (locationSuggest.contains(target)) return;
            if (customLocationInput && customLocationInput.contains(target)) return;
            hideLocationSuggest();
        });

        if (avalancheRegionSelect) {
            populateAvalancheRegionSelect();
            avalancheRegionSelect.addEventListener("change", (event) => {
                const site = sitesByName[currentSiteName] || siteMeta[0];
                if (site) setStoredAvalancheRegion(site, event.target.value);
                updateAvalancheForCurrentSite(event.target.value);
            });
        }

        if (tourDaySelect) {
            tourDaySelect.addEventListener("change", (event) => {
                currentTourDay = event.target.value;
                updateSkitour(currentPayload);
                updateSkitourCharts(currentPayload);
            });
        }
        const onParaDayChanged = (value) => {
            currentParaDay = value;
            if (paraDaySelect) paraDaySelect.value = value;
            updateParagliding(currentPayload);
            updateCharts(currentPayload);
            scheduleThermikMatrixRender();
        };
        if (paraDaySelect) {
            paraDaySelect.addEventListener("change", (event) => {
                onParaDayChanged(event.target.value);
            });
        }
        if (rideDaySelect) {
            rideDaySelect.addEventListener("change", (event) => {
                currentRideDay = event.target.value;
                updateCycling(currentPayload);
                updateCharts(currentPayload);
            });
        }
        if (xcDaySelect) {
            xcDaySelect.addEventListener("change", (event) => {
                currentXcDay = event.target.value;
                renderCrossCountry(currentSiteName);
                updateCharts(currentPayload);
            });
        }
        if (thermikMatrix) {
            thermikMatrix.addEventListener("mousemove", showThermikTooltip);
            thermikMatrix.addEventListener("mouseleave", hideThermikTooltip);
        }
        if (tourAltChecks && tourAltChecks.length) {
            tourAltChecks.forEach((el) => {
                el.addEventListener("change", () => {
                    updateSkitour(currentPayload);
                    updateSkitourCharts(currentPayload);
                    updateCharts(currentPayload);
                });
            });
        }
        window.addEventListener("resize", () => {
            scheduleViewportReflow();
        });
        window.addEventListener("orientationchange", () => {
            scheduleViewportReflow(80);
        });
        if (window.visualViewport) {
            window.visualViewport.addEventListener("resize", () => scheduleViewportReflow(60));
        }
        document.addEventListener("visibilitychange", () => {
            if (!document.hidden) {
                refreshIfNewDataset();
            }
        });

        showPage("overview");
        renderPinnedSites();
        (async () => {
            const usedDeviceLocation = await tryLoadDeviceLocationFirst();
            if (!usedDeviceLocation) {
                updateSite(currentSiteName);
            }
            startAutoRefresh();
        })();
    </script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
        if (window.initMap) {
            window.initMap();
        }
    </script>
    <script>
        if ("serviceWorker" in navigator) {
            window.addEventListener("load", () => {
                navigator.serviceWorker.register("./service-worker.js").catch(() => {
                    // ignore
                });
            });
        }
    </script>
</body>

</html>

